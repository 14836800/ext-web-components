<!DOCTYPE HTML>
<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="z-tabs.js"></script>

<script>
function changeProperty() {
  var x = document.getElementById("properties").value;
  document.getElementById("property").innerHTML = x;
}
function changeMethod() {
  var x = document.getElementById("methods").value;
  document.getElementById("method").innerHTML = x;
}
function changeEvent() {
  var x = document.getElementById("events").value;
  document.getElementById("event").innerHTML = x;
}
</script>

</head>
<body>

<div>






<!--
<div class="heading">&lt;ext-tree&gt;&lt;/ext-tree&gt;</div>
-->

<div class="heading">ext-tree</div>
<br>
<pre>he TreeGrid provides a tree-structured UI representation of tree-structured data.
TreeGrids must be bound to a {@link Ext.data.TreeStore}.

TreeGrid supports multiple columns through the {@link #cfg!...</pre>
<br>
<div><b>JavaScript:</b></div>

<pre class="code">
import '@sencha/ext-web-components/lib/ext-tree.component';

treeReady(event) {
  this.TreeCmp = event.detail.cmp;
}
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-tree onready="treeReady"&gt;&lt;/ext-tree&gt;
</pre>


<!--
<pre class="code">
import '@sencha/ext-web-components/lib/ext-tree.component';

class TreeComponentExample {

  onTreeReady(event) {
    this.TreeCmp = event.detail.cmp;
  }

}

window.TreeExample = new TreeComponentExample();
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-tree onready="TreeExample.onTreeReady"&gt;
...
&lt;/ext-tree&gt;
</pre>
-->

<div style="height:300px;">
    <z-tabs>
        <z-tabpanel tabname="properties">
<div class="flex-container">
  <div id="propertylist" class="thelist"><div>properties:</div><div class="select-div"><select id="properties" onchange="changeProperty()" name="properties">
    <option value="DOM tabIndex attribute to set on the
active Focusable child of this container when using the "Roaming tabindex"
technique.
">activeChildTabIndex</option>
    <option value="The item from the {@link #cfg!items #cfg-items}
collection that will be active first. This is usually only meaningful in a
{@link Ext.layout.Card}, where only one item can be active at a time. If
passed a string, it will be assumed to be a {@link Ext.ComponentQuery} selector. A number
will reference an index or a {@link Ext.Component} instance may be passed as
well. An object config will be created as a new component.
">activeItem</option>
    <option value="Specifies the self alignment of this widget in a box layout
">alignSelf</option>
    <option value="Set this to `true`
to enable focusing disabled child items via keyboard.
">allowFocusingDisabledChildren</option>
    <option value="A flag indicating that this component should
be above its floated siblings.

This may be a positive number to prioritize the ordering of multiple visible always on
top components.

This may be set to a *negative* number to prioritize a component to the *bottom* of the
z-index stack.
">alwaysOnTop</option>
    <option value="An object containing ARIA attributes to be set
on this Component's ARIA element. Use this to set the attributes that cannot be
determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.

**Note** that this config is only meaningful at the Component rendering time,
and setting it after that will do nothing.
">ariaAttributes</option>
    <option value="DOM selector for a child element that is to be used
as description for this Component, set in `aria-describedby` attribute.
The selector works the same way as {@link #cfg!ariaLabelledBy #ariaLabelledBy}.
">ariaDescribedBy</option>
    <option value="ARIA label for this Component. It is best to use
{@link #cfg!ariaLabelledBy #ariaLabelledBy} option instead, because screen readers prefer
`aria-labelledby` attribute to `aria-label`. {@link #cfg!ariaLabel #ariaLabel} and
{@link #cfg!ariaLabelledBy #ariaLabelledBy} config options are mutually exclusive.
">ariaLabel</option>
    <option value="DOM selector for a child element that is to be used
as label for this Component, set in `aria-labelledby` attribute.
If the selector is by `{@link #cfg!id #id}`, the label element can be any existing element,
not necessarily a child of the main Component element.

{@link #cfg!ariaLabelledBy #ariaLabelledBy} and {@link #cfg!ariaLabel #ariaLabel} config options are
mutually exclusive, and `{@link #cfg!ariaLabelledBy ariaLabelledBy}` has the higher precedence.
">ariaLabelledBy</option>
    <option value="Set this config to `false` to limit rendering data to just the record's data
or to an object to describe the desired associated data. This data is used to
satisfy the `{@link #cfg!itemTpl itemTpl}`. The default of `true` will gather all associated data
that is currently loaded. This can be expensive. If only a small amount of the
available data is needed, this config can speed up the rendering process.

For example, if an `OrderItem` needs the `Item` data but not its parent `Order`,
this config can be set like so:

     associatedData: {
         item: true
     }

Given the above, only the `item` association (to the `Item` record) will be
gathered into the render data.

For more details, see {@link Ext.data.Model#method!getData getData}.
">associatedData</option>
    <option value="If `true`, child items will be destroyed as soon as they are
{@link #method!remove removed} from this container.
">autoDestroy</option>
    <option value="May be set to `false` for improved layout performance if auto-sizing is not required.

Some versions of Safari, both desktop and mobile, have very slow performance
if the application has deeply nested containers due to the following WebKit
bug: https://bugs.webkit.org/show_bug.cgi?id=150445

Applications that experience performance issues in the affected versions of
Safari may need to turn off autoSizing globally for all `{@link Ext.Container}` instances
by placing the following override in the application's "overrides" directory:

    Ext.define('MyApp.overrides.Container', {
        override: 'Ext.Container',
        config: {
            autoSize: false
        }
    });

Once auto-sizing support has turned off by default, it can be selectively
turned back on only on those container instances that explicitly need auto-sizing
behavior by setting `{@link #cfg!autoSize autoSize}` to `true`.

This option can also be used to allow items to be sized in percentage
units as a workaround for the following browser bug:
https://bugs.webkit.org/show_bug.cgi?id=137730

To illustrate, the following example should render a 200px by 200px green box
(the container) with a yellow box inside of it (the child item).  The child
item's height and width are both set to `'50%'` so the child should render
exactly 100px by 100px in size.

    @example
    Ext.create({
        xtype: 'container',
        renderTo: Ext.getBody(),
        height: 200,
        width: 200,
        style: 'background: green',
        items: [{
            xtype: 'component',
            style: 'background: yellow',
            height: '50%',
            width: '50%'
        }]
    });

All browsers except for Safari render the previous example correctly, but
Safari does not assign a height to the component.  To make percentage-sized
items work in Safari, simply set `{@link #cfg!autoSize autoSize}` to `false` on the container.

Since the underlying implementation works by absolutely positioning the container's
body element, this option can only be used when the container is not
"shrink wrapping" the content in either direction.  When `{@link #cfg!autoSize autoSize}` is
set to `false`, shrink wrapped dimension(s) will collapse to 0.
">autoSize</option>
    <option value="If `true`, then, when {@link #method!showBy #showBy} or {@link #method!alignTo #alignTo} fallback on
constraint violation only takes place along the major align axis.

That is, if alignment `"l-r"` is being used, and `axisLock: true` is used,
then if constraints fail, only fallback to `"r-l"` is considered.
">axisLock</option>
    <option value="Setting this config option adds or removes data bindings for other configs.
For example, to bind the `title` config:

     var panel = Ext.create({
         xtype: 'panel',
         bind: {
             title: 'Hello {user.name}'
         }
     });

To dynamically add bindings:

     panel.setBind({
         title: 'Greetings {user.name}!'
     });

To remove bindings:

     panel.setBind({
         title: null
     });

The bind expressions are presented to `{@link Ext.app.ViewModel#method!bind Ext.app.ViewModel#bind}`. The
`ViewModel` instance is determined by `{@link #method!lookupViewModel lookupViewModel}`.

**Note:** If  bind is passed as a string, it will use the
{@link Ext.Component#property!defaultBindProperty Ext.Component#property-defaultBindProperty} for the binding.
">bind</option>
    <option value="The CSS class to add to this container's body element.
">bodyCls</option>
    <option value="Enables or disables bordering on this component.
The following values are accepted:

- `null` or `true (default): Do nothing and allow the border to be specified
by the theme.
- `false`: suppress the default border provided by the theme.

Please note that enabling bordering via this config will not add a `border-color`
or `border-style` CSS property to the component; you provide the `border-color`
and `border-style` via CSS rule or {@link #cfg!style #style} configuration
(if not already provide by the theme).

## Using {@link #cfg!style #style}:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        style: 'border: 1px solid blue;'
        // ...
    });

## Using CSS:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        cls: 'my-component'
        // ...
    });

And your CSS file:

    .my-component {
        border: 1px solid red;
    }
">border</option>
    <option value="The absolute bottom position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">bottom</option>
    <option value="The number of items an `{@link #cfg!infinite infinite}` list will render beyond those immediately
visible.

To prevent the rendering of items while scrolling, these extra items are
rendered out of view. When the scroller approaches within `minimumBufferSize`
of the end of the rendered range, the extra items trailing the scroll will be
repositioned (and reconfigured) ahead of the scroll.
">bufferSize</option>
    <option value="Animation to be used during transitions of cards.
">cardSwitchAnimation</option>
    <option value="Configure this as `true` to have this Component centered within its Container.
Setting this value to `true` will make this Component become 'positioned', which means
it will no longer participate in the layout of the Container that it resides in.
">centered</option>
    <option value="The CSS class to add to this widget's element, in
addition to the {@link #property!baseCls #baseCls}. In many cases, this property will be specified
by the derived widget class. See {@link #cfg!userCls #userCls} for adding additional CSS
classes to widget instances (such as items in a {@link Ext.Container}).
">cls</option>
    <option value="This config object supplies default for the `{@link #cfg!collapsible collapsible}` config. When that
config is simply `true`, this is the complete config object for the group
collapser.

NOTE: This config cannot be changed after instantiation. Instead, change the
`{@link #cfg!collapsible collapsible}` config.
">collapseDefaults</option>
    <option value="This object configures group collapse. It is only applicable when `{@link #cfg!grouped grouped}`.
Set to `false` to disable group collapsibility. The default value of `true`
uses the `{@link #cfg!collapseDefaults collapseDefaults}` config for the final collapser configuration
object. If this config is an object, it is merged with `{@link #cfg!collapseDefaults collapseDefaults}`
giving this object's properties priority over the defaults.
">collapsible</option>
    <option value="Configure as `true` to display lines between grid cells.
">columnLines</option>
    <option value="This is a config object which is used by columns in this grid to create their
header menus.

The default column menu contains the following items.

- A "Sort Ascending" menu item
- A "Sort Descending" menu item
- A Columns menu item with each of the columns in a sub-menu of check items
  that is used to hide or show each column.
- A "Group by this field" menu item to enable grouping.
- A "Show in groups" check menu item to enable/disable grouping.

These items have {@link #cfg!weight} of `-100`, `-90` and `-80` respectively to
place them at the start of the menu.

This can be configured as `null` to prevent columns from showing a column menu.
">columnMenu</option>
    <option value="Set to `false` to disable column resizing within this grid.
">columnResize</option>
    <option value="An array of column definition objects which define all columns that appear in this grid.
Each column definition provides the header text for the column, and a definition of where
the data for that column comes from.

This can also be a configuration object for a {Ext.grid.header.Container HeaderContainer}
which may override certain default configurations if necessary. For example, the special
layout may be overridden to use a simpler layout, or one can set default values shared
by all columns:

     columns: {
         items: [
             {
                 text: "Column A"
                 dataIndex: "field_A",
                 width: 200
             },{
                 text: "Column B",
                 dataIndex: "field_B",
                 width: 150
             },
             ...
         ]
     }
">columns</option>
    <option value="The config object for the grid's column hide/show menu
">columnsMenuItem</option>
    <option value="A specification of the constraint to apply when {@link #method!showBy #showBy} or {@link #method!alignTo #alignTo}
is called to align a {@link #cfg!floated #floated} or positioned component.

Defaults to the parent container for *positioned* components (components
which have their {@link #cfg!top}, {@link #cfg!right}, {@link #cfg!bottom} or
{@link #cfg!left} set to move them out of their container's layout flow).

Defaults to the viewport for {@link #cfg!floated #floated} components.

May be a {@link Ext.ComponentQuery} selector to find an ancestor
component to constrain within.

May be `false` to specify that constraining is not applied.

You may also specify an element, or a {@link Ext.util.Region}
">constrainAlign</option>
    <option value="The configured element will automatically be added as the content of this
component. When you pass a string, we expect it to be an element id. If the
content element is hidden, we will automatically show it.
">contentEl</option>
    <option value="Enables you to easily control Components inside this Container by
listening to their events and taking some action. For example, if we had a container with
a nested Disable button, and we wanted to hide the Container when the Disable button is
tapped, we could do this:

    @example
    Ext.create({
        xtype: 'container',
        control: {
           'button[text=Disable]': {
               tap: 'hideMe'
           }
        },

        hideMe: function() {
            this.hide();
        }
    });

We used a {@link Ext.ComponentQuery} selector to listen to the {@link Ext.Button#event!tap tap}
event on any {@link Ext.Button} anywhere inside the Container that has the
{@link Ext.Button#cfg!text text} 'Disable'. Whenever a Component matching that selector
fires the `tap` event our `hideMe` function is called. `hideMe` is called with scope:
`this` (e.g. `this` is the Container instance).
">control</option>
    <option value="A string alias, a configuration object or an instance of a `ViewController` for
this container. Sample usage:

    Ext.define('MyApp.UserController', {
        alias: 'controller.user'
    });

    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: 'user'
    });
    // Or
    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: {
            type: 'user',
            someConfig: true
        }
    });

    // Can also instance at runtime
    var ctrl = new MyApp.UserController();
    var view = new UserContainer({
        controller: ctrl
    });
">controller</option>
    <option value="The initial set of data to apply to the `{@link #cfg!tpl #tpl}` to
update the content area of the Component.

**Note:** Data will be appended to any existing data.
">data</option>
    <option value="
Specifies a child Component to receive focus when this Container's {@link #method!focus #method-focus}
method is called. Should be a valid {@link Ext.ComponentQuery} selector.
">defaultFocus</option>
    <option value="If `true`, this component will be the default scope (this pointer) for events
specified with string names so that the scope can be dynamically resolved. The
component will automatically become the defaultListenerScope if a
{@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for some sample
usages.

**NOTE**: This value can only be reliably set at construction time. Setting it
after that time may not correctly rewire all of the potentially effected
listeners.
">defaultListenerScope</option>
    <option value="A set of default configurations to apply to all child Components
in this Container. It's often useful to specify defaults when creating more than one
items with similar configurations. For example here we can specify that each child is a
panel and avoid repeating the xtype declaration for each one:

    @example
    Ext.create({
        xtype: 'container',
        defaults: {
            xtype: 'panel'
        },
        items: [
            {
                html: 'Panel 1'
            },
            {
                html: 'Panel 2'
            }
        ]
    });
">defaults</option>
    <option value="As a {@link Ext.Container}, this config controls the default type of
items that are added.

Non-data items can also be added to this container, and these will pick up this
default. This config will only apply to data items if `{@link #cfg!itemConfig itemConfig}` does not contain
an `{@link #cfg!xtype xtype}` property (which it does by default). This means that data items will
*not* be affected by this config unless an `{@link #cfg!itemConfig itemConfig}` is set that nulls out the
`{@link #cfg!xtype xtype}` (not recommended).
">defaultType</option>
    <option value="Set to `false` to not defer `{@link #cfg!emptyText emptyText}` being applied until the store's first
load.
">deferEmptyText</option>
    <option value="When set to true, tapping on the DataView's background (i.e. not on
an item in the DataView) will deselect any currently selected items.
">deselectOnContainerClick</option>
    <option value="Whether or not this component is disabled
">disabled</option>
    <option value="Set to `true` to disable selection styling. This only affects the presentation
of the selection not the internal selection state.
">disableSelection</option>
    <option value="A property to check on each record to display the disclosure on a per record
basis. This property must be false to prevent the disclosure from being
displayed on the item.
">disclosureProperty</option>
    <option value="Set to `true` to call `show` and `false` to call `hide`. Unlike the `{@link #cfg!hidden hidden}`
config, changing this config will potentially involve animations to show or
hide the component.
">displayed</option>
    <option value="The dock position of this component in its container. Can be `{@link #cfg!left left}`, `{@link #cfg!top top}`, `{@link #cfg!right right}` or
`{@link #cfg!bottom bottom}`.

__Notes__

You must use a HTML5 doctype for {@link #cfg!docked #docked} `{@link #cfg!bottom bottom}` to work. To do this, simply
add the following code to the HTML file:

    <!doctype html>

So your index.html file should look a little like this:

    <!doctype html>
    <html>
        <head>
            <title>MY application title</title>
            ...
">docked</option>
    <option value="Set to `true` to allow this component to be dragged. This can also be the config
object for the `{@link Ext.drag.Source}` that will manage the drag.
">draggable</option>
    <option value="The text to render when the rendering of the item via `{@link #cfg!itemTpl itemTpl}` produces no
text.
">emptyItemText</option>
    <option value="undefined">emptyState</option>
    <option value="The text to display in the view when there is no data to display.
Set this to `true` to display the default message.
">emptyText</option>
    <option value="This component config object is used to create the `{@link #cfg!emptyText emptyText}` component.
">emptyTextDefaults</option>
    <option value="The config to set on the `{@link #cfg!emptyText emptyText}` component to contain the desired text.
">emptyTextProperty</option>
    <option value="Set to `false` to disable column reorder.

**Note**: if `gridviewoptions` plugin is enabled on grids gets
precedence over `{@link #cfg!enableColumnMove enableColumnMove}` for touch supported device.
">enableColumnMove</option>
    <option value="True to enable text selection inside this view.
">enableTextSelection</option>
    <option value="Animation effect to apply when the Component is being shown.  Typically you want to use
an inbound animation type such as 'fadeIn' or 'slideIn'.
">enterAnimation</option>
    <option value="A map of event type to the corresponding handler method
name. This is used internally by native event handling mechanism.
">eventHandlers</option>
    <option value="Animation effect to apply when the Component is being hidden.
">exitAnimation</option>
    <option value="`true` to display the expander to the left of the item text.
`false` to display the expander to the right of the item text.
">expanderFirst</option>
    <option value="`true` to expand only on the click of the expander element. Setting this to
`false` will allow expansion on click of any part of the element.
">expanderOnly</option>
    <option value="The flex of this item *if* this item item is inside a {@link Ext.layout.HBox}
or {@link Ext.layout.VBox} layout.

You can also update the flex of a component dynamically using
the {@link Ext.layout.FlexBox#setItemFlex} method.

When supplied as a string or number this option supports the same syntax
as CSS [flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex).
For example:

    flex: '1 2 auto'

sets `flex-grow` property to `0`, `flex-shrink` to `2` and `flex-basis` to
`'auto'`.

The default `flex-shrink` value for box layout items is set to `0` in the
stylesheet, which is different from the browser's default `flex-shrink` value
of `1`.  This accommodates the majority use case for applications since where
non-flexed components are typically not expected to shrink smaller than their
default size.

For convenience when only a single number is supplied it is used as the value
for both `flex-grow` and `flex-shrink`, for example `flex: 3` is the same as
`flex: '3 3'`

An object form is also accepted:

    flex: {
        grow: 1,
        shrink: 2,
        basis: 'auto'
    }

When the object form is supplied `shrink` always defaults to `0` regardless
of the value of `grow`.

Although `'auto'` is the default value for flex-basis, flex-basis defaults to 0%
when flex is supplied as a single numeric or string value (e.g. `flex: 1`). If
this behavior is not desired either explicitly set flex-basis to `'auto'` or use
the object form to set only grow and/or shrink:

    flex: {
        grow: 2
    }
">flex</option>
    <option value="A Component may be floated above all other components in the application. This means that
the component is absolutely positioned, and will move to the front and occlude other
sibling floated component if clicked.

A Floated component may have floated descendants. It will bring these decendants to the
front with it when brought to the front of its sibling floated components.

By default, descendant floated components are all positioned using the viewport
coordinate system. To make a floating component a positioning parent for descendants,
and have the ancestors positioned relatively, configure the parent floated component
with `{@link #cfg!relative #cfg-relative}: true`.
">floated</option>
    <option value="Enable or disable navigation
with arrow keys for this FocusableContainer. This option may be useful
with nested FocusableContainers, when only the root container should
handle keyboard events.
">focusableContainer</option>
    <option value="CSS class that will be added to focused
component's {@link #property!focusClsEl #focusClsEl}, and removed when component blurs.
">focusCls</option>
    <option value="True to automatically prepend a leaf sorter to the store.
">folderSort</option>
    <option value="Force the component to take up 100% width and height available, by adding it
to {@link Ext.Viewport}.
">fullscreen</option>
    <option value="Set to `false` turn off all grouping.
This setting is only meaningful if the underlying `{@link #cfg!store store}` has a `grouper`.
">grouped</option>
    <option value="The counterpart to `{@link #cfg!groupHeader groupHeader}`, this config controls the footer that is
displayed below each group in a {@link #cfg!grouped grouped} list.

Footers are typically hidden when a group is `collapsed` but this can be
changed using the `footer` option:

     {
         xtype: 'list',
         collapsible: {
             footer: true  // show footers when collapsed
         }
     }
">groupFooter</option>
    <option value="This config is used to configure a header to display above each group in a
{@link #cfg!grouped grouped} list. One of the more common uses of this config
is to set the {@link Ext.dataview.ItemHeader#cfg!tpl}.

     groupHeader: {
         tpl: 'Group: {name}'
     }
">groupHeader</option>
    <option value="undefined">grouping</option>
    <option value="This config provides defaults for the placeholder items rendered for collapsed
groups.
">groupPlaceholder</option>
    <option value="The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">height</option>
    <option value="Whether or not this Component is hidden (its CSS `display` property is set to `none`).

Defaults to `true` for {@link #cfg!floated #floated} Components.
">hidden</option>
    <option value="Animation effect to apply when the Component is being hidden.  Typically you want to use
an outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check
the {@link Ext.fx.Animation#cfg!type Ext.fx.Animation#type} config.
">hideAnimation</option>
    <option value="`true` to hide the grid column headers.
">hideHeaders</option>
    <option value="A String which specifies how this component's DOM element will be hidden. The
accepted values are any of these:

- `'clip'` : Hide using {@link Ext.dom.Element#static-property!CLIP clip}.
- `'display'` : Hide using {@link Ext.dom.Element#static-property!DISPLAY display}.
- `'offsets'` : Hide using positioning {@link Ext.dom.Element#static-property!OFFSETS offsets}.
- `'opacity'` : Hide using {@link Ext.dom.Element#static-property!OPACITY opacity}.
- `'visibility'` : Hide using {@link Ext.dom.Element#static-property!VISIBILITY visibility}.

Hiding using ``display`` results in having no dimensions as well as resetting
scroll positions to 0.

The other modes overcome this but may have different trade-offs in certain
circumstances.
">hideMode</option>
    <option value="When using a {@link #cfg!modal} Component, setting this to `true` will hide
the modal mask and the Container when the mask is tapped on.
">hideOnMaskTap</option>
    <option value="undefined">hideScrollbar</option>
    <option value="undefined">horizontalOverflow</option>
    <option value="Optional HTML content to render inside this Component, or a reference to an
existing element on the page.
">html</option>
    <option value="The **unique id of this component instance.**

It should not be necessary to use this configuration except for singleton objects in
your application. Components created with an id may be accessed globally
using {@link Ext#method!getCmp Ext.getCmp}.

Instead of using assigned ids, use the {@link #cfg!itemId #itemId} config,
and {@link Ext.ComponentQuery} which provides selector-based searching
for Sencha Components analogous to DOM querying. The {@link Ext.Container} class
contains {@link Ext.Container#method!down shortcut methods} to query its descendant Components
by selector.

Note that this id will also be used as the element id for the containing HTML element
that is rendered to the page for this component. This allows you to write id-based CSS
rules to style the specific instance of this component uniquely, and also to select
sub-elements using this component's id as the parent.

**Note**: to avoid complications imposed by a unique id also see `{@link #cfg!itemId #itemId}`.

Defaults to an auto-assigned id.
">id</option>
    <option value="DOM tabIndex attribute to set on
inactive Focusable children of this container when using the "Roaming tabindex"
technique. This value rarely needs to be changed from its default.
">inactiveChildTabIndex</option>
    <option value="Set to `true` to render an alphabet IndexBar docked on the right. This can also
be a config object for the {@link Ext.dataview.IndexBar} component.
">indexBar</option>
    <option value="Set to `true` to if this list should anticipate too many rows to render to the
DOM at one time. When set to `true`, only a fixed number of rows is rendered at
once, depending on the `{@link #cfg!height height}` or `{@link #cfg!maxHeight maxHeight}` of the list.

When using this mode in an auto-height situation (where the `list` should be
the height of its items), a `{@link #cfg!maxHeight maxHeight}` setting is required. This is due to
the fact that the rendered items are absolutely positioned. As such they do not
directly contribute to the list's height.

When `{@link #cfg!maxHeight maxHeight}` is set, however, an infinite list uses that setting to decide
how many items to render **and** will set an appropriate height on its innermost
element, thereby allowing the list to achieve the proper height.

Note that this configuration can not be dynamically changed after the list has
instantiated.
">infinite</option>
    <option value="When set to `true` the items within the DataView will have their display set to
inline-block and be arranged horizontally. By default the items will wrap to
the width of the DataView. Passing an object with `{ wrap: false }` will turn
off this wrapping behavior and overflowed items will need to be scrolled to
horizontally.
">inline</option>
    <option value="A string to add to the immediate parent element of the inner items of this
container. That is, items that are not `{@link #cfg!docked docked}`, `{@link #property!positioned positioned}` or `{@link #cfg!floated floated}`. In
some containers, `{@link #property!positioned positioned}` items may be in this same element.
">innerCls</option>
    <option value="undefined">innerCtHeight</option>
    <option value="undefined">innerWidth</option>
    <option value="
An extra CSS class or classes to augment the {@link #property!classCls #classCls} on an individual instance
">instanceCls</option>
    <option value="True to cause items to act like buttons for interaction styling.
in ButtonMode items will maintain pressed state whenever pressed down.
they will not remove this state for tap distance cancellation or mouse out.
">itemButtonMode</option>
    <option value="An additional CSS class to apply to items within the DataView.
">itemCls</option>
    <option value="The object is used to configure the {@link Ext.grid.Row}.

See the {@link Ext.grid.row#cfg!body} and {@link Ext.grid.row#cfg!expandedField}
configs on the {@link Ext.grid.RowRow class} to easily add extra content to grid
rows.

Be aware that if you specify a {@link Ext.grid.row#cfg!body row body}, you must
configure the owning grid with `{@link #cfg!variableHeights #variableHeights}: true`.
">itemConfig</option>
    <option value="A class to add to the element that immediate wraps the item content produced
by the `{@link #cfg!itemTpl itemTpl}` (the "inner-html" element).
">itemContentCls</option>
    <option value="This object allows you to map {@link Ext.data.Model} fields to specific
configs on component items.

The `{@link #cfg!itemDataMap itemDataMap}` object's keys describe the target objects to receive data
from the associated {@link #cfg!record}. These keys are either `'#'`
(for the item itself) or a {@link Ext.Component#cfg!reference} to
a component contained in the item.

For each target listed in `{@link #cfg!itemDataMap itemDataMap}`, the value is another map describing
the config name (in the key) and the data field name (as the value).

For example:

     itemDataMap: {
         '#': {
             title: 'fullName'
         },
         text: {
             html: 'name'
         }
     }

The above is equivalent to:

     item.setTitle(item.getRecord().get('fullName'));
     item.lookup('text').setHtml(item.getRecord().get('name'));

For more complex mapping of data to item, you should use the data binding as
described in the class documentation.
">itemDataMap</option>
    <option value="An itemId can be used as an alternative way to get a reference to a component when no
object reference is available. Instead of using an `{@link #cfg!id #id}` with {@link Ext#method!getCmp Ext#getCmp},
use `{@link #cfg!itemId itemId}` with {@link Ext.Container#method!getComponent Ext.Container#getComponent} which will retrieve `{@link #cfg!itemId itemId}`'s or
{@link #cfg!id #id}'s. Since `{@link #cfg!itemId itemId}`'s are an index to the container's internal MixedCollection,
the `{@link #cfg!itemId itemId}` is scoped locally to the container - avoiding potential conflicts with
{@link Ext.ComponentManager} which requires a **unique** `{@link #cfg!id #id}`.

Also see {@link #cfg!id #id}, {@link Ext.Container#method!query Ext.Container#query}, {@link Ext.Container#method!down Ext.Container#down} and
{@link Ext.Container#method!child Ext.Container#child}.
">itemId</option>
    <option value="A class to add to the inner element of items.
">itemInnerCls</option>
    <option value="undefined">itemRipple</option>
    <option value="The child items to add to this Container. This is usually an
array of Component configurations or instances, for example:

    @example
    Ext.create({
        xtype: 'container',
        items: [{
            xtype: 'panel',
            html: 'This is an item'
        }]
    });

This may also be specified as an object, the property names of which are `{@link #cfg!itemId itemId}`s, and
the property values are child Component config objects, for example:

    @example
    Ext.create({
        xtype: 'tabpanel',
        items: {
            panel1: {
                xtype: 'panel',
                title: 'First panel'
            },
            panel2: {
                xtype: 'panel',
                title: 'Second panel'
            }
        }
    });
">items</option>
    <option value="Grid Rows are not focusable. Cells are focusable.
">itemsFocusable</option>
    <option value="The `{@link #cfg!tpl tpl}` to use for each of the items displayed in this DataView. This template
produces HTML and can use the follow CSS class names to influence the response
to tapping/clicking child elements:

 - `x-no-ripple` - Disables `{@link #cfg!itemRipple itemRipple}` (primarily for theme-material)
 - `x-item-no-select` - Disables item selection
 - `x-item-no-tap` - Disables all click or tap processing

For example:

     itemTpl: '<div>' +
                  '...' +
                  '<div class="x-item-no-select x-fa fa-gear"></div>' +
                  '...' +
              '</div>'

Because this template produces HTML from record data it can expose applications
to security issues if user-provided data is not properly encoded. For example,
in previous releases this template was:

     itemTpl: '<div>{text}</div>'

If the 'text' field contained HTML scripts, these would be evaluated into
the application. The `{@link #cfg!itemTpl itemTpl}` in version 6.5 is now:

     itemTpl: '<div>{text:htmlEncode}</div>'
">itemTpl</option>
    <option value="An object containing handlers for keyboard events. The property names of this
object are the key name and any modifiers. The values of the properties are the
descriptors of how to handle each event.

The handler descriptor can be simply the handler function(either the
literal function or the method name), or it can be an object with these
properties:

 - `handler`: The function or its name to call to handle the event.
 - `scope`: The this pointer context (can be "this" or "controller").
 - `event`: An optional override of the key event to which to listen.

**Important:** Calls to `setKeyMap` do not replace the entire `{@link #cfg!keyMap keyMap}` but
instead update the provided mappings. That is, unless `null` is passed as the
value of the `{@link #cfg!keyMap keyMap}` which will clear the `{@link #cfg!keyMap keyMap}` of all entries.
">keyMap</option>
    <option value="Enables or disables processing keys in the `{@link #cfg!keyMap keyMap}`. This value starts as
`null` and if it is `null` when `{@link #method!initKeyMap initKeyMap}` is called, it will automatically
be set to `true`. Since `{@link #method!initKeyMap initKeyMap}` is called by `{@link Ext.Component}` at the
proper time, this is not something application code normally handles.
">keyMapEnabled</option>
    <option value="The name of the member that should be used to listen for keydown/keypress events.
This is intended to be controlled at the class level not per instance.
">keyMapTarget</option>
    <option value="Configuration for this Container's layout. Example:

    @example
    Ext.create({
        xtype: 'container',
        layout: {
            type: 'hbox',
            align: 'middle'
        },
        items: [{
            xtype: 'panel',
            flex: 1,
            bodyStyle: {
                background: "#000",
                color:"#fff"
            }
        }, {
           xtype: 'panel',
           flex: 2,
           bodyStyle: {
               background: "#f00",
               color:"#fff"
           }
        }]
    });
">layout</option>
    <option value="The absolute left position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">left</option>
    <option value="
A config object containing one or more event handlers to be added to this object during
initialization. This should be a valid listeners config object as specified in the
{@link Ext.util.Observable#method!addListener addListener} example for attaching
multiple handlers at once.

**DOM events from Ext JS {@link Ext.Component}**

While _some_ Ext JS Component classes export selected DOM events (e.g. "click",
"mouseover" etc), this is usually only done when extra value can be added. For example
the {@link Ext.view.View DataView}'s **`{@link Ext.view.View#itemclick itemclick}`**
event passing the node clicked on. To access DOM events directly from a child element
of a Component, we need to specify the `element` option to identify the Component
property to add a DOM listener to:

    new Ext.panel.Panel({
        width: 400,
        height: 200,
        dockedItems: [{
            xtype: 'toolbar'
        }],
        listeners: {
            click: {
                element: 'el', //bind to the underlying el property on the panel
                fn: function(){ console.log('click el'); }
            },
            dblclick: {
                element: 'body', //bind to the underlying body property on the panel
                fn: function(){ console.log('dblclick body'); }
            }
        }
    });
">listeners</option>
    <option value="If specified, gives an explicit height for a {@link #cfg!floated} data view
when it is showing the {@link #cfg!loadingText #loadingText}, if that is specified. This is
useful to prevent the view's height from collapsing to zero when the loading
mask is applied and there are no other contents in the data view.
">loadingHeight</option>
    <option value="A string to display during data load operations. This text will be displayed
in a loading div and the view's contents will be cleared while loading,
otherwise the view's contents will continue to display normally until the new
data is loaded and the contents are replaced.

**Note**: For virtual stores, the load mask will be shown frequently as the user
scrolls. To inhibit that, set loadingText to the empty string.
">loadingText</option>
    <option value="Set to `true` to maintain the order of rendered items in the DOM `childNodes`. In
an `{@link #cfg!infinite infinite}` list this is not normally done for performance reasons but this can
create accessibility issues.
">maintainChildNodes</option>
    <option value="`true` to enable border management of docked items.  When enabled, borders of docked
items will collapse where they meet to avoid duplicated borders.
">manageBorders</option>
    <option value="The margin to use on this Component. Can be specified as a number (in which
case all edges get the same margin) or a CSS string like '5 10 10 10'
">margin</option>
    <option value="`true` to mark items as dirty when the underlying record has been modified.

By default there is no special styling for dirty items in data views and
{@link Ext.dataview.List}.  When this config is set to `true` each item's
element will have a CSS class name of `x-mark-dirty` added to it.  When the
underlying record for an item has been modified the item will have the `x-dirty`
CSS class.

{@link Ext.grid.Grid} style "dirty" cells using a red triangle icon in
the corner of the cell.  See
{@link Ext.grid.cell.Base#var!$gridcell-dirty-icon $gridcell-dirty-icon}
">markDirty</option>
    <option value="A configuration to allow you to mask this container.

If the value is a string, it will be used as the message config for an
{@link Ext.LoadMask}.

For more precise control over the mask, you can optionally pass an object block with
and xtype of `loadmask`, and an optional `message` value to display a loading mask.
Please refer to the {@link Ext.LoadMask} component to see other configurations.

    @example
    Ext.create({
        xtype: 'container',
        fullscreen: true,
        html: 'Hello World',
        masked: {
            xtype: 'loadmask',
            message: 'My Message'
        }
    });

Alternatively, you can just call the setter at any time with `true`/`false` to show/hide
the mask:

    setMasked(true); //show the mask
    setMasked(false); //hides the mask

There are also two convenient methods, {@link #method!mask #method-mask} and {@link #method!unmask #unmask}, to allow
you to mask and unmask this container at any time.

Remember, the {@link Ext.Viewport} is always a container, so if you want to mask your
whole application at anytime, can call:

    Ext.Viewport.setMasked({
        xtype: 'loadmask',
        message: 'Hello'
    });
">masked</option>
    <option value="The maximum height of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size. Note that this config will not apply if the
Component is 'positioned' (absolutely positioned or centered)
">maxHeight</option>
    <option value="The number of components to cache when no longer needed (as opposed to calling
`destroy` on them).
">maxItemCache</option>
    <option value="The maximum width of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size. Note that this config will not apply if the
Component is 'positioned' (absolutely positioned or centered)
">maxWidth</option>
    <option value="The minimum height of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">minHeight</option>
    <option value="The minimum number of items beyond the visible area of an `{@link #cfg!infinite infinite}` list to
allow before repositioning items on the opposite side to balance the visible
area inside the rendered range.
">minimumBufferDistance</option>
    <option value="The minimum width of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">minWidth</option>
    <option value="`true` to make this Component modal. This will create a mask underneath the
Component that covers its parent and does not allow the user to interact with
any other Components until this Component is dismissed.
">modal</option>
    <option value="This config enables binding to your `{@link Ext.data.Model#cfg!validators Ext.data.Model#validators}`. This
is only processed by form fields (e.g., `Ext.field.*`) at present, however, this
setting is inherited and so can be set on a parent container.

When set to `true` by a component (or by an ancestor container), the `validators`
of for any {@Ext.data.Model record} fields will be used wherever the `value` is
bound to such data fields.

While this config can be set arbitrarily high in the component hierarchy, doing
so can create a lot overhead if most of your form fields do not actually rely on
`validators` in your data model.

Using this setting for a form that is bound to an `{@link Ext.data.Model}` might look
like this:

     {
         xtype: 'panel',
         modelValidation: true,
         items: [{
             xtype: 'textfield',
             bind: '{theUser.firstName}'
         },{
             xtype: 'textfield',
             bind: '{theUser.lastName}'
         },{
             xtype: 'textfield',
             bind: '{theUser.phoneNumber}'
         },{
             xtype: 'textfield',
             bind: '{theUser.email}'
         }]
     }
">modelValidation</option>
    <option value="Configure as `true` to have columns retain their sorted state after other
columns have been clicked upon to sort.

As subsequent columns are clicked upon, they become the new primary sort key.

Clicking on an already sorted column which is *not* the primary sort key does
not toggle its direction. Analogous to bringing a window to the top by
clicking it, this makes that column's field the primary sort key. Subsequent
clicks then toggle it.

Clicking on a primary key column toggles `ASC` -> `DESC` -> no sorter.

The column sorting menu items may be used to toggle the direction without
affecting the sorter priority.

The maximum number of sorters allowed in a Store is configurable via its
underlying data collection. See {@link Ext.util.Collection#cfg!multiSortLimit Ext.util.Collection#multiSortLimit}
">multiColumnSort</option>
    <option value="Name for the widget to be used with {@link Ext.Container#method!lookupName Ext.Container#lookupName}
et al.
">name</option>
    <option value="Set to `true` for this component's `name` property to be tracked by its containing
`nameHolder`.
">nameable</option>
    <option value="When `true` child components are tracked by their `name` property and can be
retrieved using the `{@link #method!lookupName lookupName}` method.
">nameHolder</option>
    <option value="Set to `true` to display a disclosure icon on each list item. The list will
then fire the `{@link #event!disclose disclose}` event, and the event can be stopped before `{@link #event!childtap childtap}`.
By setting this config to a function, the function passed will be called when
the disclosure is tapped. This can be either a function object or the name of
a {@link Ext.app.ViewController} method.

Finally you can specify an object with a `scope` and `handler` property defined.
This will also be bound to the tap event listener and is useful when you want
to change the scope of the handler.
">onItemDisclosure</option>
    <option value="The padding to use on this Component. Can be specified as a number (in which
case all edges get the same padding) or a CSS string like '5 10 10 10'
">padding</option>
    <option value="Whether or not to pin {@link #cfg!pinnedFooter footers} on bottom of item groups
while scrolling.
">pinFooters</option>
    <option value="Whether or not to pin {@link #cfg!pinnedHeader headers} on top of item groups
while scrolling. Only applicable for `{@link #cfg!infinite infinite}` lists.
">pinHeaders</option>
    <option value="A config object for the pinned footer. Only applicable when {@link #cfg!pinFooters #pinFooters}
and {@link #cfg!grouped #grouped} are `true`.
">pinnedFooter</option>
    <option value="undefined">pinnedFooterHeight</option>
    <option value="A config object for the pinned header. Only applicable when {@link #cfg!pinHeaders #pinHeaders}
and {@link #cfg!grouped #grouped} are `true`.
">pinnedHeader</option>
    <option value="undefined">pinnedHeaderHeight</option>
    <option value="This config describes one or more plugin config objects used to create plugin
instances for this component.

Plugins are a way to bundle and reuse custom functionality. Plugins should extend
`{@link Ext.plugin.Abstract}` but technically the only requirement for a valid plugin
is that it contain an `init` method that accepts a reference to its owner. Once
a plugin is created, the owner will call the `init` method, passing a reference
to itself. Each plugin can then call methods or respond to events on its owner
as needed to provide its functionality.

This config's value can take several different forms.

The value can be a single string with the plugin's {@link Ext.enums.Plugin alias}:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: 'listpaging'
     });

In the above examples, the string "listpaging" is the type alias for
`{@link Ext.dataview.plugin.ListPaging}`. The full alias includes the "plugin." prefix
(i.e., 'plugin.listpaging').

The preferred form for multiple plugins or to configure plugins is the
keyed-object form (new in version 6.5):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: {
             pullrefresh: true,
             listpaging: {
                 autoPaging: true,
                 weight: 10
             }
         }
     });

The object keys are the `id`'s as well as the default type alias. This form
allows the value of the `{@link #cfg!plugins plugins}` to be merged from base class to derived class
and finally with the instance configuration. This allows classes to define a
set of plugins that derived classes or instantiators can further configure or
disable. This merge behavior is a feature of the
{@link Ext.Class#cfg!config}.

The `{@link #cfg!plugins plugins}` config can also be an array of plugin aliases (arrays are not
merged so this form does not respect plugins defined by the class author):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

An array can also contain elements that are config objects with a `type`
property holding the type alias:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['pullrefresh', {
             type: 'listpaging',
             autoPaging: true
         }]
     });
">plugins</option>
    <option value="The amount of delay between the `tapstart` and adding the `pressedCls`.
">pressedDelay</option>
    <option value="When `true` item selection is prevented when the user taps a disclose icon.
">preventSelectionOnDisclose</option>
    <option value="When `true` item selection is prevented when the user taps on a `tool`. This
can be overridden on specific tools by placing the `preventSelection` property
on the tool:

     tools: [{
         type: 'gear',
         preventSelection: false
     }]
">preventSelectionOnTool</option>
    <option value="One or more names of config properties that this component should publish
to its ViewModel. Generally speaking, only properties defined in a class config
block (including ancestor config blocks and mixins) are eligible for publishing
to the viewModel. Some components override this and publish their most useful
configs by default.

**Note:** We'll discuss publishing properties **not** found in the config block below.

Values determined to be invalid by component (often form fields and model validations)
will not be published to the ViewModel.

This config uses the `{@link #cfg!reference #cfg-reference}` to determine the name of the data
object to place in the `ViewModel`. If `{@link #cfg!reference reference}` is not set then this config
is ignored.

By using this config and `{@link #cfg!reference #cfg-reference}` you can bind configs between
components. For example:

     ...
         items: [{
             xtype: 'textfield',
             reference: 'somefield',  // component's name in the ViewModel
             publishes: 'value' // value is not published by default
         },{
             ...
         },{
             xtype: 'displayfield',
             bind: 'You have entered "{somefield.value}"'
         }]
     ...

Classes must provide this config as an Object:

     Ext.define('App.foo.Bar', {
         publishes: {
             foo: true,
             bar: true
         }
     });

This is required for the config system to properly merge values from derived
classes.

For instances this value can be specified as a value as show above or an array
or object as follows:

     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: [
             'value',
             'rawValue',
             'dirty'
         ]
     }

     // This achieves the same result as the above array form.
     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: {
             value: true,
             rawValue: true,
             dirty: true
         }
     }

In some cases, users may want to publish a property to the viewModel that is not found
in a class  config block. In these situations, you may utilize {@link #method!publishState #publishState}
if the property has a  setter method. Let's use
{@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:

      setFieldLabel: function(fieldLabel) {
          this.callParent(arguments);
          this.publishState('fieldLabel', fieldLabel);
      }

With the above chunk of code, fieldLabel may now be published to the viewModel.
">publishes</option>
    <option value="A model instance which updates the Component's html based on it's tpl. Similar
to the data configuration, but tied to to a record to make allow dynamic
updates.  This must be a model instance and not a configuration of one.
">record</option>
    <option value="Specifies a name for this component inside its component hierarchy. This name
must be unique within its {@link Ext.Container#cfg!referenceHolder view}
or its {@link Ext.app.ViewController}. See the documentation in
{@link Ext.Container Ext.container.Container} for more information about references.

**Note**: Valid identifiers start with a letter or underscore and are followed
by zero or more additional letters, underscores or digits. References are case
sensitive.
">reference</option>
    <option value="If `true`, this container will be marked as being a point in the hierarchy where
references to items with a specified `reference` config will be held. The container
will automatically become a referenceHolder if a {@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for more information
about references & reference holders.
">referenceHolder</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure this as `true` if you require descendant floated components to be positioned
relative to this component's coordinate space, not the viewport's coordinate space.

*Note:* The coordinate space is this Component's encapsulating element's area. Not that
of the inner element in which static child items are rendered by the layout.
">relative</option>
    <option value="Optional element to render this Component to.
Not required if this component is an {@link Ext.Container#cfg!items item} of a Container
of a Container.
">renderTo</option>
    <option value="*only meaningful on platforms which has space-consuming scroll bars*

Configure as `true` to leave space for a scrollbar to appear even if the
content does not overflow.

This is useful for trees which may expand and collapse causing visual
flickering when scrollbars appear or disappear.
">reserveScrollbar</option>
    <option value="When `true`, FocusableContainer
will reset last focused position whenever focus leaves the container.
Subsequent tabbing into the container will always focus the first eligible
child item.

When `false`, subsequent tabbing into the container will focus the child
item that was last focused before.
">resetFocusPosition</option>
    <option value="The absolute right position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">right</option>
    <option value="Set to truthy, Color or Object value for the ripple.
">ripple</option>
    <option value="Set this to `false` to suppress the borders in between the items in this list.
By default the presence of borders between items is determined by the stylesheet.
">rowLines</option>
    <option value="Configure as `true` to a {@link Ext.grid.column.RowNumberer}
column which gravitates to the start of the grid.

May be a {@link Ext.grid.column.RowNumberer} configuration object. For
instance to set the column title use:

    rowNumbers: {
        text: 'Index'
    }
">rowNumbers</option>
    <option value="Configuration options to make this Component scrollable. Acceptable values are:

- `true` to enable auto scrolling.
- `false` (or `null`) to disable scrolling - this is the default.
- `{@link #cfg!x x}` or `horizontal` to enable horizontal scrolling only
- `{@link #cfg!y y}` or `vertical` to enable vertical scrolling only

Also accepts a configuration object for a `{@link Ext.scroll.Scroller}` if
if advanced configuration is needed.

The getter for this config returns the {@link Ext.scroll.Scroller}
instance.  You can use the Scroller API to read or manipulate the scroll position:

    // scrolls the component to 5 on the x axis and 10 on the y axis
    component.getScrollable().scrollTo(5, 10);
">scrollable</option>
    <option value="This property is placed on the _child items_ added to this container. The value
placed on the child items determines the position of that item with respect to
the data items.

     Ext.Viewport.add({
         xtype: 'dataview',
         itemTpl: '{firstName}',
         data: [
             { firstName: 'Peter'},
             { firstName: 'Raymond'},
             { firstName: 'Egon'},
             { firstName: 'Winston'}
         ],
         items: [{
              xtype: 'component',
              html: 'Always At End!',
              scrollDock: 'end'
         }]
     });

Note, a value of `'top'` is equivalent to `'start'` while `'bottom'` is
equivalent to `'end'`. The `'top'` and `'bottom'` values originated from the
`{@link Ext.dataview.List}` class.
">scrollDock</option>
    <option value="Scroll the DataView to the top when the DataView is refreshed.
">scrollToTopOnRefresh</option>
    <option value="A configuration object which allows passing of configuration options to create or
reconfigure a {@link Ext.grid.selection.Model}.

The following options control what can be selected:

 - {@link Ext.grid.selection.Model#cfg!cells}
 - {@link Ext.grid.selection.Model#cfg!columns}
 - {@link Ext.grid.selection.Model#cfg!rows}

These options control how selections can be made:

 - {@link Ext.grid.selection.Model#cfg!checkbox}
 - {@link Ext.grid.selection.Model#cf!deselectable deselectable}
 - {@link Ext.grid.selection.Model#cfg!drag}
 - {@link Ext.grid.selection.Model#cfg!extensible}
 - {@link Ext.grid.selection.Model#cfg!mode}
 - {@link Ext.grid.selection.Model#cfg!reducible}
">selectable</option>
    <option value="The selected record.
">selection</option>
    <option value="`true` to select the node when clicking the expander.
">selectOnExpander</option>
    <option value="If provided this creates a new `Session` instance for this component. If this
is a `Container`, this will then be inherited by all child components.

To create a new session you can specify `true`:

     Ext.create({
         xtype: 'viewport',
         session: true,

         items: [{
             ...
         }]
     });

Alternatively, a config object can be provided:

     Ext.create({
         xtype: 'viewport',
         session: {
             ...
         },

         items: [{
             ...
         }]
     });
">session</option>
    <option value="Configure as `true` for the component to have a drop shadow. 'false' will suppress any
default shadow. By default the theme will determine the presence of a shadow.
">shadow</option>
    <option value="Set to `true` to allow this component's `name` to be shared by other items in the
same `nameHolder`. Such items will be returned in an array from `lookupName`.
">shareableName</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure as `true` for the component to use an `<iframe>` as an underlay to ensure
certain non-standard browser plugins are occluded by this component.
">shim</option>
    <option value="Animation effect to apply when the Component is being shown.  Typically you want to use
an inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the
{@link Ext.fx.Animation#cfg!type Ext.fx.Animation#type} config.
">showAnimation</option>
    <option value="`true` if only 1 node per branch may be expanded.
">singleExpand</option>
    <option value="Configure as `false` to disable column sorting via clicking the header and via
the Sorting menu items.
">sortable</option>
    <option value="
This config specifies the config properties that will be persisted using the
{@link Ext.state.Provider}. If this config is set to `true`, the
configs specified by `{@link #cfg!statefulDefaults statefulDefaults}` will be assumed.

     stateful: true

Otherwise, this config can be an array of strings of the properties to save:

     stateful: [
         'width',
         'height',
         'collapsed'
     ]

The above is equivalent to:

     stateful: {
         width: true,
         height: true,
         collapsed: true
     }

**Note:** To be truly stateful, an `id` or `{@link #cfg!stateId stateId}` must also be assigned.

A stateful object will save its state when any of these config properties change
value.
">stateful</option>
    <option value="The default set of {@link #cfg!stateful} properties. The form of this config
is the same as {@link #cfg!stateful} except this config cannot be a Boolean.

This config is intended for classes to specify so that instances can simply
enable statefulness using `stateful: true`.
">statefulDefaults</option>
    <option value="The unique id for this object to use for state management purposes.
">stateId</option>
    <option value="Can be either a Store instance or a configuration object that will be turned
into a Store. The Store is used to populate the set of items that will be
rendered in the DataView. See the DataView intro documentation for more
information about the relationship between Store and DataView.
">store</option>
    <option value="Set this to `true` if you want the items in this DataView to be zebra striped.
alternating their background color.
Only applicable if the stylesheet provides styling for alternate items.

By default the stylesheet does not provide styling for DataView items, but it
can be enabled by setting the `{@link #cfg!ui ui}` to `'basic'`.

Lists and Grids provide default styling for striped items
">striped</option>
    <option value="Additional CSS styles that will be rendered into an inline style attribute when
the widget is rendered.

You can pass either a string syntax:

    style: 'background:red'

Or by using an object:

    style: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    style: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
">style</option>
    <option value="DOM tabIndex attribute for this component's
{@link #property!focusEl #focusEl}.
">tabIndex</option>
    <option value="The title that will be displayed in the TitleBar at the top of this Grid.
">title</option>
    <option value="The TitleBar.
">titleBar</option>
    <option value="True to automatically call {@link #method!toFront #toFront} when a {@link #cfg!floated #cfg-floated} Component is
shown.
">toFrontOnShow</option>
    <option value="The tooltip for this component - can be a string to be used as innerHTML
(html tags are accepted) or {@link Ext.tip.ToolTip} config object.

The default behavior is to use a shared tip instance. The tooltip configuration is
registered with the {@link Ext.tip.Manager}. To enable this, your application can set
the {@link Ext.app.Application#cfg!quickTips Ext.app.Application#quickTips} config, or an instance of the
{@link Ext.tip.Manager} may be created manually.

To force a unique tooltip instance to be created, specify `autoCreate: true` on this
configuration.

Configuring this with `autoHide: false` implies `autoCreate: true` so that the desired
persistent behavior can be obtained with other targets still showing the singleton
instance.
">tooltip</option>
    <option value="The absolute top position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">top</option>
    <option value="undefined">topRenderedIndex</option>
    <option value="
Emulates the behavior of the CSS
[touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
property in a cross-browser compatible manner.

Keys in this object are touch action names, and values are `false` to disable
a touch action or `true` to enable it.  Accepted keys are:

- `panX`
- `panY`
- `pinchZoom`
- `doubleTapZoom`

All touch actions are enabled (`true`) by default, so it is usually only necessary
to specify which touch actions to disable.  For example, the following disables
only horizontal scrolling and pinch-to-zoom on the component's main element:

    touchAction: {
        panX: false,
        pinchZoom: false
    }

Touch actions can be specified on reference elements using the reference element
name, for example:

    // disables horizontal scrolling on the main element, and double-tap-zoom
    // on the child element named "body"
    touchAction: {
        panY: false
        body: {
            doubleTapZoom: false
        }
    }

The primary motivation for setting the touch-action of an element is to prevent
the browser's default handling of a gesture such as pinch-to-zoom, or
drag-to-scroll, so that the application can implement its own handling of that
gesture on the element.  Suppose, for example, a component has a custom drag
handler on its element and wishes to prevent horizontal scrolling of its container
while it is being dragged:

    Ext.create('Ext.Widget', {
        touchAction: {
            panX: false
        },
        listeners: {
            drag: function(e) {
                // implement drag logic
            }
        }
    });
">touchAction</option>
    <option value="A {@link String}, {@link Ext.Template}, {@link Ext.XTemplate} or an {@link Array} of
strings to form an {@link Ext.XTemplate}. Used in conjunction with the {@link #cfg!data #data}
and {@link #cfg!tplWriteMode #tplWriteMode} configurations.

__Note__
The {@link #cfg!data #data} configuration _must_ be set for any content to be shown in the
component when using this configuration.
">tpl</option>
    <option value="The Ext.(X)Template method to use when updating the content area of the
Component.

Valid modes are:

- append
- insertAfter
- insertBefore
- insertFirst
- overwrite
">tplWriteMode</option>
    <option value="undefined">translatable</option>
    <option value="Determines what type of touch event is recognized as a touch on the container.
">triggerCtEvent</option>
    <option value="Determines what type of touch event causes an item to be selected.
">triggerEvent</option>
    <option value="This object holds a map of `config` properties that will update their binding
as they are modified. For example, `value` is a key added by form fields. The
form of this config is the same as `{@link #cfg!publishes}`.

This config is defined so that updaters are not created and added for all
bound properties since most cannot be modified by the end-user and hence are
not appropriate for two-way binding.
">twoWayBindable</option>
    <option value="The ui or uis to be used on this Component

When a ui is configured, CSS class names are added to the {@link #property!element #element}, created
by appending the ui name(s) to each {@link #property!classCls #classCls} and/or {@link #property!baseCls #baseCls}.
">ui</option>
    <option value="One or more CSS classes to add to the component's primary element. This config
is intended solely for use by the component instantiator (the "user"), not by
derived classes.

For example:

     items: [{
         xtype: 'button',
         userCls: 'my-button'
     ...
     }]
">userCls</option>
    <option value="
Set to true to allow users to select text within this component.

Can also be any valid value for the CSS3
[user-select](https://developer.mozilla.org/en-US/docs/Web/CSS/user-select) property.

A value of true implies `auto`, while false implies `none`.

May also be an object keyed by child element name.

By default, the user cannot click+drag+select text/elements of the UI.  Applications may
want to enable user selection for specific DOM elements, such as the bodyElement of
a component used as a tab panel.  The tab and tab text would not be user selectable in
this example, but the content area when the tab is selected would.

     userSelectable: {
         element: true,       // allow the element to be user selectable
         bodyElement: true    // allow the component's body element to be user selectable
     }
">userSelectable</option>
    <option value="Setting this to `false` changes the `{@link #cfg!xtype xtype}` of the `{@link #cfg!itemConfig itemConfig}` to the more
flexible {@link Ext.dataview.ListItem} instead of the more efficient
setting of {@link Ext.dataview.SimpleListItem}.
">useSimpleItems</option>
    <option value="Set to `true` if the items in this list do not all have the same height. This
is `false` by default to avoid measure each row to determine its height.
">variableHeights</option>
    <option value="This config is set to `true` when an `{@link #cfg!infinite infinite}` list has vertical overflow.
">verticalOverflow</option>
    <option value="The `ViewModel` is a data provider for this component and its children. The
data contained in the `ViewModel` is typically used by adding `{@link #cfg!bind bind}` configs
to the components that want present or edit this data.

When set, the `ViewModel` is created and links to any inherited `{@link #cfg!viewModel viewModel}`
instance from an ancestor container as the "parent". The `ViewModel` hierarchy,
once established, only supports creation or destruction of children. The
parent of a `ViewModel` cannot be changed on the fly.

If this is a root-level `ViewModel`, the data model connection is made to this
component's associated `{@link Ext.data.Session}`. This is
determined by calling `getInheritedSession`.
">viewModel</option>
    <option value="The height of the container in pixels. This is a config to simplify processing
changes in container height.
">visibleHeight</option>
    <option value="undefined">visibleLeft</option>
    <option value="The top-most visible pixel coordinate. This is the same as the `{@link #cfg!y y}` value of
the `Scroller` but is a config to simplify processing scrolling changes.
">visibleTop</option>
    <option value="undefined">visibleWidth</option>
    <option value="This value controls this item's order in a {@link Ext.Container#cfg!weighted}
{@link Ext.Container} (see {@link #cfg!parent}).

Lower values gravitate towards the start of the container - the top in vertical layouts,
the locale start side in horizontal layouts.
">weight</option>
    <option value="If set to `true`, then child {@link #cfg!items} may be specified as a object,
with each property name specifying an {@link #cfg!itemId}, and the property
value being the child item configuration object.

When using this scheme, each child item may contain a {@link #cfg!weight}
configuration value which affects its order in this container. Lower weights
are towards the start, higher weights towards the end.
">weighted</option>
    <option value="The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">width</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
">x</option>
    <option value="The `{@link #cfg!xtype xtype}` configuration option can be used to optimize Component creation and rendering.
It serves as a shortcut to the full component name. For example, the component
`Ext.button.Button` has an xtype of `button`.

You can define your own xtype on a custom {@link Ext.Component} like so:

    Ext.define('PressMeButton', {
        extend: 'Ext.button.Button',
        xtype: 'pressmebutton',
        text: 'Press Me'
    });

Any Component can be created implicitly as an object config with an xtype specified,
allowing it to be declared and passed into the rendering pipeline without actually being
instantiated as an object. Not only is rendering deferred, but the actual creation of the
object itself is also deferred, saving memory and resources until they are actually needed.
In complex, nested layouts containing many Components, this can make a noticeable
improvement in performance.

    // Explicit creation of contained Components:
    var panel = new Ext.Panel({
       // ...
       items: [
          Ext.create('Ext.button.Button', {
             text: 'OK'
          })
       ]
    });

    // Implicit creation using xtype:
    var panel = new Ext.Panel({
       // ...
       items: [{
          xtype: 'button',
          text: 'OK'
       }]
    });

In the first example, the button will always be created immediately during the panel's
initialization. With many added Components, this approach could potentially slow the
rendering of the page. In the second example, the button will not be created or rendered
until the panel is actually displayed in the browser. If the panel is never displayed
(for example, if it is a tab that remains hidden) then the button will never be created and
will never consume any resources whatsoever.
">xtype</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
">y</option>
    <option value="The z-index to give this Component when it is rendered.

Not valid for {@link #cfg!floated #cfg-floated} Components. The Z ordering of {@link #cfg!floated #cfg-floated}
Components is managed by ordering of the DOM elements.
">zIndex</option>
</select></div>
</div>
  <div id="property" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="methods">
<div class="flex-container">
  <div id="methodlist" class="thelist"><div>methods:</div><div class="select-div"><select id="methods" onchange="changeMethod()" name="methods">
    <option value="Adds declarative listeners as nested arrays of listener objects.
">_addDeclaredListeners</option>
    <option value="Sets up a reference on our current reference holder.
">_fixReference</option>
    <option value="This method is called before `{@link #method!destroy destroy}` to ensure that this instance's `{@link #cfg!stateful stateful}`
properties are saved to persistent storage. Since this object is about to be
destroyed, this cannot be delayed.
">_flushStateful</option>
    <option value="Returns the state id for this object.
">_getStateId</option>
    <option value="Creates a particular plugin type if defined in the `{@link #cfg!plugins plugins}` configuration.
">activatePlugin</option>
    <option value="Adds one or more Components to this Container. Example:

    var myPanel = Ext.create({
        xtype: 'panel',
        html : 'This will be added to a Container'
    });

    var items = myContainer.add([myPanel]); // Array returned
    var item  = myContainer.add(myPanel);   // One item is returned
">add</option>
    <option value="Alias for {@link #method!onAfter #onAfter}.
">addAfterListener</option>
    <option value="Alias for {@link #method!onBefore #onBefore}.
">addBeforeListener</option>
    <option value="Adds a CSS class (or classes) to this Component's rendered element.
">addCls</option>
    <option value="Adds a listeners with the "delegate" event option.  Users should not invoke this
method directly.  Use the "delegate" event option of
{@link Ext.util.Observable#method!addListener addListener} instead.
">addDelegatedListener</option>
    <option value="This method applies a versioned, deprecation declaration to this class. This
is typically called by the `deprecated` config.
">addDeprecations</option>
    <option value="Adds an element reference to this Widget instance.
">addElementReference</option>
    <option value="Reduces instantiation time for a Widget by lazily instantiating Ext.Element
references the first time they are used.  This optimization only works for elements
with no listeners specified.
">addElementReferenceOnDemand</option>
    <option value="The {@link #method!on #on} method is shorthand for
{@link Ext.util.Observable#method!addListener addListener}.

Appends an event handler to this object.  For example:

    myGridPanel.on("itemclick", this.onItemClick, this);

The method also allows for a single argument to be passed which is a config object
containing properties which specify multiple events. For example:

    myGridPanel.on({
        cellclick: this.onCellClick,
        select: this.onSelect,
        viewready: this.onViewReady,
        scope: this // Important. Ensure "this" is correct during handler execution
    });

One can also specify options for each event handler separately:

    myGridPanel.on({
        cellclick: {fn: this.onCellClick, scope: this, single: true},
        viewready: {fn: panel.onViewReady, scope: panel}
    });

*Names* of methods in a specified scope may also be used:

    myGridPanel.on({
        cellclick: {fn: 'onCellClick', scope: this, single: true},
        viewready: {fn: 'onViewReady', scope: panel}
    });
">addListener</option>
    <option value="The addManagedListener method is used when some object (call it "A") is listening
to an event on another observable object ("B") and you want to remove that listener
from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
all of its listeners will be removed at that time.

Example:

    Ext.define('Foo', {
        extend: 'Ext.Component',

        initComponent: function () {
            this.addManagedListener(MyApp.SomeSharedMenu, 'show', this.doSomething);
            this.callParent();
        }
    });

As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.

As of version 5.1 it is no longer necessary to use this method in most cases because
listeners are automatically managed if the scope object provided to
{@link Ext.util.Observable#method!addListener addListener} is an Observable instance.
However, if the observable instance and scope are not the same object you
still need to use `{@link #method!mon mon}` or `{@link #method!addManagedListener addManagedListener}` if you want the listener to be
managed.
">addManagedListener</option>
    <option value="Adds a plugin. For example:

     list.addPlugin('pullrefresh');

Or:

     list.addPlugin({
         type: 'pullrefresh',
         pullRefreshText: 'Pull to refresh...'
     });
">addPlugin</option>
    <option value="Used to handle joining of a record to a tpl
">afterEdit</option>
    <option value="Used to handle joining of a record to a tpl
">afterErase</option>
    <option value="This method is called after the component is initially added to the DOM. If this
component {@link Ext.Container} other components, the `{@link #method!afterRender afterRender}` method
for child components is called *before* the parent's `{@link #method!afterRender afterRender}`.

Implementations of this method should avoid reading from the DOM but are free to
write to the DOM as needed. To read the DOM, consider implementing
{@link #method!onRender onRender} instead.

This method is not generally needed because components always have their own DOM
{@link #property!element} and these are maintained by config property
updaters prior to insertion in the DOM. In general, it is always best to manipulate
the component's elements outside the DOM where there is no associated reflow or
layout cost. This method is useful for situations where the component's elements
must be in the DOM in order to be manipulated correctly.
">afterRender</option>
    <option value="undefined">alignTo</option>
    <option value="Animates to the supplied `{@link #cfg!activeItem activeItem}` with a specified animation. Currently this only works
with a Card layout.  This passed animation will override any default animations on the
container, for a single card switch. The animation will be destroyed when complete.
">animateActiveItem</option>
    <option value="undefined">applyActiveItem</option>
    <option value="undefined">applyBind</option>
    <option value="undefined">applyCentered</option>
    <option value="undefined">applyControl</option>
    <option value="Applies the container's {@link #cfg!defaults #defaults} onto a child item. The item
can be a config object or an instance but has to be an inner item.
">applyItemDefaults</option>
    <option value="Changes the {@link #cfg!masked #masked} configuration when its setter is called, which will convert the
value into a proper object/instance of {@link Ext.Mask}/{@link Ext.LoadMask}. If a mask
already exists, it will use that instead.
">applyMasked</option>
    <option value="Applier for the `{@link #cfg!plugins plugins}` config property.
">applyPlugins</option>
    <option value="Transforms a Session config to a proper instance.
">applySession</option>
    <option value="undefined">applyStyle</option>
    <option value="undefined">applyTpl</option>
    <option value="Transforms a ViewModel config to a proper instance.
">applyViewModel</option>
    <option value="Sets up a component name reference.
">attachNameRef</option>
    <option value="Sets up a component reference.
">attachReference</option>
    <option value="undefined">beforeInitialize</option>
    <option value="undefined">blur</option>
    <option value="Bubbles up the {@link #method!getRefOwner} hierarchy, calling the specified function
with each component. The scope (`this` reference) of the function call will be the
scope provided or the current component. The arguments to the function will
be the args provided or the current component. If the function returns false at any
point, the bubble is stopped.
">bubble</option>
    <option value="Call the original method that was previously overridden with {@link Ext.Base#static-method!override Ext.Base#override}

    Ext.define('My.Cat', {
        constructor: function() {
            alert("I'm a cat!");
        }
    });

    My.Cat.override({
        constructor: function() {
            alert("I'm going to be a cat!");

            this.callOverridden();

            alert("Meeeeoooowwww");
        }
    });

    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
                              // alerts "I'm a cat!"
                              // alerts "Meeeeoooowwww"
">callOverridden</option>
    <option value="Call the "parent" method of the current method. That is the method previously
overridden by derivation or by an override (see {@link Ext#method!define Ext#define}).

     Ext.define('My.Base', {
         constructor: function(x) {
             this.x = x;
         },

         statics: {
             method: function(x) {
                 return x;
             }
         }
     });

     Ext.define('My.Derived', {
         extend: 'My.Base',

         constructor: function() {
             this.callParent([21]);
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // alerts 21

This can be used with an override as follows:

     Ext.define('My.DerivedOverride', {
         override: 'My.Derived',

         constructor: function(x) {
             this.callParent([x*2]); // calls original My.Derived constructor
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // now alerts 42

This also works with static and private methods.

     Ext.define('My.Derived2', {
         extend: 'My.Base',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Base.method
             }
         }
     });

     alert(My.Base.method(10));     // alerts 10
     alert(My.Derived2.method(10)); // alerts 20

Lastly, it also works with overridden static methods.

     Ext.define('My.Derived2Override', {
         override: 'My.Derived2',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Derived2.method
             }
         }
     });

     alert(My.Derived2.method(10); // now alerts 40

To override a method and replace it and also call the superclass method, use
{@link #method!callSuper #method-callSuper}. This is often done to patch a method to fix a bug.
">callParent</option>
    <option value="This method is used by an **override** to call the superclass method but
bypass any overridden method. This is often done to "patch" a method that
contains a bug but for whatever reason cannot be fixed directly.

Consider:

     Ext.define('Ext.some.Class', {
         method: function() {
             console.log('Good');
         }
     });

     Ext.define('Ext.some.DerivedClass', {
         extend: 'Ext.some.Class',

         method: function() {
             console.log('Bad');

             // ... logic but with a bug ...

             this.callParent();
         }
     });

To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
override:

     Ext.define('App.patches.DerivedClass', {
         override: 'Ext.some.DerivedClass',

         method: function() {
             console.log('Fixed');

             // ... logic but with bug fixed ...

             this.callSuper();
         }
     });

The patch method cannot use {@link #method!callParent #method-callParent} to call the superclass
`method` since that would call the overridden method containing the bug. In
other words, the above patch would only produce "Fixed" then "Good" in the
console log, whereas, using `callParent` would produce "Fixed" then "Bad"
then "Good".
">callSuper</option>
    <option value="Cancel all pending `bufferableMethod` calls on this object.
">cancelAllCalls</option>
    <option value="Cancel a specific pending `bufferableMethod` call on this object.
">cancelBufferedCall</option>
    <option value="Center this {@link #cfg!floated #cfg-floated} or {@link #isPositioned positioned} Component in its parent.
">center</option>
    <option value="This method changes the record bound to the specified item.
">changeItem</option>
    <option value="Retrieves the first direct child of this container which matches the passed selector
or component. The passed in selector must comply with an Ext.ComponentQuery selector,
or it can be an actual Ext.Component.
">child</option>
    <option value="Clears all listeners that were attached using the "delegate" event option.
Users should not invoke this method directly.  It is called automatically as
part of normal {@link Ext.util.Observable#method!clearListeners clearListeners}
processing.
">clearDelegatedListeners</option>
    <option value="Removes all listeners for this object including the managed listeners
">clearListeners</option>
    <option value="Removes all managed listeners for this object.
">clearManagedListeners</option>
    <option value="Collapse all nodes
">collapseAll</option>
    <option value="Collapses a record that is loaded in the tree.
">collapseNode</option>
    <option value="Creates new Component.
">constructor</option>
    <option value="Converts the provided type or config object into a plugin instance.
">createPlugin</option>
    <option value="Creates an event handling function which re-fires the event from this object
as the passed event name.
">createRelayer</option>
    <option value="Destroys the Widget. This method should not be overridden in custom Widgets,
because it sets the flags and does final cleanup that must go last. Instead,
override {@link #method!doDestroy #doDestroy} method to add functionality at destruction time.
">destroy</option>
    <option value="Destroys member properties by name.

If a property name is the name of a *config*, the getter is *not* invoked, so
if the config has not been initialized, nothing will be done.

The property will be destroyed, and the corrected name (if the property is a *config*
and config names are prefixed) will set to `null` in this object's dictionary.
">destroyMembers</option>
    <option value="Removes and destroys a plugin.

**Note:** Not all plugins are designed to be removable. Consult the documentation
for the specific plugin in question to be sure.
">destroyPlugin</option>
    <option value="Disables this Component
">disable</option>
    <option value="undefined">doAdd</option>
    <option value="undefined">doAddListener</option>
    <option value="Perform the actual destruction sequence. This is the method to override in your
subclasses to add steps specific to the destruction of custom Component.

If the Component is currently added to a Container it will first be removed
from that Container. All {@link Ext.dom.Element Ext.Element} references are also deleted and
the Component is de-registered from {@link Ext.ComponentManager}.

As a rule of thumb, subclasses should destroy their child Components, Elements,
and/or other objects before calling parent method. Any object references will be
nulled after this method has finished, to prevent the possibility of memory leaks.
">doDestroy</option>
    <option value="Fires a delegated event.  Users should not invoke this method directly.  It
is called automatically by the framework as needed (see the "delegate" event
option of {@link Ext.util.Observable#method!addListener addListener} for more
details.
">doFireDelegatedEvent</option>
    <option value="Continue to fire event.
">doFireEvent</option>
    <option value="undefined">doInheritUi</option>
    <option value="undefined">doInsert</option>
    <option value="undefined">doUninheritUi</option>
    <option value="Retrieves the first descendant of this container which matches the passed selector.
The passed in selector must comply with an Ext.ComponentQuery selector, or it can be
an actual Ext.Component.
">down</option>
    <option value="Enables this Component
">enable</option>
    <option value="Enables events fired by this Observable to bubble up an owner hierarchy by calling
`this.getBubbleTarget()` if present. There is no implementation in the Observable
base class.

This is commonly used by Ext.Components to bubble events to owner Containers.
See {@link Ext.Component#getBubbleTarget}. The default implementation in Ext.Component
returns the Component's immediate owner. But if a known target is required, this can be
overridden to access the required target more quickly.

Example:

    Ext.define('Ext.overrides.form.field.Base', {
        override: 'Ext.form.field.Base',

        //  Add functionality to Field's initComponent to enable
        // the change event to bubble
        initComponent: function () {
            this.callParent();
            this.enableBubble('change');
        }
    });

    var myForm = Ext.create('Ext.form.Panel', {
        title: 'User Details',
        items: [{
            ...
        }],
        listeners: {
            change: function() {
                // Title goes red if form has been modified.
                myForm.header.setStyle('color', 'red');
            }
        }
    });
">enableBubble</option>
    <option value="Scrolls the specified record into view.
">ensureVisible</option>
    <option value="This method builds up a plan object with flags and a pop-off "steps" array of
method names to be called in order to fullfil the passed options of an
ensureVisible call.
">ensureVisiblePlan</option>
    <option value="Expand all nodes
">expandAll</option>
    <option value="Expands a record that is loaded in the tree.
">expandNode</option>
    <option value="Called when an item is added to this container either during initialization of the
{@link #cfg!items #cfg-items} config, or when new items are {@link #method!add added), or
{@link #method-insert inserted}.

If the passed object is *not* an instanced component, it converts the passed object into an
instanced child component.

It applies {@link #cfg!defaults #cfg-defaults} applied for contained child items - that is items
which are not positiond using {@link Ext.Component#cfg!left left},
{@link Ext.Component#cfg!top top}, {@link Ext.Component#cfg!bottom bottom},
{@link Ext.Component#cfg!right right}, {@link Ext.Component#cfg!centered centered} or
{@link Ext.Component#cfg!docked docked}.

Derived classes can override this method to process context appropriate short-hands
such as {@link Ext.Toolbar} and "->" to insert a spacer.
">factoryItem</option>
    <option value="Finds the configured default focus item. See {@link #cfg!defaultFocus}.
">findDefaultFocus</option>
    <option value="The method finds this floated component's floatParent. That means a DOM positioning
container which acts as a root element for sibling floated components, and allows allows
floated components to be absolutely positioned, and their encapsulating elements to be
reordered to produce a visual stacking effect.

This component's element is appended to its floatParent.

There is a global floatParent element, created on demand when the first top level
floated component is shown. This may be an item child of a container configured with
`{@link #cfg!floated #cfg-floated}: true`, or a free `{@link #cfg!floated floated}` component which is programatically
{@link Ext.Component#show shown}.

Child items of components inside a floated component may also be configured `{@link #cfg!floated floated}`.
These are give a floatParent which is created on demand wrapping the nearest `{@link #cfg!floated floated}`
ancestor. This means that when that ancestor's element is brought to the top of the
stack (by moving its element to the end of its own floatParent), the descendant elements
will automatically remain above.
">findFloatParent</option>
    <option value="Finds an alternate Component to focus if this Component is disabled while focused, or
focused while disabled, or otherwise unable to focus.

In both cases, focus must not be lost to document.body, but must move to an intuitively
connectible Component, either a sibling, or uncle or nephew.

This is both for the convenience of keyboard users, and also for when focus is tracked
within a Component tree such as for ComboBoxes and their dropdowns.

For example, a ComboBox with a PagingToolbar in is BoundList. If the "Next Page"
button is hit, the LoadMask shows and focuses, the next page is the last page, so
the "Next Page" button is disabled. When the LoadMask hides, it attempt to focus the
last focused Component which is the disabled "Next Page" button. In this situation,
focus should move to a sibling within the PagingToolbar.
">findFocusTarget</option>
    <option value="Retrieves plugin by its `type` alias. For example:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

     list.findPlugin('pullrefresh').setPullRefreshText('Pull to refresh...');

**Note:** See also {@link #method!getPlugin #getPlugin}.
">findPlugin</option>
    <option value="Fires the specified event with the passed parameters and executes a function (action).
By default, the action function will be executed after any "before" event handlers
(as specified using the `order` option of
`{@link Ext.util.Observable#method!addListener addListener}`), but before any other
handlers are fired.  This gives the "before" handlers an opportunity to
cancel the event by returning `false`, and prevent the action function from
being called.

The action can also be configured to run after normal handlers, but before any "after"
handlers (as specified using the `order` event option) by passing `'after'`
as the `order` parameter.  This configuration gives any event handlers except
for "after" handlers the opportunity to cancel the event and prevent the action
function from being called.
">fireAction</option>
    <option value="Fires the specified event with the passed parameters (minus the event name, plus
the `options` object passed to {@link Ext.util.Observable#method!addListener addListener}).

An event may be set to bubble up an Observable parent hierarchy (See
{@link Ext.Component#getBubbleTarget}) by calling {@link #method!enableBubble #enableBubble}.
">fireEvent</option>
    <option value="Fires the specified event with the passed parameter list.

An event may be set to bubble up an Observable parent hierarchy
(See {@link Ext.Component#getBubbleTarget}) by calling {@link #method!enableBubble #enableBubble}.
">fireEventArgs</option>
    <option value="Fires the specified event with the passed parameters and executes a function (action).
Evented Actions will automatically dispatch a 'before' event passing. This event will
be given a special controller that allows for pausing/resuming of the event flow.

By pausing the controller the updater and events will not run until resumed. Pausing,
however, will not stop the processing of any other before events.
">fireEventedAction</option>
    <option value="Flushes a specific pending `bufferableMethod` call on this object if one is
pending.
">flushBufferedCall</option>
    <option value="Try to focus this component.

If this component is disabled or otherwise not focusable, a close relation
will be targeted for focus instead to keep focus localized for keyboard users.
">focus</option>
    <option value="We MUST use our own cells as delegates for grid-based events.
Cell events will not work without this. The event system would not
carry cell information if we don't delegate onto our cells.
">generateSelectorFunctions</option>
    <option value="Prepares information on aligning this to component using alignment.
Also checks to see if this is already aligned to component according to alignment.
">getAlignmentInfo</option>
    <option value="undefined">getAlignRegion</option>
    <option value="Find component(s) that label or describe this component,
and return the id(s) of their ariaEl elements.
">getAriaLabelEl</option>
    <option value="Returns the Component for a given index in the Container's {@link #property-items}.
">getAt</option>
    <option value="Gets the bubbling parent for an Observable
">getBubbleParent</option>
    <option value="Retrieve an array of checked records.
">getChecked</option>
    <option value="get checked nodes
">getCheckedChildItems</option>
    <option value="undefined">getClassCls</option>
    <option value="Get columns using a selector to filter which columns
to return.
">getColumns</option>
    <option value="Examines this container's `{@link #property-items}` property
and gets a direct child component of this container.
">getComponent</option>
    <option value="Returns a specified config property value. If the name parameter is not passed,
all current configuration options will be returned as key value pairs.
">getConfig</option>
    <option value="Returns the {@link Ext.app.ViewController} instance associated with this
component via the {@link #cfg!controller #controller} config or {@link #setController} method.
">getController</option>
    <option value="Current Alignment information from the last alignTo call
">getCurrentAlignmentInfo</option>
    <option value="undefined">getCurrentConfig</option>
    <option value="Finds a docked item of this container using a reference, `id `or an `index` of its location
in {@link #method!getDockedItems #getDockedItems}.
">getDockedComponent</option>
    <option value="Returns all the {@link Ext.Component#cfg!docked Ext.Component#docked} items in this container.
">getDockedItems</option>
    <option value="A template method for modifying the {@link #property!element #element} config before it is processed.
By default adds the result of `this.getTemplate()` as the `children` array of
{@link #property!element #element} if `children` were not specified in the original
{@link #property!element #element} config.  Typically this method should not need to be implemented
in subclasses.  Instead the {@link #property!element #element} property should be use to configure
the element template for a given Widget subclass.

This method is called once when the first instance of each Widget subclass is
created.  The element config object that is returned is cached and used as the template
for all successive instances.  The scope object for this method is the class prototype,
not the instance.
">getElementConfig</option>
    <option value="This method is in place on the instance during construction to ensure that any
{@link #method!lookup #lookup} or {@link #method!getReferences #getReferences} calls have the {@link #cfg!items #items} initialized
prior to the lookup.
">getFirstReferences</option>
    <option value="*For {@link #cfg!floated #cfg-floated} components only. *

Finds the owning {@link #cfg!floated #cfg-floated} component (if any) responsible for
the base z-index stack position of this compoonent, and, if that component
is {@link #cfg!relative #cfg-relative}, for the coordinate system in which this component
is positioned.

If this is a top level floated component, this method will return `null`
">getFloatParent</option>
    <option value="This method returns, or creates on demand the floatWrap element which wraps the passed
floated component. It enables that floated component to act as a host for descendant
floated components.
">getFloatWrap</option>
    <option value="Returns the element used to apply focus styling CSS class when Focusable's
{@link #property!focusEl #focusEl} becomes focused. By default it is {@link #property!focusEl #focusEl}.
">getFocusClsEl</option>
    <option value="Returns the focus holder element associated with this Container.
By default, this is the Container's {@link #property!focusEl #focusEl} element;
however if {@link #cfg!defaultFocus} is defined, the child component
referenced by that property will be found and returned instead.
">getFocusEl</option>
    <option value="Retrieves the `id`. This method Will auto-generate an id if one has not already
been configured.
">getId</option>
    <option value="This method returns an object containing the inherited properties for this instance.
">getInherited</option>
    <option value="This method returns the value of a config property that may be inherited from some
ancestor.

In some cases, a config may be explicitly set on a component with the intent of
*only* being presented to its children while that component should act upon the
inherited value (see `referenceHolder` for example). In these cases the `skipThis`
parameter should be specified as `true`.
">getInheritedConfig</option>
    <option value="Returns the initial configuration passed to the constructor when
instantiating this class.

Given this example Ext.button.Button definition and instance:

    Ext.define('MyApp.view.Button', {
        extend: 'Ext.button.Button',
        xtype: 'mybutton',

        scale: 'large',
        enableToggle: true
    });

    var btn = Ext.create({
        xtype: 'mybutton',
        renderTo: Ext.getBody(),
        text: 'Test Button'
    });

Calling `btn.getInitialConfig()` would return an object including the config
options passed to the `{@link #static-method!create create}` method:

    xtype: 'mybutton',
    renderTo: // The document body itself
    text: 'Test Button'

Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
">getInitialConfig</option>
    <option value="Returns all inner {@link #property-items} of this container. `inner` means that the item is
not `{@link #cfg!docked docked}` or `{@link #property!positioned positioned}`.
">getInnerItems</option>
    <option value="Returns an item at the specified view `index`. This may return items that do not
correspond to a {@link Ext.data.Model} in the store if such items have been
added to this container.

Negative numbers are treated as relative to the end such that `-1` is the last
item, `-2` is the next-to-last and so on.

The `{@link #method!mapToItem mapToItem}` method recommended over this method as it is more flexible and can
also handle a {@link Ext.data.Model} as the parameter. To handle store
index values, use `{@link #method!mapToViewIndex mapToViewIndex}`:

     item = view.mapToItem(view.mapToViewIndex(storeIndex));
">getItemAt</option>
    <option value="Returns the item (an element or widget) at the given page coordinates.
">getItemFromPagePoint</option>
    <option value="Returns the item (an element or widget) at the given client coordinates.
">getItemFromPoint</option>
    <option value="Returns the item's index in the store, or -1 if the item does not correspond to a
{@link Ext.data.Model}.

**Deprecated** Historically this method has always returned the record's index in
the `{@link #cfg!store store}`. In most uses this was assumed to match the view index. But this is
not always the case, especially for the `{@link Ext.List}` subclass. To be clear about
which index is being requested, new code should instead call `{@link #method!mapToViewIndex mapToViewIndex}` or
`{@link #method!mapToRecordIndex mapToRecordIndex}`.
">getItemIndex</option>
    <option value="In IE11 vertically flexed elements (such as container body-el or panel body-wrap-el)
are not flexed properly when the container has a max-height, but no height.
We can workaround the issue by wrapping the vertical box in a horizontal box.
See EXTJS-24498
">getMaxHeightElement</option>
    <option value="Returns the topmost modal floated component (other then this one).
">getModalSibling</option>
    <option value="Returns an object holding the descendants of this container keyed by their
`name`. This object should not be held past the scope of the function calling this
method. It will not be valid if items are added or removed from this or any
sub-container.

The intended usage is shown here (assume there are 3 components with names of
"foo", "bar" and "baz" at some level below this container):

     onClick: function () {
         var items = this.getNamedItems();

         // using "items" we can access any descendant by its "name"

         items.foo.getValue() + items.bar.getValue() + items.baz.getValue();
     }

If `this` component has a `name` assigned to it, it is **not** included in this
object. That name is understood to belong to the ancestor container configured
as the `{@link #cfg!nameHolder nameHolder}`.
">getNamedItems</option>
    <option value="Retrieves a plugin by its `id`.

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: [{
             type: 'pullrefresh',
             id: 'foo'
         }]
     });

     list.getPlugin('foo').setPullRefreshText('Pull to refresh...');

**Note:** See also {@link #method!findPlugin #findPlugin}.
">getPlugin</option>
    <option value="Similar to `{@link #method!getRenderTarget getRenderTarget}` but for `{@link #property!positioned positioned}` items.
">getPositionedItemTarget</option>
    <option value="This method returns an object of all proxied config values for a given target. This
is only useful during the class initialization phase to avoid passing in "wrong"
initial config values for a child object and then proxying down all the configs
from the parent.

This method is not typically called directly but rather `{@link #method!mergeProxiedConfigs mergeProxiedConfigs}` is
more likely.
">getProxiedConfigs</option>
    <option value="Returns an object holding the descendants of this view keyed by their
`{@link Ext.Component#cfg!reference reference}`. This object should not be held
past the scope of the function calling this method. It will not be valid if items
are added or removed from this or any sub-container.

The intended usage is shown here (assume there are 3 components with reference
values of "foo", "bar" and "baz" at some level below this container):

     onClick: function () {
         var refs = this.getReferences();

         // using "refs" we can access any descendant by its "reference"

         refs.foo.getValue() + refs.bar.getValue() + refs.baz.getValue();
     }

If `this` component has a `{@link Ext.Component#cfg!reference reference}` assigned
to it, that is **not** included in this object. That reference is understood to
belong to the ancestor container configured as the `{@link #cfg!referenceHolder referenceHolder}`.
">getReferences</option>
    <option value="Used by ComponentQuery to retrieve all of the items
which can potentially be considered a child of this Container.
This should be overridden by components which have child items
that are not contained in items. For example `dockedItems`, `menu`, etc
">getRefItems</option>
    <option value="Used by {@link Ext.ComponentQuery}, and the {@link Ext.Component#method!up up}
method to find the owning Component in the linkage hierarchy.

By default this returns the Container which contains this Component.

This may be overridden by Component authors who implement ownership hierarchies
which are not based upon ownerCt, such as BoundLists being owned by Fields or Menus
being owned by Buttons.
">getRefOwner</option>
    <option value="Returns the element into which the html content and items should be rendered.
This defaults to the `bodyElement` but derived classes can override this method
to use a different element.

For containers his only applies to `inner` items, not `{@link #cfg!docked docked}` items. The
`{@link #property!positioned positioned}` items are rendered to the element returned by the
{@link Ext.Container#getPositionedItemTarget method.
">getRenderTarget</option>
    <option value="Returns the root node for this tree.
">getRootNode</option>
    <option value="This method is required by the Scroller to return the scrollable client region
">getScrollableClientRegion</option>
    <option value="Returns all the items that are docked at the ends of the items.
">getScrollDockedItems</option>
    <option value="Returns the grid's selection if {@link Ext.grid.selection.Model#cfg!mode} is single
">getSelection</option>
    <option value="Returns the height and width of the Component.
">getSize</option>
    <option value="Creates a state builder to access or edit this instance's state object. If this
instance has a `{@link #method!getStatefulOwner}`, the returned
builder will have a `parent` reference that owner's state builder. This can be
an arbitrarily deep chain but does proceed all the way up to the root instance
(with no owner) since that is the instance that determines the ultimate state
storage key.
">getStateBuilder</option>
    <option value="This method allows a class to specify an owning stateful object. This is used by
{@link Ext.plugin.Abstract} to save their state as part of their owning
{@link Ext.Component}.

The return value can be either a `Stateful` object or an array whose first element is
a `Stateful` object. This object's state will be stored inside the state object of
the returned `Stateful` object. If an array is returned, the elements beyond the first
are sub-keys in the state object.

For example, {@link Ext.plugin.Abstract} implement this method like so:

     getStatefulOwner: function() {
         return [ this.cmp, 'plugins' ];
     }

The effect of this is to produce a state object like so:

     {
         plugins: {
             pluginId1: {
                 //...
             }
         }
     }

In order for a child object's state to be saved and restored, all of its parents must
also be stateful (i.e., have a `{@link #cfg!stateId stateId}`).
">getStatefulOwner</option>
    <option value="Return the actual tabIndex for this Focusable.
">getTabIndex</option>
    <option value="Returns an array of the current items in the DataView. Depends on the
{@link #cfg-useComponents} configuration.
">getViewItems</option>
    <option value="Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the {@link Ext.Component} header.

__Note:__ If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.

Example usage:

    var t = new Ext.field.Text();
    alert(t.getXTypes());  // alerts 'component/field/textfield'
">getXTypes</option>
    <option value="Returns the `ListGroup` instance for the given `key`.
">groupFrom</option>
    <option value="undefined">handleBlurEvent</option>
    <option value="undefined">handleFocusEvent</option>
    <option value="undefined">has</option>
    <option value="Checks if the specified CSS class exists on this element's DOM node.
">hasCls</option>
    <option value="undefined">hasConfig</option>
    <option value="undefined">hasInnerItem</option>
    <option value="Checks to see if this object has any listeners for a specified event, or whether
the event bubbles. The answer indicates whether the event needs firing or not.
">hasListener</option>
    <option value="Hides this Component optionally using an animation.
">hide</option>
    <option value="This method is called to convert the modified field names array received from
the `{@link #cfg!store store}` when records are modified. Grids want to convert that array into an
object keyed by modified name for efficient decisions about which cells need to
be refreshed.
">indexModifiedFields</option>
    <option value="undefined">indexOf</option>
    <option value="This method triggers the lazy configs and must be called when it is time to
fully boot up. The configs that must be initialized are: `{@link #cfg!bind bind}`, `{@link #cfg!publishes publishes}`,
`{@link #cfg!session session}`, `{@link #cfg!twoWayBindable twoWayBindable}` and `{@link #cfg!viewModel viewModel}`.
">initBindable</option>
    <option value="This method initializes an instance when the first bufferable method is called.
It merges an instance-level `bufferableMethods` config if present. This allows
an instance to change the buffer timeouts, even to 0 to disable buffering.

     Ext.create({
         ...
         bufferableMethods: {
             foobar: 0
         }
     });

Note, this method cannot effect unbuffered methods. The `bufferableMethods`
config only instruments buffered methods when used on a class declaration.
">initBufferables</option>
    <option value="Initialize configuration for this class. a typical example:

    Ext.define('My.awesome.Class', {
        // The default config
        config: {
            name: 'Awesome',
            isAwesome: true
        },

        constructor: function(config) {
            this.initConfig(config);
        }
    });

    var awesome = new My.awesome.Class({
        name: 'Super Awesome'
    });

    alert(awesome.getName()); // 'Super Awesome'
">initConfig</option>
    <option value="This method is called when a drag is initializing. This method should adjust the
drag constraints to ensure all drag movements are properly restricted. See
{@link Ext.drag.Source#cfg!constrain Ext.drag.Source#constrain}.
">initDragConstraints</option>
    <option value="Initializes the Element for this Widget instance.  If this is the first time a
Widget of this type has been instantiated the {@link #property!element #element} config will be
processed to create an Element.  This Element is then cached on the prototype (see
afterCachedConfig) so that future instances can obtain their element by simply
cloning the Element that was cached by the first instance.
">initElement</option>
    <option value="Called for the first instance of this Widget to create an object that contains the
listener configs for all of the element references keyed by reference name. The
object is cached on the prototype and has the following shape:

    _elementListeners: {
        element: {
            click: 'onClick',
            scope: this
        },
        fooReference: {
            tap: {
                fn: someFunction,
                delay: 100
            }
        }
    }

The returned object is prototype chained to the _elementListeners object of its
superclass, and each key in the object is prototype chained to object with the
corresponding key in the superclass _elementListeners.  This allows element
listeners to be inherited and overridden when subclassing widgets.

This method is invoked with the prototype object as the scope
">initElementListeners</option>
    <option value="Sets up the focus listener on this Component's {@link #method!getFocusEl focusEl} if it has one.

Form Components which must implicitly participate in tabbing order usually have
a naturally focusable element as their {@link #method!getFocusEl focusEl}, and it is
the DOM event of that receiving focus which drives the Component's `{@link #method!onFocus onFocus}` handling,
and the DOM event of it being blurred which drives the `{@link #method!onBlur onBlur}` handling.
">initFocusableElement</option>
    <option value="Template method to do any event listener initialization for a Focusable.
This generally happens after the focusEl is available.
">initFocusableEvents</option>
    <option value="Allows addition of behavior to the rendering phase.
">initialize</option>
    <option value="Called by `{@link #method!getInherited getInherited}` to initialize the inheritedState the first time it is requested.
">initInheritedState</option>
    <option value="This method should be called when the instance is ready to start listening for
keyboard events. This is called automatically for `{@link Ext.Component}` and derived
classes. This is done after the component is rendered.
">initKeyMap</option>
    <option value="Initializes a "uiReference".  Ui rerefences are reference elements that have
classCls and ui info in their CSS class names.  They can be used by setting
uiCls in the template, or by invoking this method to setup the ui reference
after element/template initialization (Toolable uses this for its dock wrapper)
">initUiReference</option>
    <option value="Adds a child Component at the given index. For example, here's how we can add a new item,
making it the first child Component of this Container:

    myContainer.insert(0, {xtype: 'panel', html: 'new item'});
">insert</option>
    <option value="undefined">insertAfter</option>
    <option value="undefined">insertBefore</option>
    <option value="undefined">insertFirst</option>
    <option value="This method inserts this floated component's DOM into its owning floatParent.
">insertFloatedDom</option>
    <option value="undefined">insertInner</option>
    <option value="undefined">insertLast</option>
    <option value="This method marks the current inherited state as invalid. The next time a call is
made to `{@link #method!getInherited getInherited}` the objects will be recreated and initialized.
">invalidateInheritedState</option>
    <option value="Tests whether this Widget matches a {@link Ext.ComponentQuery}
selector string.
">is</option>
    <option value="Determines whether **this Component** is an ancestor of the passed Component.
This will return `true` if the passed Component is anywhere within the subtree
beneath this Component.
">isAncestor</option>
    <option value="undefined">isBlurring</option>
    <option value="Determines if the passed property name is bound to ViewModel data.
">isBound</option>
    <option value="Returns `true` if a specific `bufferableMethod` is pending.
">isCallPending</option>
    <option value="undefined">isCentered</option>
    <option value="Determines whether this component is the descendant of a passed component.
">isDescendantOf</option>
    <option value="Determines if this Component is inside a Component tree which is destroyed, *or
is being destroyed*.
">isDestructing</option>
    <option value="Returns `true` if this Component is currently disabled.
">isDisabled</option>
    <option value="Returns `true` if this Component is not currently disabled.
">isEnabled</option>
    <option value="Determine if this Focusable can receive focus at this time.

Note that Containers can be non-focusable themselves while delegating
focus treatment to a child Component; see {@link Ext.Container}
for more information.
">isFocusable</option>
    <option value="undefined">isFocusing</option>
    <option value="undefined">isHeighted</option>
    <option value="Returns `true` if this Component is currently hidden.
">isHidden</option>
    <option value="undefined">isPainted</option>
    <option value="For infinite lists, not all records are represented in the DOM.

This method will return `true` if the passed record index or
{@link Ext.data.Model} is represented in the DOM.
">isRecordRendered</option>
    <option value="undefined">isRendered</option>
    <option value="Checks if all events, or a specific event, is suspended.
">isSuspended</option>
    <option value="Checks if a particular binding is synchronizing the value.
">isSyncing</option>
    <option value="Returns `true` if this Component is currently visible.

A Widget is visible if its element is not hidden, *and* has been
{@link #property!rendered} *and* has not been destroyed.
">isVisible</option>
    <option value="undefined">isWidthed</option>
    <option value="Tests whether or not this Component is of a specific xtype. This can test whether this
Component is descended from the xtype (default) or whether it is directly of the xtype
specified (`shallow = true`).
**If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.__

For a list of all available xtypes, see the {@link Ext.Component} header.

Example usage:

    var t = new Ext.field.Text();
    var isText = t.isXType('textfield'); // true
    var isBoxSubclass = t.isXType('field'); // true, descended from Ext.field.Field
    var isBoxInstance = t.isXType('field', true); // false, not a direct
                                                  // Ext.field.Field instance
">isXType</option>
    <option value="undefined">itemAs</option>
    <option value="Adds a "destroyable" object to an internal list of objects that will be destroyed
when this instance is destroyed (via `{@link #method!destroy}`).
">link</option>
    <option value="This method is called to load state from the provided `state` builder. This method
should return the config properties loaded from `state`.

This method, like `{@link #method!saveState saveState}`, can be overridden by derived classes:

     loadState: function(state) {
         var ret = this.callParent([ state ]);

         if (ret.foo) {
             // use custom data...

             delete ret.foo;  // remove it since it isn't a config
         }

         return ret;
     }

When overriding this method, it is also likely necessary to override `{@link #method!saveState saveState}`.
">loadState</option>
    <option value="Gets a reference to the component with the specified
{@link Ext.Component#cfg!reference reference} value.

The method is a short-hand for the {@link #method!lookupReference #lookupReference} method.
">lookup</option>
    <option value="Gets the controller that controls this view. May be a controller that belongs
to a view higher in the hierarchy.
">lookupController</option>
    <option value="Gets a reference to the component with the specified `name` property.
">lookupName</option>
    <option value="Gets the Form or Component that is used as the name holder for this component.
">lookupNameHolder</option>
    <option value="Gets a reference to the component with the specified {@link #cfg!reference #reference} value.

The {@link #method!lookup #lookup} method is a short-hand version of this method.
">lookupReference</option>
    <option value="Gets the Controller or Component that is used as the reference holder for this view.
">lookupReferenceHolder</option>
    <option value="Returns the `{@link Ext.data.Session}` for this instance. This property may come
from this instance's `{@link #cfg!session #session}` or be inherited from this object's parent.
">lookupSession</option>
    <option value="Gets a named template instance for this class. See {@link Ext.XTemplate#static-method!getTpl Ext.XTemplate#getTpl}.
">lookupTpl</option>
    <option value="Returns the `{@link Ext.app.ViewModel}` for this instance. This property may come from this
this instance's `{@link #cfg!viewModel #viewModel}` or be inherited from this object's parent.
">lookupViewModel</option>
    <option value="Converts the given parameter to a cell.
">mapToCell</option>
    <option value="Converts the given `indexOrRecord` to an "item".

An "item" can be either an `{@link Ext.dom.Element}` or an `{@link Ext.Component}` depending on the
type of dataview. For convenience the `as` parameter can be used to convert the
returned item to a common type such as `{@link Ext.dom.Element}` or `HTMLElement`.

Be aware that the `{@link Ext.List}` subclass can optionally render only some records, in
which case not all records will have an associated item in the view and this method
will return `null`.

An index value is a view index. These will only match the record's index in the
`{@link #cfg!store store}` when no extra items are added to this dataview (so called "non-record"
items). These are often unaligned in `{@link Ext.List}` due to group headers as well as
`infinite` mode where not all records are rendered into the view at one time.

Negative index values are treated as relative to the end such that `-1` is the last
item, `-2` is the next-to-last and so on.

For example:

     // Add "foo" class to the last item in the view
     view.mapToItem(-1, 'el').addCls('foo');

     // Add "foo" class to the last data item in the view
     view.mapToItem(view.getStore().last(), 'el').addCls('foo');

To handle a record's index in the `{@link #cfg!store store}`:

     item = view.mapToItem(view.mapToViewIndex(storeIndex));
">mapToItem</option>
    <option value="Converts the given parameter to a {@link Ext.data.Model}. Not all items
in a dataview correspond to records (such as group headers in `{@link Ext.List}`). In these
cases `null` is returned.

If `item` is a {@link Ext.data.Model}, it will be returned if it belongs to
this dataview's `{@link #cfg!store store}`. Otherwise, `null` will be returned.

An "item" can be simply an element or a component depending on the type of dataview.

An index value is a view index. These will only match the record's index in the
`{@link #cfg!store store}` when no extra items are added to this dataview (so called "non-record"
items). These are often unaligned in `{@link Ext.List}` due to group headers as well as
`infinite` mode where not all records are rendered into the view at one time.

Negative index values are treated as relative to the end such that `-1` is the last
item, `-2` is the next-to-last and so on.
">mapToRecord</option>
    <option value="Converts the given parameter to the record's index in the `{@link #cfg!store store}`. Not all items
in a dataview correspond to records (such as group headers in `{@link Ext.List}`). In these
cases `-1` is returned.

An "item" can be simply an element or a component depending on the type of dataview.

An input index value is a view index. These will only match the record's index in
the `{@link #cfg!store store}` when no extra items are added to this dataview (so called "non-record"
items). These are often unaligned in `{@link Ext.List}` due to group headers as well as
`infinite` mode where not all records are rendered into the view at one time.

Negative index values are treated as relative to the end such that `-1` is the last
item, `-2` is the next-to-last and so on.
">mapToRecordIndex</option>
    <option value="Converts the given parameter to a row body.
">mapToRowBody</option>
    <option value="Converts the given parameter to the equivalent record index in the `{@link #cfg!store store}`.

In this method alone, the index parameter is a *store index* not a *view index*.

Be aware that the `{@link Ext.List}` subclass can optionally render only some records, in
which case not all records will have an associated item in the view and this method
will return `-1`.

Negative index values are treated as relative to the end such that `-1` is the last
record, `-2` is the next-to-last and so on.

An "item" can be simply an element or a component depending on the type of dataview.

The view index will only match the record's index in the `{@link #cfg!store store}` when no extra
items are added to this dataview (so called "non-record" items). These are often
unaligned in `{@link Ext.List}` due to group headers as well as `infinite` mode where not
all records are rendered into the view at one time.
">mapToViewIndex</option>
    <option value="Convenience method which calls {@link #setMasked} with a value of `true` (to show the mask).
For additional functionality, call the {@link #setMasked} function direction (See the
{@link #cfg!masked #masked} configuration documentation for more information).
">mask</option>
    <option value="This method accepts the normal config object (`itemConfig`) for the child object
(`name`) and merges any proxied configs into a new config object. This is useful
during the class initialization phase to avoid passing in "wrong" initial config
values for a child object and then proxying down the rest of the configs.

This method is typically called during an "applier" method for a proxy target. If
called at any other time this method simply returns the given `itemConfig`. This
makes it safe to code such appliers as follows:

     applyChildThing: function(config) {
         config = this.mergeProxiedConfigs('childThing', config);

         return new ChildThing(config);
     }
">mergeProxiedConfigs</option>
    <option value="Shorthand for {@link #method!addManagedListener #addManagedListener}.
The addManagedListener method is used when some object (call it "A") is listening
to an event on another observable object ("B") and you want to remove that listener
from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
all of its listeners will be removed at that time.

Example:

    Ext.define('Foo', {
        extend: 'Ext.Component',

        initComponent: function () {
            this.addManagedListener(MyApp.SomeSharedMenu, 'show', this.doSomething);
            this.callParent();
        }
    });

As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.

As of version 5.1 it is no longer necessary to use this method in most cases because
listeners are automatically managed if the scope object provided to
{@link Ext.util.Observable#method!addListener addListener} is an Observable instance.
However, if the observable instance and scope are not the same object you
still need to use `{@link #method!mon mon}` or `{@link #method!addManagedListener addManagedListener}` if you want the listener to be
managed.
">mon</option>
    <option value="Shorthand for {@link #method!removeManagedListener #removeManagedListener}.
Removes listeners that were added by the {@link #method!mon #mon} method.
">mun</option>
    <option value="Returns the item following the passed `item` in the view. For `infinite` lists, this
traversal can encounter unrendered records. In this case, the record index of the
unrendered record is returned.

If `as` is specified, the item is converted to the desired form, if possible. If
that conversion cannot be performed, `null` is returned.
">nextItem</option>
    <option value="The {@link #method!on #on} method is shorthand for
{@link Ext.util.Observable#method!addListener addListener}.

Appends an event handler to this object.  For example:

    myGridPanel.on("itemclick", this.onItemClick, this);

The method also allows for a single argument to be passed which is a config object
containing properties which specify multiple events. For example:

    myGridPanel.on({
        cellclick: this.onCellClick,
        select: this.onSelect,
        viewready: this.onViewReady,
        scope: this // Important. Ensure "this" is correct during handler execution
    });

One can also specify options for each event handler separately:

    myGridPanel.on({
        cellclick: {fn: this.onCellClick, scope: this, single: true},
        viewready: {fn: panel.onViewReady, scope: panel}
    });

*Names* of methods in a specified scope may also be used:

    myGridPanel.on({
        cellclick: {fn: 'onCellClick', scope: this, single: true},
        viewready: {fn: 'onViewReady', scope: panel}
    });
">on</option>
    <option value="undefined">onAdded</option>
    <option value="Appends an after-event handler.

Same as {@link Ext.util.Observable#method!addListener addListener} with `order` set
to `'after'`.
">onAfter</option>
    <option value="Appends a before-event handler.  Returning `false` from the handler will stop the event.

Same as {@link Ext.util.Observable#method!addListener addListener} with `order` set
to `'before'`.
">onBefore</option>
    <option value="undefined">onBlur</option>
    <option value="Initialize layout and event listeners the very first time an item is added
">onFirstItemAdd</option>
    <option value="undefined">onFocus</option>
    <option value="Called when focus enters this Component's hierarchy
">onFocusEnter</option>
    <option value="Called when focus exits from this Component's hierarchy
">onFocusLeave</option>
    <option value="Called when focus moves *within* this Component's hierarchy
">onFocusMove</option>
    <option value="Called when this Inheritable is added to a parent
">onInheritedAdd</option>
    <option value="Called when this inheritable is removed from a parent
">onInheritedRemove</option>
    <option value="undefined">onInitialized</option>
    <option value="undefined">onItemAdd</option>
    <option value="undefined">onItemMove</option>
    <option value="undefined">onItemRemove</option>
    <option value="This method is called by the {@link #cfg!navigationModel} when navigation events are
detected within this DataView.

It may be overridden to control the linkage of navigation events such as
taps, clicks or keystrokes detected by the {@link #cfg!navigationModel} to
the {@link #cfg!selectionModel}.

`callParent` if you wish selection to proceed from the passed event.
">onNavigate</option>
    <option value="Called by {@link Ext.GlobalEvents#setPressedComponent} when the global
mouseup event fires and there's a registered pressed component.
">onRelease</option>
    <option value="This method is called the first time a component is inserted into the DOM. If this
component {@link Ext.Container} other components, the `{@link #method!onRender onRender}` method
for child components is called *after* the parent's `{@link #method!onRender onRender}`.

Implementations of this method should avoid modifying the DOM but are free to read
from and measure elements as needed. To adjust the DOM, consider implementing
{@link #method!afterRender afterRender} instead.

If this method is overridden, be sure to use `callParent` to call the base class
version.

     onRender: function() {
         this.callParent();

         // custom actions
     }

This method is not generally needed because components always have their own DOM
{@link #property!element} and these are maintained by config property
updaters prior to insertion in the DOM. In general, it is always best to interrogate
the component's elements outside the DOM where there is no associated reflow or
layout cost. This method is useful for situations where the component's elements
must be in the DOM. For example to be measured correctly.
">onRender</option>
    <option value="Optional template method. If implemented, this is called *asynchronously* after a browser
layout caused by a component resize. This may be triggered for any or several of the
following reasons:
   - Programmatic changes to {@link #cfg!width #cfg-width} or {@link #cfg!height #cfg-height} configs.
   - Setting the {@link #cfg!flex #cfg-flex} config when the owning layout is {@link Ext.layout.Box}.
   - Setting {@link #cfg!minHeight #cfg-minHeight}, {@link #cfg!maxHeight #cfg-maxHeight}, {@link #cfg!minWidth #cfg-minWidth}
     or {@link #cfg!maxWidth #cfg-maxWidth}.
   - Changing device orientation.
   - Changing the browser viewport size.
   - Any resize caused by browser layout recalculation which may be caused by content
     size changes or application of default browser layout rules.
">onResize</option>
    <option value="Invoked when a scroll operation is completed via this component's
{@link #cfg!scrollable scroller}.
">onScrollEnd</option>
    <option value="Invoked when this component is scrolled via its {@link #cfg!scrollable scroller}.
">onScrollMove</option>
    <option value="Invoked when a scroll is initiated on this component via its {@link #cfg!scrollable scroller}.
">onScrollStart</option>
    <option value="This method is called when any of the `{@link #cfg!stateful stateful}` configs are modified.
">onStatefulChange</option>
    <option value="Returns `true` if the passed element is within the container tree of this component.

For example if a menu's submenu contains an {@link Ext.form.field.Date}, that top level
menu owns the elements of the date picker. Using this method, you can tell if an event
took place within a certain component tree.
">owns</option>
    <option value="Saves the state of this instance to the persistence store. This method is called
by the {@link Ext.state.Provider} when it is ready to save state
to storage.
">persistState</option>
    <option value="Function which can be overridden to provide custom formatting for each Record that is used
by this DataView's {@link #cfg!tpl template} to render each node.
">prepareData</option>
    <option value="This is the private method to ensure everything is set up for showing.
This is called by both show and showBy to set a component up.
the user-facing method is beforeShow, this setup must have
happened by the time that is called.
">preprocessShow</option>
    <option value="Returns the item preceding the passed `item` in the view. For `infinite` lists, this
traversal can encounter unrendered records. In this case, the record index of the
unrendered record is returned.

If `as` is specified, the item is converted to the desired form, if possible. If
that conversion cannot be performed, `null` is returned.
">previousItem</option>
    <option value="Recursively processes the element templates for this class and its superclasses,
ascending the hierarchy until it reaches a superclass whose element template
has already been processed.  This method is invoked using the prototype as the scope.
">processElementConfig</option>
    <option value="An overrideable function which preprocesses all key events from within this
FocusableContainer. The base implementation vetoes processing of key events from input
fields by returning `undefined`. This may be overridden in subclasses with special
requirements.
">processFocusableContainerKeyEvent</option>
    <option value="Publish this components state to the `ViewModel`. If no arguments are given (or if
this is the first call), the entire state is published. This state is determined by
the `{@link #cfg!publishes publishes}` property.

This method is called only by component authors.
">publishState</option>
    <option value="Retrieves all descendant components which match the passed selector.
Executes an Ext.ComponentQuery.query using this container as its root.
">query</option>
    <option value="Retrieves all descendant components which match the passed function.
The function should return false for components that are to be
excluded from the selection.
">queryBy</option>
    <option value="Finds a component at any level under this container matching the id/itemId.
This is a shorthand for calling ct.down('#' + id);
">queryById</option>
    <option value="Returns this instance's state object from the persistence store. This object
should contain config properties.
">readStateObject</option>
    <option value="undefined">realign</option>
    <option value="Refreshes the view by reloading the data from the store and re-rendering the template.
">refresh</option>
    <option value="This method is for use by plugins which require the grid to enter actionable mode
to focus in-cell elements.

An example of this can be found in the {@link Ext.grid.plugin.CellEditing cell editing}
plugin.

Actionable plugins have an `{@link Ext.grid.plugin.CellEditing#activateCell activateCell}`
method which will be called whenever the application wants to enter actionable mode
on a certain cell. A {@link Ext.grid.Location} object will be passed.

The `activateCell` method must return an {@link Ext.grid.Location} if it accepts
control, indicating in its {@link Ext.grid.Location#element element} setting
exactly where focus has moved to.

Actionable plugins may also expose a `{@link #cfg!triggerEvent triggerEvent}` config which is the name of an
event to be used to trigger actioning that plugin, in addition fo the ARIA standard
method of the user pressing `F2` or `ENTER` when focused on a cell.
">registerActionable</option>
    <option value="Relays selected events from the specified Observable as if the events were fired
by `this`.

For example if you are extending Grid, you might decide to forward some events from
store. So you can do this inside your initComponent:

    this.relayEvents(this.getStore(), ['load']);

The grid instance will then have an observable 'load' event which will be passed
the parameters of the store's load event and any function fired with the grid's
load event would have access to the grid using the this keyword (unless the event
is handled by a controller's control/listen event listener in which case 'this'
will be the controller rather than the grid).
">relayEvents</option>
    <option value="Removes an item from this Container, optionally destroying it.
">remove</option>
    <option value="Alias for {@link #method!unAfter #unAfter}.
">removeAfterListener</option>
    <option value="Removes all items currently in the Container, optionally destroying them all.
">removeAll</option>
    <option value="Removes the Component at the specified index:

    myContainer.removeAt(0); // removes the first item
">removeAt</option>
    <option value="Alias for {@link #method!unBefore #unBefore}.
">removeBeforeListener</option>
    <option value="Removes the given CSS class(es) from this widget's primary element.
">removeCls</option>
    <option value="Removes delegated listeners for a given eventName, function, and scope.
Users should not invoke this method directly.  It is called automatically by
the framework as part of {@link #method!removeListener #removeListener} processing.
">removeDelegatedListener</option>
    <option value="undefined">removeInner</option>
    <option value="Removes an inner Component at the specified index:

    myContainer.removeInnerAt(0); // removes the first item of the innerItems property
">removeInnerAt</option>
    <option value="Removes an event handler.
">removeListener</option>
    <option value="Removes listeners that were added by the {@link #method!mon #mon} method.
">removeManagedListener</option>
    <option value="Remove a single managed listener item
">removeManagedListenerItem</option>
    <option value="Removes and (optionally) destroys a plugin.

**Note:** Not all plugins are designed to be removable. Consult the documentation
for the specific plugin in question to be sure.
">removePlugin</option>
    <option value="Moves the given `item` to be before the `ref` item or index. For `{@link #cfg!infinite infinite}`
lists this does not impact the DOM childNodes unless `{@link #cfg!maintainChildNodes maintainChildNodes}` is
specified. In this case the reordering only impacts this container's `{@link #cfg!items items}`
and `innerItems` collections.

Maintaining the order of `{@link #property!dataItems dataItems}` is a separate concern.
">reorderItem</option>
    <option value="Replaces specified classes with the newly specified classes.
It uses the {@link #method!addCls #addCls} and {@link #method!removeCls #removeCls} methods, so if the class(es) you
are removing don't exist, it will still add the new classes.
">replaceCls</option>
    <option value="Resets {@link #cfg!top #top}, {@link #cfg!right #right}, {@link #cfg!bottom #bottom} and {@link #cfg!left #left} configurations to
`null`, which will cause this component to stop being 'positioned' and to take its place in
its owning container's layout.
">resetFloating</option>
    <option value="Resets {@link #cfg!top #top}, {@link #cfg!right #right}, {@link #cfg!bottom #bottom} and {@link #cfg!left #left} configurations to
`null`, which will cause this component to stop being 'positioned' and to take its place in
its owning container's layout.
">resetPositioned</option>
    <option value="Gets the default scope for firing late bound events (string names with
no scope attached) at runtime.
">resolveListenerScope</option>
    <option value="Returns the default listener scope for a "satellite" of this component.
Used for resolving scope for observable objects that are not part of the normal
Container/Component hierarchy (for example, plugins)
">resolveSatelliteListenerScope</option>
    <option value="Resumes firing of the named event(s).

After calling this method to resume events, the events will fire when requested to fire.

**Note that if the {@link #method!suspendEvent #suspendEvent} method is called multiple times for a certain
event, this converse method will have to be called the same number of times for it
to resume firing.**
">resumeEvent</option>
    <option value="Resumes firing events (see {@link #method!suspendEvents #suspendEvents}).

If events were suspended using the `queueSuspended` parameter, then all events fired
during event suspension will be sent to any listeners now.
">resumeEvents</option>
    <option value="Returns focus to the Component or element found in the cached
focusEnterEvent.
">revertFocus</option>
    <option value="This field is on the recieving end of a call from {@link #method!revertFocus}.

It is called when focus is being pushed back into this Component from a Component
that is focused and is being hidden or disabled.

We must focus the passed element.

Subclasses may perform some extra processing to prepare for refocusing.
">revertFocusTo</option>
    <option value="Called prior to an operation which mey remove focus from this view by some kind of
DOM operation.

If this view contains focus, this method returns a function which, when called after
the disruptive DOM operation will restore focus to the same record, or, if the
record has been removed to the same item index..
">saveFocusState</option>
    <option value="Saves the current state of this object to the provided `state` builder. By default
this method saves the configs specified as `{@link #cfg!stateful stateful}`.

This method can also be overridden by subclasses to store custom data directly to
the `state` builder:

     saveState: function(state) {
         this.callParent([ state ]);

         state.set('foo', 42);
     }

When overriding this method, it is also likely necessary to override `{@link #method!loadState loadState}`.
">saveState</option>
    <option value="Scrolls the list so that the specified record is at the top.
">scrollToRecord</option>
    <option value="Sets a single/multiple configuration options.
">setConfig</option>
    <option value="Sets the current Alignment information, called by alignTo
">setCurrentAlignmentInfo</option>
    <option value="An alias for {@link Ext.util.Observable#method!addListener addListener}.  In
versions prior to 5.1, {@link #cfg!listeners #listeners} had a generated setter which could
be called to add listeners.  In 5.1 the listeners config is not processed
using the config system and has no generated setter, so this method is
provided for backward compatibility.  The preferred way of adding listeners
is to use the {@link #method!on #on} method.
">setListeners</option>
    <option value="All Components need a potentially recursive setRendered because some are
pseudo containers, such as grid {@link Ext.grid.Row}, and some mix in
{@link Ext.mixin.Toolable}.
">setRendered</option>
    <option value="Sets root node of this tree. All trees *always* have a root node. It may be
{@link #rootVisible hidden}.

If the passed node has not already been loaded with child nodes, and has its expanded field
set, this triggers the {@link #cfg!store #cfg-store} to load the child nodes of the root.
">setRootNode</option>
    <option value="Sets the size of the Component.
">setSize</option>
    <option value="Set the tabIndex property for this Focusable. If the focusEl
is available, set tabIndex attribute on it, too.
">setTabIndex</option>
    <option value="undefined">setVisibility</option>
    <option value="This method has the same arguments as {@link Ext.dom.Element#method!setXY element's setXY}
method, but is used to maintain the `{@link #cfg!x x}` and `{@link #cfg!y y}` configs (for `{@link #cfg!floated floated}` components)
or the `{@link #cfg!left left}` and `{@link #cfg!top top}` config for positioned components.
">setXY</option>
    <option value="Shows this component optionally using an animation.
">show</option>
    <option value="Displays component at specific xy position.
A floating component (like a menu) is positioned relative to its ownerCt if any.
Useful for popping up a context menu:

    listeners: {
        itemcontextmenu: function(view, record, item, index, event, options) {
            Ext.create('Ext.menu.Menu', {
                width: 100,
                height: 100,
                margin: '0 0 10 0',
                items: [{
                    text: 'regular item 1'
                },{
                    text: 'regular item 2'
                },{
                    text: 'regular item 3'
                }]
            }).showAt(event.getXY());
        }
    }
">showAt</option>
    <option value="Shows this component by another component. If you specify no alignment, it will automatically
position this component relative to the reference component depending upon the `alignment`
parameter.

The `alignment` parameter describes the edge-to-edge alignment of *this* component
with the target. It can be specified thus:

- **Blank**: Defaults to positioning where the component will fit trying `'l-r?'`,
`'r-l?'`, `'b-t?'` then `'t-b?'` in that order.
- **Two anchors**: If two values from the table below are passed separated by a dash,
  the first value is used as the element's anchor point, and the second value is
  used as the target's anchor point.
- **Two edge/offset descriptors:** An edge/offset descriptor is an edge initial
  (`t`/`r`/`b`/`l`) followed by a percentage along that side. This describes a
  point to align with a similar point in the target. So `'t0-b0'` would be
  the same as `'tl-bl'`, `'l0-r50'` would place the top left corner of this item
  halfway down the right edge of the target item. This allows more flexibility
  and also describes which two edges are considered adjacent when positioning a tip pointer.

Following are all of the supported predefined anchor positions:

     Value  Description
     -----  -----------------------------
     tl     The top left corner
     t      The center of the top edge
     tr     The top right corner
     l      The center of the left edge
     c      The center
     r      The center of the right edge
     bl     The bottom left corner
     b      The center of the bottom edge
     br     The bottom right corner

You can put a '?' at the end of the alignment string to constrain the positioned element to
the {@link Ext.Viewport}. The element will attempt to align as specified, but the
position will be adjusted to constrain to the viewport if necessary. Note that the element
being aligned might be swapped to align to a different position than that specified in order
to enforce the viewport constraints.

Example Usage:

    // show `panel` by `button` using the default positioning (auto fit)
    panel.showBy(button);

    // align the top left corner of `panel` with the top right corner of `button`
    // (constrained to viewport)
    panel.showBy(button, "tl-tr?");

    // align the bottom right corner of `panel` with the center left edge of `button`
    // (not constrained by viewport)
    panel.showBy(button, "br-cl");

    // align the center of panel with the bottom left corner of button and
    // adjust the x position by -6 pixels (and the y position by 0)
    panel.showBy(button, "c-bl", [-6, 0]);

    // align the 25% point on the bottom edge of this panel
    // with the 75% point on the top edge of button.
    panel.showBy(button, 'b25-t75');
">showBy</option>
    <option value="Get the reference to the class from which this object was instantiated. Note that unlike
{@link Ext.Base#property!self Ext.Base#self}, `this.statics()` is scope-independent and it always returns
the class from which it was called, regardless of what `this` points to during run-time

    Ext.define('My.Cat', {
        statics: {
            totalCreated: 0,
            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        },

        constructor: function() {
            var statics = this.statics();

            // always equals to 'Cat' no matter what 'this' refers to
            // equivalent to: My.Cat.speciesName
            alert(statics.speciesName);


            alert(this.self.speciesName);   // dependent on 'this'

            statics.totalCreated++;
        },

        clone: function() {
            var cloned = new this.self();   // dependent on 'this'

            // equivalent to: My.Cat.speciesName
            cloned.groupName = this.statics().speciesName;

            return cloned;
        }
    });


    Ext.define('My.SnowLeopard', {
        extend: 'My.Cat',

        statics: {
            speciesName: 'Snow Leopard' // My.SnowLeopard.speciesName = 'Snow Leopard'
        },

        constructor: function() {
            this.callParent();
        }
    });

    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'

    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'

    var clone = snowLeopard.clone();
    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
    alert(clone.groupName);                 // alerts 'Cat'

    alert(My.Cat.totalCreated);             // alerts 3
">statics</option>
    <option value="Suspends firing of the named event(s).

After calling this method to suspend events, the events will no longer fire when
requested to fire.

**Note that if this is called multiple times for a certain event, the converse method
{@link #method!resumeEvent #resumeEvent} will have to be called the same number of times for it to resume
firing.**
">suspendEvent</option>
    <option value="Suspends the firing of all events. (see {@link #method!resumeEvents #resumeEvents})
">suspendEvents</option>
    <option value="Fixes up the alwaysOnTop order of this floated widget within its siblings.
">syncAlwaysOnTop</option>
    <option value="Synchronizes the size and position of the {@link #method!getFloatWrap floatWrap}
when this Widget is resized
">syncFloatWrap</option>
    <option value="Brings a {@link #cfg!floated #cfg-floated} Component to the front of any other visible, floated
Components while honoring all {@link #cfg!alwaysOnTop} settings. This may not become
topmost if another visible floated component has a higher {@link #cfg!alwaysOnTop} value.

If this Component becomes the topmost *modal* floated component, the the shared modal
mask is moved to just below this Component.
">toFront</option>
    <option value="Toggles the specified CSS class on this element (removes it if it already exists,
otherwise adds it).
">toggleCls</option>
    <option value="This method is called internally by `{@link #method!initConfig initConfig}` to apply whatever changes are
needed from persistent storage.
">transformStatefulConfig</option>
    <option value="undefined">triggerInitialized</option>
    <option value="Shorthand for {@link #method!removeListener #removeListener}.
Removes an event handler.
">un</option>
    <option value="Removes a before-event handler.

Same as {@link #method!removeListener #removeListener} with `order` set to `'after'`.
">unAfter</option>
    <option value="Removes a before-event handler.

Same as {@link #method!removeListener #removeListener} with `order` set to `'before'`.
">unBefore</option>
    <option value="Destroys a given set of `{@link #method!link linked}` objects. This is only needed if
the linked object is being destroyed before this instance.
">unlink</option>
    <option value="Convenience method which calls {@link #setMasked} with a value of false (to hide the mask).
For additional functionality, call the {@link #setMasked} function direction (See the
{@link #cfg!masked #masked} configuration documentation for more information).
">unmask</option>
    <option value="This method is for use by plugins which require the grid to enter actionable mode
to focus in-cell elements. See {@link #method!registerActionable}.
">unregisterActionable</option>
    <option value="Walks up the ownership hierarchy looking for an ancestor Component which matches
the passed simple selector.

Example:

    var owningTabPanel = grid.up('tabpanel');
">up</option>
    <option value="All cls methods directly report to the {@link #cfg!cls #cls} configuration, so anytime it changes,
{@link #method!updateCls #updateCls} will be called
">updateCls</option>
    <option value="undefined">updateData</option>
    <option value="undefined">updateHeight</option>
    <option value="Updates the session config.
">updateSession</option>
    <option value="Updates the viewModel config.
">updateViewModel</option>
    <option value="undefined">updateWidth</option>
    <option value="Traverses the tree rooted at this node in post-order mode, calling the passed function
on the nodes at each level. That is the function is called upon each node **after** being
called on its children).

This method is used at each level down the cascade. Currently
{@link Ext.Component}s and {@link Ext.data.TreeModel}s are queryable.

If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery
on them.
">visitPostOrder</option>
    <option value="Traverses the tree rooted at this node in pre-order mode, calling the passed function
on the nodes at each level. That is the function is called upon each node **before**
being called on its children).

This method is used at each level down the cascade. Currently
{@link Ext.Component}s and {@link Ext.data.TreeModel}s are queryable.

If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery
on them.
">visitPreOrder</option>
    <option value="Watches config properties.

     instance.watchConfig({
         title: 'onTitleChange',
         scope: me
     });
">watchConfig</option>
    <option value="Queue a function to run when the component is visible & painted. If those conditions
are met, the function will execute  immediately, otherwise it will wait until it is
visible and painted.
">whenVisible</option>
</select></div>
</div>
  <div id="method" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="events">
<div class="flex-container">
  <div id="eventlist" class="thelist"><div>events:</div><div class="select-div"><select id="events" onchange="changeEvent()" name="events">
    <option value="Fires whenever item within the Container is activated.
">activate</option>
    <option value="This event fires when `{@link #cfg!activeItem}` changes.">activeItemchange</option>
    <option value="undefined">add</option>
    <option value="Fires after a Component had been added to a Container.
">added</option>
    <option value="This event fires when `{@link #cfg!activeItem}` changes.">beforeactiveItemchange</option>
    <option value="This event fires when `{@link #cfg!bottom}` changes.">beforebottomchange</option>
    <option value="This event fires when `{@link #cfg!centered}` changes.">beforecenteredchange</option>
    <option value="cell, checked, current, record
Fires before a node with a checkbox's checked property changes.
">beforecheckchange</option>
    <option value="Fires after a change has been made to the field, but before the change is reflected in the
underlying field.  Saving the change to the field can be canceled by returning false from
the handler of this event. Note that if the value has not changed and ignoreNoChange = true,
the editing will still end but this event will not fire since no edit actually occurred.
">beforecomplete</option>
    <option value="This event fires when `{@link #cfg!disabled}` changes.">beforedisabledchange</option>
    <option value="This event fires when `{@link #cfg!docked}` changes.">beforedockedchange</option>
    <option value="Fires before row editing is triggered. Return `false` from event handler to prevent
the editing.

This event is only fired if the {@link Ext.grid.rowedit.Plugin} plugin is
configured on the grid.
">beforeedit</option>
    <option value="Fires before a group collapse starts. Return `false` to cancel the collapse.
">beforegroupcollapse</option>
    <option value="Fires before a group expand starts. Return `false` to cancel the expand.
">beforegroupexpand</option>
    <option value="This event fires when `{@link #cfg!height}` changes.">beforeheightchange</option>
    <option value="This event fires when `{@link #cfg!hidden}` changes.">beforehiddenchange</option>
    <option value="Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
">beforehide</option>
    <option value="This event fires when `{@link #cfg!left}` changes.">beforeleftchange</option>
    <option value="Fires before a request is made for a new data object. If the beforeload handler returns
`false` the load action will be canceled.

**Note:** If you are using a buffered store, you should use
{@link Ext.data.Store#event!beforeprefetch beforeprefetch}.
">beforeload</option>
    <option value="This event fires when `{@link #cfg!maxHeight}` changes.">beforemaxHeightchange</option>
    <option value="This event fires when `{@link #cfg!maxWidth}` changes.">beforemaxWidthchange</option>
    <option value="This event fires when `{@link #cfg!minHeight}` changes.">beforeminHeightchange</option>
    <option value="This event fires when `{@link #cfg!minWidth}` changes.">beforeminWidthchange</option>
    <option value="Fires before an row is visually collapsed. May be vetoed by returning false from a handler.
">beforenodecollapse</option>
    <option value="Fires before an row is visually expanded. May be vetoed by returning false from a handler.
">beforenodeexpand</option>
    <option value="Fires before orientation changes.
">beforeorientationchange</option>
    <option value="This event fires when `{@link #cfg!right}` changes.">beforerightchange</option>
    <option value="This event fires when `{@link #cfg!scrollable}` changes.">beforescrollablechange</option>
    <option value="An event fired when an extension block is extended
using a drag gesture. Only fired when the grid's
`{@link Ext.grid.Grid.selectable #cfg!selectable}` is configured with the
{@link Ext.grid.selection.Model#cfg!extensible extensible} config.
">beforeselectionextend</option>
    <option value="Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
">beforeshow</option>
    <option value="Fires when editing is initiated, but before the value changes.  Editing can be canceled by
returning false from the handler of this event.
">beforestartedit</option>
    <option value="This event fires when `{@link #cfg!store}` changes.">beforestorechange</option>
    <option value="Fires before a {@link #cfg!floated #cfg-floated} component is brought to the front of the visual stack.
">beforetofront</option>
    <option value="This event fires when `{@link #cfg!top}` changes.">beforetopchange</option>
    <option value="This event fires when `{@link #cfg!width}` changes.">beforewidthchange</option>
    <option value="Fires when this Component's {@link #property!focusEl #focusEl} loses focus.
">blur</option>
    <option value="This event fires when `{@link #cfg!bottom}` changes.">bottomchange</option>
    <option value="Fires after editing has been canceled and the editor's value has been reset.
">canceledit</option>
    <option value="Fires when cell selection is being used and cells are selected or deselected.
">cellselection</option>
    <option value="This event fires when `{@link #cfg!centered}` changes.">centeredchange</option>
    <option value="Fires when a node with a checkbox's checked property changes.
">checkchange</option>
    <option value="Fires when a child is double tapped.
">childdoubletap</option>
    <option value="Fires when a child is long-pressed.
">childlongpress</option>
    <option value="Fires when the mouse pointer enters a child.
">childmouseenter</option>
    <option value="Fires when the mouse pointer leaves a child.
">childmouseleave</option>
    <option value="Fires when a child is single tapped.
">childsingletap</option>
    <option value="Fires when a child is tapped.
">childtap</option>
    <option value="Fires when a child is tap-held.
">childtaphold</option>
    <option value="Fires when a touch is cancelled.
">childtouchcancel</option>
    <option value="Fires when a touch ends on a child.
">childtouchend</option>
    <option value="Fires when a touch move occurs on a child.
">childtouchmove</option>
    <option value="Fires when a child is first touched.
">childtouchstart</option>
    <option value="Fires whenever a column is added to the Grid.
">columnadd</option>
    <option value="Fires whenever a column is hidden in the Grid.
">columnhide</option>
    <option value="Fired when a column first creates its column menu. This is to allow plugins
to access and manipulate the column menu.

There will be the two sort items, and a column hide/show item with a child menu of
checkboxes. After this, developers may add custom enu items.

Menu items may be configured with a `{@link #cfg!weight weight}` config, and those with the lowest weight
gravitate to the top.

The sort ascending, sort descending, and hide columns items have weight -3, -2, and -1
">columnmenucreated</option>
    <option value="Fires whenever a column is moved in the grid.
">columnmove</option>
    <option value="Fires whenever a column is removed from the Grid.
">columnremove</option>
    <option value="Fires whenever a column is resized in the Grid.
">columnresize</option>
    <option value="Fires when column selection is being used and columns are selected or deselected.
">columnselection</option>
    <option value="Fires whenever a column is shown in the Grid.
">columnshow</option>
    <option value="Fires whenever a column is sorted in the Grid.
">columnsort</option>
    <option value="Fires after editing is complete and any changed value has been written to the underlying
field.
">complete</option>
    <option value="Fires whenever item within the Container is deactivated.
">deactivate</option>
    <option value="Fires whenever an item is deselected
">deselect</option>
    <option value="Fires when the component is destroyed
">destroy</option>
    <option value="This event fires when `{@link #cfg!disabled}` changes.">disabledchange</option>
    <option value="Fires whenever a disclosure is handled
">disclose</option>
    <option value="This event fires when `{@link #cfg!docked}` changes.">dockedchange</option>
    <option value="Fires after editing.

This event is only fired if the {@link Ext.grid.rowedit.Plugin} plugin is
configured on the grid.

Usage example:

     {
         xtype: 'grid',
         plugins: 'rowedit',

         listeners: {
             edit: function(grid, location) {
                 // commit the changes right after editing finished
                 location.record.commit();
             }
         }
     }
">edit</option>
    <option value="Fires when the component is no longer displayed in the DOM.  Listening to this event will
degrade performance not recommend for general use.
">erased</option>
    <option value="Fires whenever there is a change in the positioned status of a component
">floatingchange</option>
    <option value="Fires when this Component's {@link #property!focusEl #focusEl} receives focus.
">focus</option>
    <option value="Fires when focus enters this Component's hierarchy.
">focusenter</option>
    <option value="Fires when focus leaves this Component's hierarchy.
">focusleave</option>
    <option value="Fires whenever a Component with the fullscreen config is instantiated
">fullscreen</option>
    <option value="Fires when a group collapse starts.
">groupcollapse</option>
    <option value="Fires when a group expand starts.
">groupexpand</option>
    <option value="This event fires when `{@link #cfg!height}` changes.">heightchange</option>
    <option value="This event fires when `{@link #cfg!hidden}` changes.">hiddenchange</option>
    <option value="Fires whenever the Component is hidden
">hide</option>
    <option value="Fires when the component has been initialized
">initialize</option>
    <option value="Fires whenever a swipe action has been triggered from a list item.
">itemaction</option>
    <option value="Fires whenever an item is doubletapped
">itemdoubletap</option>
    <option value="Fires whenever an item's longpress event fires
">itemlongpress</option>
    <option value="Fires whenever the mouse pointer moves over an item
">itemmouseenter</option>
    <option value="Fires whenever the mouse pointer leaves an item
">itemmouseleave</option>
    <option value="Fires whenever an item is singletapped
">itemsingletap</option>
    <option value="Fires whenever an item is swiped
">itemswipe</option>
    <option value="Fires whenever an item is tapped. Add `x-item-no-tap` CSS class to a child of list
item to suppress `{@link #event!itemtap itemtap}` events on that child. This can be useful when items
contain components such as Buttons.
">itemtap</option>
    <option value="Fires whenever an item's taphold event fires
">itemtaphold</option>
    <option value="Fires whenever an item touch is cancelled
">itemtouchcancel</option>
    <option value="Fires whenever an item is touched
">itemtouchend</option>
    <option value="Fires whenever an item is moved
">itemtouchmove</option>
    <option value="Fires whenever an item is touched
">itemtouchstart</option>
    <option value="This event fires when `{@link #cfg!left}` changes.">leftchange</option>
    <option value="Fires whenever the store reads data from a remote data source.
">load</option>
    <option value="This event fires when `{@link #cfg!maxHeight}` changes.">maxHeightchange</option>
    <option value="This event fires when `{@link #cfg!maxWidth}` changes.">maxWidthchange</option>
    <option value="This event fires when `{@link #cfg!minHeight}` changes.">minHeightchange</option>
    <option value="This event fires when `{@link #cfg!minWidth}` changes.">minWidthchange</option>
    <option value="undefined">move</option>
    <option value="Fires when a component si moved within its Container.
">moved</option>
    <option value="Fires whenever the user navigates to a new location.

In regular dataviews, a location encapsulates one view item, and its associated record.

In grids, a location encapsulates one cell, and its associated data field.
">navigate</option>
    <option value="Fires after an row has been visually collapsed and its child nodes are no longer
visible in the tree.
">nodecollapse</option>
    <option value="Fires after an row has been visually expanded and its child nodes are visible in the tree.
">nodeexpand</option>
    <option value="Fires when orientation changes.
">orientationchange</option>
    <option value="Fires whenever this Element actually becomes visible (painted) on the screen. This is
useful when you need to perform 'read' operations on the DOM element, i.e: calculating
natural sizes and positioning.

__Note:__ This event is not available to be used with event delegation. Instead `{@link #event!painted painted}`
only fires if you explicitly add at least one listener to it, for performance reasons.
">painted</option>
    <option value="Fires whenever there is a change in the positioned status of a component
">positionedchange</option>
    <option value="Fires whenever the DataView is refreshed
">refresh</option>
    <option value="undefined">remove</option>
    <option value="Fires when a component is removed from a Container
">removed</option>
    <option value="Fires whenever an item is rendered into a container or derendered
from a Container.
">renderedchange</option>
    <option value="Important note: For the best performance on mobile devices, use this only when you
absolutely need to monitor a Element's size.

__Note:__ This event is not available to be used with event delegation. Instead `{@link #event!resize resize}`
only fires if you explicitly add at least one listener to it, for performance reasons.
">resize</option>
    <option value="This event fires when `{@link #cfg!right}` changes.">rightchange</option>
    <option value="This event fires when `{@link #cfg!scrollable}` changes.">scrollablechange</option>
    <option value="Fires whenever an item is selected
">select</option>
    <option value="An event fired when an extension block is dragged to encompass
a new range. Only fired when the grid's `{@link Ext.grid.Grid.selectable #cfg!selectable}`
is configured with the {@link Ext.grid.selection.Model#cfg!extensible extensible} config.
">selectionextenderdrag</option>
    <option value="Fires whenever the Component is shown
">show</option>
    <option value="Fires when any key related to navigation (arrows, tab, enter, esc, etc.) is pressed. You can
check
{@link Ext.event.Event#method!getKey Ext.event.Event#getKey} to determine which key was pressed.
">specialkey</option>
    <option value="Fires when this editor is displayed
">startedit</option>
    <option value="This event fires when `{@link #cfg!store}` changes.">storechange</option>
    <option value="Fires when a {@link #cfg!floated #cfg-floated} component has been brought to the front of the visual
stack.
">tofront</option>
    <option value="This event fires when `{@link #cfg!top}` changes.">topchange</option>
    <option value="Fires whenever the data of the component is updated
">updatedata</option>
    <option value="Fires after editing, but before the value is set in the record. Return `false`
from the event handler to prevent the change.

This event is only fired if the {@link Ext.grid.rowedit.Plugin} plugin is
configured on the grid.

     {
         xtype: 'grid',
         plugins: 'rowedit',

         listeners: {
             edit: function(grid, location) {
                 var changes = location.editor.getChanges();

                 // validate the fields affected in changes...
             }
         }
     }
">validateedit</option>
    <option value="This event fires when `{@link #cfg!width}` changes.">widthchange</option>
</select></div>
</div>
  <div id="event" class="thetext"></div>
</div>
        </z-tabpanel>
    </z-tabs>
</div>

<p>
------------------
<pre>The TreeGrid provides a tree-structured UI representation of tree-structured data.
TreeGrids must be bound to a {@link Ext.data.TreeStore}.

TreeGrid supports multiple columns through the {@link #cfg!columns #columns} configuration.

By default a TreeGrid contains a single column that uses the `text` field of
the store's nodes.

Here is a simple TreeGrid using inline data:

    @example
    var ts = Ext.create('Ext.data.TreeStore', {
        root: {
            text: 'Genre',
            expanded: true,
            children: [
                {
                    text: 'Comedy',
                    children: [
                        { leaf: true, text: '30 Rock' },
                        { leaf: true, text: 'Arrested Development' },
                        { leaf: true, text: 'Bob\'s Burgers' },
                        { leaf: true, text: 'Curb your Enthusiasm' },
                        { leaf: true, text: 'Futurama' }
                    ]
                },
                {
                    text: 'Drama',
                    children: [
                        { leaf: true, text: 'Breaking Bad', },
                        { leaf: true, text: 'Game of Thrones' },
                        { leaf: true, text: 'Lost' },
                        { leaf: true, text: 'Preacher' },
                        { leaf: true, text: 'The Wire' }
                    ]
                },
                {
                    text: 'Science Fiction',
                    children: [
                        { leaf: true, text: 'Black Mirror' },
                        { leaf: true, text: 'Doctor Who' },
                        { leaf: true, text: 'Eureka' },
                        { leaf: true, text: 'Futurama' },
                        { leaf: true, text: 'The Twilight Zone' },
                        { leaf: true, text: 'X-Files' }
                    ]
                }
            ]
        }
    });

    Ext.create({
        fullscreen: true,
        xtype: 'panel',

        items: [{
            xtype: 'tree',
            height: 600,
            width: 400,
            store: ts,
            title: 'Favorite Shows by Genre'
        }]
    });
</pre>

<span><b>Ext JS name:</b></span>
<br>
<span>Ext.grid.Tree</span>
<br><br>
<span><b>others:</b></span>
extend: 
extenders: 
mixed: Ext.Mixin,Ext.mixin.Accessible,Ext.mixin.Bindable,Ext.mixin.Bufferable,Ext.mixin.ComponentDelegation,Ext.mixin.ConfigProxy,Ext.mixin.Container,Ext.mixin.Factoryable,Ext.mixin.Focusable,Ext.mixin.FocusableContainer,Ext.mixin.Identifiable,Ext.mixin.Inheritable,Ext.mixin.ItemRippler,Ext.mixin.Keyboard,Ext.mixin.Observable,Ext.mixin.Pluggable,Ext.mixin.Queryable,Ext.state.Stateful
mixins: 
requires: 
src: [object Object]



</div>

</body>
</html>