<!DOCTYPE HTML>
<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="z-tabs.js"></script>

<script>
function changeProperty() {
  var x = document.getElementById("properties").value;
  document.getElementById("property").innerHTML = x;
}
function changeMethod() {
  var x = document.getElementById("methods").value;
  document.getElementById("method").innerHTML = x;
}
function changeEvent() {
  var x = document.getElementById("events").value;
  document.getElementById("event").innerHTML = x;
}
</script>

</head>
<body>

<div>






<!--
<div class="heading">&lt;ext-slider&gt;&lt;/ext-slider&gt;</div>
-->

<div class="heading">ext-slider</div>
<br>
<pre>he slider component utilized by `{@link Ext.field.Slider}`.

The slider is a way to allow the user to select a value from a given numerical range.
You might use it for choosing a percentage, combine ...</pre>
<br>
<div><b>JavaScript:</b></div>

<pre class="code">
import '@sencha/ext-web-components/lib/ext-slider.component';

sliderReady(event) {
  this.SliderCmp = event.detail.cmp;
}
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-slider onready="sliderReady"&gt;&lt;/ext-slider&gt;
</pre>


<!--
<pre class="code">
import '@sencha/ext-web-components/lib/ext-slider.component';

class SliderComponentExample {

  onSliderReady(event) {
    this.SliderCmp = event.detail.cmp;
  }

}

window.SliderExample = new SliderComponentExample();
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-slider onready="SliderExample.onSliderReady"&gt;
...
&lt;/ext-slider&gt;
</pre>
-->

<div style="height:300px;">
    <z-tabs>
        <z-tabpanel tabname="properties">
<div class="flex-container">
  <div id="propertylist" class="thelist"><div>properties:</div><div class="select-div"><select id="properties" onchange="changeProperty()" name="properties">
    <option value="Specifies the self alignment of this widget in a box layout
">alignSelf</option>
    <option value="Whether or not to allow multiple thumbs to
overlap each other. Setting this to true guarantees the ability to select every
possible value in between {@link #cfg!minValue #minValue} and {@link #cfg!maxValue #maxValue} that
satisfies {@link #cfg!increment #increment}
">allowThumbsOverlapping</option>
    <option value="A flag indicating that this component should
be above its floated siblings.

This may be a positive number to prioritize the ordering of multiple visible always on
top components.

This may be set to a *negative* number to prioritize a component to the *bottom* of the
z-index stack.
">alwaysOnTop</option>
    <option value="The animation to use when moving the slider. Possible properties are:

- duration
- easingX
- easingY
">animation</option>
    <option value="An object containing ARIA attributes to be set
on this Component's ARIA element. Use this to set the attributes that cannot be
determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.

**Note** that this config is only meaningful at the Component rendering time,
and setting it after that will do nothing.
">ariaAttributes</option>
    <option value="DOM selector for a child element that is to be used
as description for this Component, set in `aria-describedby` attribute.
The selector works the same way as {@link #cfg!ariaLabelledBy #ariaLabelledBy}.
">ariaDescribedBy</option>
    <option value="ARIA label for this Component. It is best to use
{@link #cfg!ariaLabelledBy #ariaLabelledBy} option instead, because screen readers prefer
`aria-labelledby` attribute to `aria-label`. {@link #cfg!ariaLabel #ariaLabel} and
{@link #cfg!ariaLabelledBy #ariaLabelledBy} config options are mutually exclusive.
">ariaLabel</option>
    <option value="DOM selector for a child element that is to be used
as label for this Component, set in `aria-labelledby` attribute.
If the selector is by `{@link #cfg!id #id}`, the label element can be any existing element,
not necessarily a child of the main Component element.

{@link #cfg!ariaLabelledBy #ariaLabelledBy} and {@link #cfg!ariaLabel #ariaLabel} config options are
mutually exclusive, and `{@link #cfg!ariaLabelledBy ariaLabelledBy}` has the higher precedence.
">ariaLabelledBy</option>
    <option value="If `true`, then, when {@link #method!showBy #showBy} or {@link #method!alignTo #alignTo} fallback on
constraint violation only takes place along the major align axis.

That is, if alignment `"l-r"` is being used, and `axisLock: true` is used,
then if constraints fail, only fallback to `"r-l"` is considered.
">axisLock</option>
    <option value="Setting this config option adds or removes data bindings for other configs.
For example, to bind the `title` config:

     var panel = Ext.create({
         xtype: 'panel',
         bind: {
             title: 'Hello {user.name}'
         }
     });

To dynamically add bindings:

     panel.setBind({
         title: 'Greetings {user.name}!'
     });

To remove bindings:

     panel.setBind({
         title: null
     });

The bind expressions are presented to `{@link Ext.app.ViewModel#method!bind Ext.app.ViewModel#bind}`. The
`ViewModel` instance is determined by `{@link #method!lookupViewModel lookupViewModel}`.

**Note:** If  bind is passed as a string, it will use the
{@link Ext.Component#property!defaultBindProperty Ext.Component#property-defaultBindProperty} for the binding.
">bind</option>
    <option value="Enables or disables bordering on this component.
The following values are accepted:

- `null` or `true (default): Do nothing and allow the border to be specified
by the theme.
- `false`: suppress the default border provided by the theme.

Please note that enabling bordering via this config will not add a `border-color`
or `border-style` CSS property to the component; you provide the `border-color`
and `border-style` via CSS rule or {@link #cfg!style #style} configuration
(if not already provide by the theme).

## Using {@link #cfg!style #style}:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        style: 'border: 1px solid blue;'
        // ...
    });

## Using CSS:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        cls: 'my-component'
        // ...
    });

And your CSS file:

    .my-component {
        border: 1px solid red;
    }
">border</option>
    <option value="The absolute bottom position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">bottom</option>
    <option value="Configure this as `true` to have this Component centered within its Container.
Setting this value to `true` will make this Component become 'positioned', which means
it will no longer participate in the layout of the Container that it resides in.
">centered</option>
    <option value="The CSS class to add to this widget's element, in
addition to the {@link #property!baseCls #baseCls}. In many cases, this property will be specified
by the derived widget class. See {@link #cfg!userCls #userCls} for adding additional CSS
classes to widget instances (such as items in a {@link Ext.Container}).
">cls</option>
    <option value="A specification of the constraint to apply when {@link #method!showBy #showBy} or {@link #method!alignTo #alignTo}
is called to align a {@link #cfg!floated #floated} or positioned component.

Defaults to the parent container for *positioned* components (components
which have their {@link #cfg!top}, {@link #cfg!right}, {@link #cfg!bottom} or
{@link #cfg!left} set to move them out of their container's layout flow).

Defaults to the viewport for {@link #cfg!floated #floated} components.

May be a {@link Ext.ComponentQuery} selector to find an ancestor
component to constrain within.

May be `false` to specify that constraining is not applied.

You may also specify an element, or a {@link Ext.util.Region}
">constrainAlign</option>
    <option value="The configured element will automatically be added as the content of this
component. When you pass a string, we expect it to be an element id. If the
content element is hidden, we will automatically show it.
">contentEl</option>
    <option value="A string alias, a configuration object or an instance of a `ViewController` for
this container. Sample usage:

    Ext.define('MyApp.UserController', {
        alias: 'controller.user'
    });

    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: 'user'
    });
    // Or
    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: {
            type: 'user',
            someConfig: true
        }
    });

    // Can also instance at runtime
    var ctrl = new MyApp.UserController();
    var view = new UserContainer({
        controller: ctrl
    });
">controller</option>
    <option value="The initial set of data to apply to the `{@link #cfg!tpl #tpl}` to
update the content area of the Component.

**Note:** Data will be appended to any existing data.
">data</option>
    <option value="If `true`, this component will be the default scope (this pointer) for events
specified with string names so that the scope can be dynamically resolved. The
component will automatically become the defaultListenerScope if a
{@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for some sample
usages.

**NOTE**: This value can only be reliably set at construction time. Setting it
after that time may not correctly rewire all of the potentially effected
listeners.
">defaultListenerScope</option>
    <option value="Whether or not this component is disabled
">disabled</option>
    <option value="Set to `true` to call `show` and `false` to call `hide`. Unlike the `{@link #cfg!hidden hidden}`
config, changing this config will potentially involve animations to show or
hide the component.
">displayed</option>
    <option value="The dock position of this component in its container. Can be `{@link #cfg!left left}`, `{@link #cfg!top top}`, `{@link #cfg!right right}` or
`{@link #cfg!bottom bottom}`.

__Notes__

You must use a HTML5 doctype for {@link #cfg!docked #docked} `{@link #cfg!bottom bottom}` to work. To do this, simply
add the following code to the HTML file:

    <!doctype html>

So your index.html file should look a little like this:

    <!doctype html>
    <html>
        <head>
            <title>MY application title</title>
            ...
">docked</option>
    <option value="Set to `true` to allow this component to be dragged. This can also be the config
object for the `{@link Ext.drag.Source}` that will manage the drag.
">draggable</option>
    <option value="Animation effect to apply when the Component is being shown.  Typically you want to use
an inbound animation type such as 'fadeIn' or 'slideIn'.
">enterAnimation</option>
    <option value="A map of event type to the corresponding handler method
name. This is used internally by native event handling mechanism.
">eventHandlers</option>
    <option value="Animation effect to apply when the Component is being hidden.
">exitAnimation</option>
    <option value="The flex of this item *if* this item item is inside a {@link Ext.layout.HBox}
or {@link Ext.layout.VBox} layout.

You can also update the flex of a component dynamically using
the {@link Ext.layout.FlexBox#setItemFlex} method.

When supplied as a string or number this option supports the same syntax
as CSS [flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex).
For example:

    flex: '1 2 auto'

sets `flex-grow` property to `0`, `flex-shrink` to `2` and `flex-basis` to
`'auto'`.

The default `flex-shrink` value for box layout items is set to `0` in the
stylesheet, which is different from the browser's default `flex-shrink` value
of `1`.  This accommodates the majority use case for applications since where
non-flexed components are typically not expected to shrink smaller than their
default size.

For convenience when only a single number is supplied it is used as the value
for both `flex-grow` and `flex-shrink`, for example `flex: 3` is the same as
`flex: '3 3'`

An object form is also accepted:

    flex: {
        grow: 1,
        shrink: 2,
        basis: 'auto'
    }

When the object form is supplied `shrink` always defaults to `0` regardless
of the value of `grow`.

Although `'auto'` is the default value for flex-basis, flex-basis defaults to 0%
when flex is supplied as a single numeric or string value (e.g. `flex: 1`). If
this behavior is not desired either explicitly set flex-basis to `'auto'` or use
the object form to set only grow and/or shrink:

    flex: {
        grow: 2
    }
">flex</option>
    <option value="A Component may be floated above all other components in the application. This means that
the component is absolutely positioned, and will move to the front and occlude other
sibling floated component if clicked.

A Floated component may have floated descendants. It will bring these decendants to the
front with it when brought to the front of its sibling floated components.

By default, descendant floated components are all positioned using the viewport
coordinate system. To make a floating component a positioning parent for descendants,
and have the ancestors positioned relatively, configure the parent floated component
with `{@link #cfg!relative #cfg-relative}: true`.
">floated</option>
    <option value="CSS class that will be added to focused
component's {@link #property!focusClsEl #focusClsEl}, and removed when component blurs.
">focusCls</option>
    <option value="Force the component to take up 100% width and height available, by adding it
to {@link Ext.Viewport}.
">fullscreen</option>
    <option value="The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">height</option>
    <option value="Whether or not this Component is hidden (its CSS `display` property is set to `none`).

Defaults to `true` for {@link #cfg!floated #floated} Components.
">hidden</option>
    <option value="Animation effect to apply when the Component is being hidden.  Typically you want to use
an outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check
the {@link Ext.fx.Animation#cfg!type Ext.fx.Animation#type} config.
">hideAnimation</option>
    <option value="A String which specifies how this component's DOM element will be hidden. The
accepted values are any of these:

- `'clip'` : Hide using {@link Ext.dom.Element#static-property!CLIP clip}.
- `'display'` : Hide using {@link Ext.dom.Element#static-property!DISPLAY display}.
- `'offsets'` : Hide using positioning {@link Ext.dom.Element#static-property!OFFSETS offsets}.
- `'opacity'` : Hide using {@link Ext.dom.Element#static-property!OPACITY opacity}.
- `'visibility'` : Hide using {@link Ext.dom.Element#static-property!VISIBILITY visibility}.

Hiding using ``display`` results in having no dimensions as well as resetting
scroll positions to 0.

The other modes overcome this but may have different trade-offs in certain
circumstances.
">hideMode</option>
    <option value="When using a {@link #cfg!modal} Component, setting this to `true` will hide
the modal mask and the Container when the mask is tapped on.
">hideOnMaskTap</option>
    <option value="Optional HTML content to render inside this Component, or a reference to an
existing element on the page.
">html</option>
    <option value="The **unique id of this component instance.**

It should not be necessary to use this configuration except for singleton objects in
your application. Components created with an id may be accessed globally
using {@link Ext#method!getCmp Ext.getCmp}.

Instead of using assigned ids, use the {@link #cfg!itemId #itemId} config,
and {@link Ext.ComponentQuery} which provides selector-based searching
for Sencha Components analogous to DOM querying. The {@link Ext.Container} class
contains {@link Ext.Container#method!down shortcut methods} to query its descendant Components
by selector.

Note that this id will also be used as the element id for the containing HTML element
that is rendered to the page for this component. This allows you to write id-based CSS
rules to style the specific instance of this component uniquely, and also to select
sub-elements using this component's id as the parent.

**Note**: to avoid complications imposed by a unique id also see `{@link #cfg!itemId #itemId}`.

Defaults to an auto-assigned id.
">id</option>
    <option value="The increment by which to snap each thumb when its value
changes. Any thumb movement will be snapped to the nearest value that is a multiple
of the increment (e.g. if increment is 10 and the user tries to move the thumb to 67,
it will be snapped to 70 instead)
">increment</option>
    <option value="
An extra CSS class or classes to augment the {@link #property!classCls #classCls} on an individual instance
">instanceCls</option>
    <option value="An itemId can be used as an alternative way to get a reference to a component when no
object reference is available. Instead of using an `{@link #cfg!id #id}` with {@link Ext#method!getCmp Ext#getCmp},
use `{@link #cfg!itemId itemId}` with {@link Ext.Container#method!getComponent Ext.Container#getComponent} which will retrieve `{@link #cfg!itemId itemId}`'s or
{@link #cfg!id #id}'s. Since `{@link #cfg!itemId itemId}`'s are an index to the container's internal MixedCollection,
the `{@link #cfg!itemId itemId}` is scoped locally to the container - avoiding potential conflicts with
{@link Ext.ComponentManager} which requires a **unique** `{@link #cfg!id #id}`.

Also see {@link #cfg!id #id}, {@link Ext.Container#method!query Ext.Container#query}, {@link Ext.Container#method!down Ext.Container#down} and
{@link Ext.Container#method!child Ext.Container#child}.
">itemId</option>
    <option value="An object containing handlers for keyboard events. The property names of this
object are the key name and any modifiers. The values of the properties are the
descriptors of how to handle each event.

The handler descriptor can be simply the handler function(either the
literal function or the method name), or it can be an object with these
properties:

 - `handler`: The function or its name to call to handle the event.
 - `scope`: The this pointer context (can be "this" or "controller").
 - `event`: An optional override of the key event to which to listen.

**Important:** Calls to `setKeyMap` do not replace the entire `{@link #cfg!keyMap keyMap}` but
instead update the provided mappings. That is, unless `null` is passed as the
value of the `{@link #cfg!keyMap keyMap}` which will clear the `{@link #cfg!keyMap keyMap}` of all entries.
">keyMap</option>
    <option value="Enables or disables processing keys in the `{@link #cfg!keyMap keyMap}`. This value starts as
`null` and if it is `null` when `{@link #method!initKeyMap initKeyMap}` is called, it will automatically
be set to `true`. Since `{@link #method!initKeyMap initKeyMap}` is called by `{@link Ext.Component}` at the
proper time, this is not something application code normally handles.
">keyMapEnabled</option>
    <option value="The name of the member that should be used to listen for keydown/keypress events.
This is intended to be controlled at the class level not per instance.
">keyMapTarget</option>
    <option value="The absolute left position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">left</option>
    <option value="
A config object containing one or more event handlers to be added to this object during
initialization. This should be a valid listeners config object as specified in the
{@link Ext.util.Observable#method!addListener addListener} example for attaching
multiple handlers at once.

**DOM events from Ext JS {@link Ext.Component}**

While _some_ Ext JS Component classes export selected DOM events (e.g. "click",
"mouseover" etc), this is usually only done when extra value can be added. For example
the {@link Ext.view.View DataView}'s **`{@link Ext.view.View#itemclick itemclick}`**
event passing the node clicked on. To access DOM events directly from a child element
of a Component, we need to specify the `element` option to identify the Component
property to add a DOM listener to:

    new Ext.panel.Panel({
        width: 400,
        height: 200,
        dockedItems: [{
            xtype: 'toolbar'
        }],
        listeners: {
            click: {
                element: 'el', //bind to the underlying el property on the panel
                fn: function(){ console.log('click el'); }
            },
            dblclick: {
                element: 'body', //bind to the underlying body property on the panel
                fn: function(){ console.log('dblclick body'); }
            }
        }
    });
">listeners</option>
    <option value="The margin to use on this Component. Can be specified as a number (in which
case all edges get the same margin) or a CSS string like '5 10 10 10'
">margin</option>
    <option value="The maximum height of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size. Note that this config will not apply if the
Component is 'positioned' (absolutely positioned or centered)
">maxHeight</option>
    <option value="The highest value any thumb on this slider can be set to.
">maxValue</option>
    <option value="The maximum width of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size. Note that this config will not apply if the
Component is 'positioned' (absolutely positioned or centered)
">maxWidth</option>
    <option value="The minimum height of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">minHeight</option>
    <option value="The lowest value any thumb on this slider can be set to.
">minValue</option>
    <option value="The minimum width of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">minWidth</option>
    <option value="`true` to make this Component modal. This will create a mask underneath the
Component that covers its parent and does not allow the user to interact with
any other Components until this Component is dismissed.
">modal</option>
    <option value="This config enables binding to your `{@link Ext.data.Model#cfg!validators Ext.data.Model#validators}`. This
is only processed by form fields (e.g., `Ext.field.*`) at present, however, this
setting is inherited and so can be set on a parent container.

When set to `true` by a component (or by an ancestor container), the `validators`
of for any {@Ext.data.Model record} fields will be used wherever the `value` is
bound to such data fields.

While this config can be set arbitrarily high in the component hierarchy, doing
so can create a lot overhead if most of your form fields do not actually rely on
`validators` in your data model.

Using this setting for a form that is bound to an `{@link Ext.data.Model}` might look
like this:

     {
         xtype: 'panel',
         modelValidation: true,
         items: [{
             xtype: 'textfield',
             bind: '{theUser.firstName}'
         },{
             xtype: 'textfield',
             bind: '{theUser.lastName}'
         },{
             xtype: 'textfield',
             bind: '{theUser.phoneNumber}'
         },{
             xtype: 'textfield',
             bind: '{theUser.email}'
         }]
     }
">modelValidation</option>
    <option value="Name for the widget to be used with {@link Ext.Container#method!lookupName Ext.Container#lookupName}
et al.
">name</option>
    <option value="Set to `true` for this component's `name` property to be tracked by its containing
`nameHolder`.
">nameable</option>
    <option value="The padding to use on this Component. Can be specified as a number (in which
case all edges get the same padding) or a CSS string like '5 10 10 10'
">padding</option>
    <option value="This config describes one or more plugin config objects used to create plugin
instances for this component.

Plugins are a way to bundle and reuse custom functionality. Plugins should extend
`{@link Ext.plugin.Abstract}` but technically the only requirement for a valid plugin
is that it contain an `init` method that accepts a reference to its owner. Once
a plugin is created, the owner will call the `init` method, passing a reference
to itself. Each plugin can then call methods or respond to events on its owner
as needed to provide its functionality.

This config's value can take several different forms.

The value can be a single string with the plugin's {@link Ext.enums.Plugin alias}:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: 'listpaging'
     });

In the above examples, the string "listpaging" is the type alias for
`{@link Ext.dataview.plugin.ListPaging}`. The full alias includes the "plugin." prefix
(i.e., 'plugin.listpaging').

The preferred form for multiple plugins or to configure plugins is the
keyed-object form (new in version 6.5):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: {
             pullrefresh: true,
             listpaging: {
                 autoPaging: true,
                 weight: 10
             }
         }
     });

The object keys are the `id`'s as well as the default type alias. This form
allows the value of the `{@link #cfg!plugins plugins}` to be merged from base class to derived class
and finally with the instance configuration. This allows classes to define a
set of plugins that derived classes or instantiators can further configure or
disable. This merge behavior is a feature of the
{@link Ext.Class#cfg!config}.

The `{@link #cfg!plugins plugins}` config can also be an array of plugin aliases (arrays are not
merged so this form does not respect plugins defined by the class author):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

An array can also contain elements that are config objects with a `type`
property holding the type alias:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['pullrefresh', {
             type: 'listpaging',
             autoPaging: true
         }]
     });
">plugins</option>
    <option value="One or more names of config properties that this component should publish
to its ViewModel. Generally speaking, only properties defined in a class config
block (including ancestor config blocks and mixins) are eligible for publishing
to the viewModel. Some components override this and publish their most useful
configs by default.

**Note:** We'll discuss publishing properties **not** found in the config block below.

Values determined to be invalid by component (often form fields and model validations)
will not be published to the ViewModel.

This config uses the `{@link #cfg!reference #cfg-reference}` to determine the name of the data
object to place in the `ViewModel`. If `{@link #cfg!reference reference}` is not set then this config
is ignored.

By using this config and `{@link #cfg!reference #cfg-reference}` you can bind configs between
components. For example:

     ...
         items: [{
             xtype: 'textfield',
             reference: 'somefield',  // component's name in the ViewModel
             publishes: 'value' // value is not published by default
         },{
             ...
         },{
             xtype: 'displayfield',
             bind: 'You have entered "{somefield.value}"'
         }]
     ...

Classes must provide this config as an Object:

     Ext.define('App.foo.Bar', {
         publishes: {
             foo: true,
             bar: true
         }
     });

This is required for the config system to properly merge values from derived
classes.

For instances this value can be specified as a value as show above or an array
or object as follows:

     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: [
             'value',
             'rawValue',
             'dirty'
         ]
     }

     // This achieves the same result as the above array form.
     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: {
             value: true,
             rawValue: true,
             dirty: true
         }
     }

In some cases, users may want to publish a property to the viewModel that is not found
in a class  config block. In these situations, you may utilize {@link #method!publishState #publishState}
if the property has a  setter method. Let's use
{@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:

      setFieldLabel: function(fieldLabel) {
          this.callParent(arguments);
          this.publishState('fieldLabel', fieldLabel);
      }

With the above chunk of code, fieldLabel may now be published to the viewModel.
">publishes</option>
    <option value="Will make this field read only, meaning it cannot be changed from the user interface.
">readOnly</option>
    <option value="A model instance which updates the Component's html based on it's tpl. Similar
to the data configuration, but tied to to a record to make allow dynamic
updates.  This must be a model instance and not a configuration of one.
">record</option>
    <option value="Specifies a name for this component inside its component hierarchy. This name
must be unique within its {@link Ext.Container#cfg!referenceHolder view}
or its {@link Ext.app.ViewController}. See the documentation in
{@link Ext.Container Ext.container.Container} for more information about references.

**Note**: Valid identifiers start with a letter or underscore and are followed
by zero or more additional letters, underscores or digits. References are case
sensitive.
">reference</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure this as `true` if you require descendant floated components to be positioned
relative to this component's coordinate space, not the viewport's coordinate space.

*Note:* The coordinate space is this Component's encapsulating element's area. Not that
of the inner element in which static child items are rendered by the layout.
">relative</option>
    <option value="Optional element to render this Component to.
Not required if this component is an {@link Ext.Container#cfg!items item} of a Container
of a Container.
">renderTo</option>
    <option value="The absolute right position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">right</option>
    <option value="Set to truthy, Color or Object value for the ripple.
">ripple</option>
    <option value="Configuration options to make this Component scrollable. Acceptable values are:

- `true` to enable auto scrolling.
- `false` (or `null`) to disable scrolling - this is the default.
- `{@link #cfg!x x}` or `horizontal` to enable horizontal scrolling only
- `{@link #cfg!y y}` or `vertical` to enable vertical scrolling only

Also accepts a configuration object for a `{@link Ext.scroll.Scroller}` if
if advanced configuration is needed.

The getter for this config returns the {@link Ext.scroll.Scroller}
instance.  You can use the Scroller API to read or manipulate the scroll position:

    // scrolls the component to 5 on the x axis and 10 on the y axis
    component.getScrollable().scrollTo(5, 10);
">scrollable</option>
    <option value="If provided this creates a new `Session` instance for this component. If this
is a `Container`, this will then be inherited by all child components.

To create a new session you can specify `true`:

     Ext.create({
         xtype: 'viewport',
         session: true,

         items: [{
             ...
         }]
     });

Alternatively, a config object can be provided:

     Ext.create({
         xtype: 'viewport',
         session: {
             ...
         },

         items: [{
             ...
         }]
     });
">session</option>
    <option value="Configure as `true` for the component to have a drop shadow. 'false' will suppress any
default shadow. By default the theme will determine the presence of a shadow.
">shadow</option>
    <option value="Set to `true` to allow this component's `name` to be shared by other items in the
same `nameHolder`. Such items will be returned in an array from `lookupName`.
">shareableName</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure as `true` for the component to use an `<iframe>` as an underlay to ensure
certain non-standard browser plugins are occluded by this component.
">shim</option>
    <option value="Animation effect to apply when the Component is being shown.  Typically you want to use
an inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the
{@link Ext.fx.Animation#cfg!type Ext.fx.Animation#type} config.
">showAnimation</option>
    <option value="
This config specifies the config properties that will be persisted using the
{@link Ext.state.Provider}. If this config is set to `true`, the
configs specified by `{@link #cfg!statefulDefaults statefulDefaults}` will be assumed.

     stateful: true

Otherwise, this config can be an array of strings of the properties to save:

     stateful: [
         'width',
         'height',
         'collapsed'
     ]

The above is equivalent to:

     stateful: {
         width: true,
         height: true,
         collapsed: true
     }

**Note:** To be truly stateful, an `id` or `{@link #cfg!stateId stateId}` must also be assigned.

A stateful object will save its state when any of these config properties change
value.
">stateful</option>
    <option value="The default set of {@link #cfg!stateful} properties. The form of this config
is the same as {@link #cfg!stateful} except this config cannot be a Boolean.

This config is intended for classes to specify so that instances can simply
enable statefulness using `stateful: true`.
">statefulDefaults</option>
    <option value="The unique id for this object to use for state management purposes.
">stateId</option>
    <option value="Additional CSS styles that will be rendered into an inline style attribute when
the widget is rendered.

You can pass either a string syntax:

    style: 'background:red'

Or by using an object:

    style: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    style: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
">style</option>
    <option value="DOM tabIndex attribute for this component's
{@link #property!focusEl #focusEl}.
">tabIndex</option>
    <option value="The config object to factory
{@link Ext.slider.Thumb} instances
">thumbDefaults</option>
    <option value="True to automatically call {@link #method!toFront #toFront} when a {@link #cfg!floated #cfg-floated} Component is
shown.
">toFrontOnShow</option>
    <option value="The tooltip for this component - can be a string to be used as innerHTML
(html tags are accepted) or {@link Ext.tip.ToolTip} config object.

The default behavior is to use a shared tip instance. The tooltip configuration is
registered with the {@link Ext.tip.Manager}. To enable this, your application can set
the {@link Ext.app.Application#cfg!quickTips Ext.app.Application#quickTips} config, or an instance of the
{@link Ext.tip.Manager} may be created manually.

To force a unique tooltip instance to be created, specify `autoCreate: true` on this
configuration.

Configuring this with `autoHide: false` implies `autoCreate: true` so that the desired
persistent behavior can be obtained with other targets still showing the singleton
instance.
">tooltip</option>
    <option value="The absolute top position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
">top</option>
    <option value="
Emulates the behavior of the CSS
[touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
property in a cross-browser compatible manner.

Keys in this object are touch action names, and values are `false` to disable
a touch action or `true` to enable it.  Accepted keys are:

- `panX`
- `panY`
- `pinchZoom`
- `doubleTapZoom`

All touch actions are enabled (`true`) by default, so it is usually only necessary
to specify which touch actions to disable.  For example, the following disables
only horizontal scrolling and pinch-to-zoom on the component's main element:

    touchAction: {
        panX: false,
        pinchZoom: false
    }

Touch actions can be specified on reference elements using the reference element
name, for example:

    // disables horizontal scrolling on the main element, and double-tap-zoom
    // on the child element named "body"
    touchAction: {
        panY: false
        body: {
            doubleTapZoom: false
        }
    }

The primary motivation for setting the touch-action of an element is to prevent
the browser's default handling of a gesture such as pinch-to-zoom, or
drag-to-scroll, so that the application can implement its own handling of that
gesture on the element.  Suppose, for example, a component has a custom drag
handler on its element and wishes to prevent horizontal scrolling of its container
while it is being dragged:

    Ext.create('Ext.Widget', {
        touchAction: {
            panX: false
        },
        listeners: {
            drag: function(e) {
                // implement drag logic
            }
        }
    });
">touchAction</option>
    <option value="A {@link String}, {@link Ext.Template}, {@link Ext.XTemplate} or an {@link Array} of
strings to form an {@link Ext.XTemplate}. Used in conjunction with the {@link #cfg!data #data}
and {@link #cfg!tplWriteMode #tplWriteMode} configurations.

__Note__
The {@link #cfg!data #data} configuration _must_ be set for any content to be shown in the
component when using this configuration.
">tpl</option>
    <option value="The Ext.(X)Template method to use when updating the content area of the
Component.

Valid modes are:

- append
- insertAfter
- insertBefore
- insertFirst
- overwrite
">tplWriteMode</option>
    <option value="undefined">translatable</option>
    <option value="This object holds a map of `config` properties that will update their binding
as they are modified. For example, `value` is a key added by form fields. The
form of this config is the same as `{@link #cfg!publishes}`.

This config is defined so that updaters are not created and added for all
bound properties since most cannot be modified by the end-user and hence are
not appropriate for two-way binding.
">twoWayBindable</option>
    <option value="The ui or uis to be used on this Component

When a ui is configured, CSS class names are added to the {@link #property!element #element}, created
by appending the ui name(s) to each {@link #property!classCls #classCls} and/or {@link #property!baseCls #baseCls}.
">ui</option>
    <option value="One or more CSS classes to add to the component's primary element. This config
is intended solely for use by the component instantiator (the "user"), not by
derived classes.

For example:

     items: [{
         xtype: 'button',
         userCls: 'my-button'
     ...
     }]
">userCls</option>
    <option value="
Set to true to allow users to select text within this component.

Can also be any valid value for the CSS3
[user-select](https://developer.mozilla.org/en-US/docs/Web/CSS/user-select) property.

A value of true implies `auto`, while false implies `none`.

May also be an object keyed by child element name.

By default, the user cannot click+drag+select text/elements of the UI.  Applications may
want to enable user selection for specific DOM elements, such as the bodyElement of
a component used as a tab panel.  The tab and tab text would not be user selectable in
this example, but the content area when the tab is selected would.

     userSelectable: {
         element: true,       // allow the element to be user selectable
         bodyElement: true    // allow the component's body element to be user selectable
     }
">userSelectable</option>
    <option value="The value(s) of this slider's thumbs. If you pass
a number, it will assume you have just 1 thumb.
">value</option>
    <option value="If `false` the {@link #cfg!value #value} will be a number when a single value is given
(even if it's an array containing that single value), and an array,
when an array of values was given.
If `true`, the {@link #cfg!value #value} will always be converted to an array.
">valueIsArray</option>
    <option value="Alias to {@link #cfg!value #value}
">values</option>
    <option value="The `ViewModel` is a data provider for this component and its children. The
data contained in the `ViewModel` is typically used by adding `{@link #cfg!bind bind}` configs
to the components that want present or edit this data.

When set, the `ViewModel` is created and links to any inherited `{@link #cfg!viewModel viewModel}`
instance from an ancestor container as the "parent". The `ViewModel` hierarchy,
once established, only supports creation or destruction of children. The
parent of a `ViewModel` cannot be changed on the fly.

If this is a root-level `ViewModel`, the data model connection is made to this
component's associated `{@link Ext.data.Session}`. This is
determined by calling `getInheritedSession`.
">viewModel</option>
    <option value="This value controls this item's order in a {@link Ext.Container#cfg!weighted}
{@link Ext.Container} (see {@link #cfg!parent}).

Lower values gravitate towards the start of the container - the top in vertical layouts,
the locale start side in horizontal layouts.
">weight</option>
    <option value="The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">width</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
">x</option>
    <option value="The `{@link #cfg!xtype xtype}` configuration option can be used to optimize Component creation and rendering.
It serves as a shortcut to the full component name. For example, the component
`Ext.button.Button` has an xtype of `button`.

You can define your own xtype on a custom {@link Ext.Component} like so:

    Ext.define('PressMeButton', {
        extend: 'Ext.button.Button',
        xtype: 'pressmebutton',
        text: 'Press Me'
    });

Any Component can be created implicitly as an object config with an xtype specified,
allowing it to be declared and passed into the rendering pipeline without actually being
instantiated as an object. Not only is rendering deferred, but the actual creation of the
object itself is also deferred, saving memory and resources until they are actually needed.
In complex, nested layouts containing many Components, this can make a noticeable
improvement in performance.

    // Explicit creation of contained Components:
    var panel = new Ext.Panel({
       // ...
       items: [
          Ext.create('Ext.button.Button', {
             text: 'OK'
          })
       ]
    });

    // Implicit creation using xtype:
    var panel = new Ext.Panel({
       // ...
       items: [{
          xtype: 'button',
          text: 'OK'
       }]
    });

In the first example, the button will always be created immediately during the panel's
initialization. With many added Components, this approach could potentially slow the
rendering of the page. In the second example, the button will not be created or rendered
until the panel is actually displayed in the browser. If the panel is never displayed
(for example, if it is a tab that remains hidden) then the button will never be created and
will never consume any resources whatsoever.
">xtype</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
">y</option>
    <option value="The z-index to give this Component when it is rendered.

Not valid for {@link #cfg!floated #cfg-floated} Components. The Z ordering of {@link #cfg!floated #cfg-floated}
Components is managed by ordering of the DOM elements.
">zIndex</option>
</select></div>
</div>
  <div id="property" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="methods">
<div class="flex-container">
  <div id="methodlist" class="thelist"><div>methods:</div><div class="select-div"><select id="methods" onchange="changeMethod()" name="methods">
    <option value="Adds declarative listeners as nested arrays of listener objects.
">_addDeclaredListeners</option>
    <option value="Sets up a reference on our current reference holder.
">_fixReference</option>
    <option value="This method is called before `{@link #method!destroy destroy}` to ensure that this instance's `{@link #cfg!stateful stateful}`
properties are saved to persistent storage. Since this object is about to be
destroyed, this cannot be delayed.
">_flushStateful</option>
    <option value="Returns the state id for this object.
">_getStateId</option>
    <option value="Creates a particular plugin type if defined in the `{@link #cfg!plugins plugins}` configuration.
">activatePlugin</option>
    <option value="Alias for {@link #method!onAfter #onAfter}.
">addAfterListener</option>
    <option value="Alias for {@link #method!onBefore #onBefore}.
">addBeforeListener</option>
    <option value="Adds a CSS class (or classes) to this Component's rendered element.
">addCls</option>
    <option value="Adds a listeners with the "delegate" event option.  Users should not invoke this
method directly.  Use the "delegate" event option of
{@link Ext.util.Observable#method!addListener addListener} instead.
">addDelegatedListener</option>
    <option value="This method applies a versioned, deprecation declaration to this class. This
is typically called by the `deprecated` config.
">addDeprecations</option>
    <option value="Adds an element reference to this Widget instance.
">addElementReference</option>
    <option value="Reduces instantiation time for a Widget by lazily instantiating Ext.Element
references the first time they are used.  This optimization only works for elements
with no listeners specified.
">addElementReferenceOnDemand</option>
    <option value="The {@link #method!on #on} method is shorthand for
{@link Ext.util.Observable#method!addListener addListener}.

Appends an event handler to this object.  For example:

    myGridPanel.on("itemclick", this.onItemClick, this);

The method also allows for a single argument to be passed which is a config object
containing properties which specify multiple events. For example:

    myGridPanel.on({
        cellclick: this.onCellClick,
        select: this.onSelect,
        viewready: this.onViewReady,
        scope: this // Important. Ensure "this" is correct during handler execution
    });

One can also specify options for each event handler separately:

    myGridPanel.on({
        cellclick: {fn: this.onCellClick, scope: this, single: true},
        viewready: {fn: panel.onViewReady, scope: panel}
    });

*Names* of methods in a specified scope may also be used:

    myGridPanel.on({
        cellclick: {fn: 'onCellClick', scope: this, single: true},
        viewready: {fn: 'onViewReady', scope: panel}
    });
">addListener</option>
    <option value="The addManagedListener method is used when some object (call it "A") is listening
to an event on another observable object ("B") and you want to remove that listener
from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
all of its listeners will be removed at that time.

Example:

    Ext.define('Foo', {
        extend: 'Ext.Component',

        initComponent: function () {
            this.addManagedListener(MyApp.SomeSharedMenu, 'show', this.doSomething);
            this.callParent();
        }
    });

As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.

As of version 5.1 it is no longer necessary to use this method in most cases because
listeners are automatically managed if the scope object provided to
{@link Ext.util.Observable#method!addListener addListener} is an Observable instance.
However, if the observable instance and scope are not the same object you
still need to use `{@link #method!mon mon}` or `{@link #method!addManagedListener addManagedListener}` if you want the listener to be
managed.
">addManagedListener</option>
    <option value="Adds a plugin. For example:

     list.addPlugin('pullrefresh');

Or:

     list.addPlugin({
         type: 'pullrefresh',
         pullRefreshText: 'Pull to refresh...'
     });
">addPlugin</option>
    <option value="Used to handle joining of a record to a tpl
">afterEdit</option>
    <option value="Used to handle joining of a record to a tpl
">afterErase</option>
    <option value="This method is called after the component is initially added to the DOM. If this
component {@link Ext.Container} other components, the `{@link #method!afterRender afterRender}` method
for child components is called *before* the parent's `{@link #method!afterRender afterRender}`.

Implementations of this method should avoid reading from the DOM but are free to
write to the DOM as needed. To read the DOM, consider implementing
{@link #method!onRender onRender} instead.

This method is not generally needed because components always have their own DOM
{@link #property!element} and these are maintained by config property
updaters prior to insertion in the DOM. In general, it is always best to manipulate
the component's elements outside the DOM where there is no associated reflow or
layout cost. This method is useful for situations where the component's elements
must be in the DOM in order to be manipulated correctly.
">afterRender</option>
    <option value="undefined">alignTo</option>
    <option value="undefined">applyBind</option>
    <option value="undefined">applyCentered</option>
    <option value="Sets the {@link #cfg!increment #increment} configuration.
">applyIncrement</option>
    <option value="Applier for the `{@link #cfg!plugins plugins}` config property.
">applyPlugins</option>
    <option value="Transforms a Session config to a proper instance.
">applySession</option>
    <option value="undefined">applyStyle</option>
    <option value="undefined">applyTpl</option>
    <option value="Transforms a ViewModel config to a proper instance.
">applyViewModel</option>
    <option value="undefined">beforeInitialize</option>
    <option value="undefined">blur</option>
    <option value="Bubbles up the {@link #method!getRefOwner} hierarchy, calling the specified function
with each component. The scope (`this` reference) of the function call will be the
scope provided or the current component. The arguments to the function will
be the args provided or the current component. If the function returns false at any
point, the bubble is stopped.
">bubble</option>
    <option value="Call the original method that was previously overridden with {@link Ext.Base#static-method!override Ext.Base#override}

    Ext.define('My.Cat', {
        constructor: function() {
            alert("I'm a cat!");
        }
    });

    My.Cat.override({
        constructor: function() {
            alert("I'm going to be a cat!");

            this.callOverridden();

            alert("Meeeeoooowwww");
        }
    });

    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
                              // alerts "I'm a cat!"
                              // alerts "Meeeeoooowwww"
">callOverridden</option>
    <option value="Call the "parent" method of the current method. That is the method previously
overridden by derivation or by an override (see {@link Ext#method!define Ext#define}).

     Ext.define('My.Base', {
         constructor: function(x) {
             this.x = x;
         },

         statics: {
             method: function(x) {
                 return x;
             }
         }
     });

     Ext.define('My.Derived', {
         extend: 'My.Base',

         constructor: function() {
             this.callParent([21]);
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // alerts 21

This can be used with an override as follows:

     Ext.define('My.DerivedOverride', {
         override: 'My.Derived',

         constructor: function(x) {
             this.callParent([x*2]); // calls original My.Derived constructor
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // now alerts 42

This also works with static and private methods.

     Ext.define('My.Derived2', {
         extend: 'My.Base',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Base.method
             }
         }
     });

     alert(My.Base.method(10));     // alerts 10
     alert(My.Derived2.method(10)); // alerts 20

Lastly, it also works with overridden static methods.

     Ext.define('My.Derived2Override', {
         override: 'My.Derived2',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Derived2.method
             }
         }
     });

     alert(My.Derived2.method(10); // now alerts 40

To override a method and replace it and also call the superclass method, use
{@link #method!callSuper #method-callSuper}. This is often done to patch a method to fix a bug.
">callParent</option>
    <option value="This method is used by an **override** to call the superclass method but
bypass any overridden method. This is often done to "patch" a method that
contains a bug but for whatever reason cannot be fixed directly.

Consider:

     Ext.define('Ext.some.Class', {
         method: function() {
             console.log('Good');
         }
     });

     Ext.define('Ext.some.DerivedClass', {
         extend: 'Ext.some.Class',

         method: function() {
             console.log('Bad');

             // ... logic but with a bug ...

             this.callParent();
         }
     });

To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
override:

     Ext.define('App.patches.DerivedClass', {
         override: 'Ext.some.DerivedClass',

         method: function() {
             console.log('Fixed');

             // ... logic but with bug fixed ...

             this.callSuper();
         }
     });

The patch method cannot use {@link #method!callParent #method-callParent} to call the superclass
`method` since that would call the overridden method containing the bug. In
other words, the above patch would only produce "Fixed" then "Good" in the
console log, whereas, using `callParent` would produce "Fixed" then "Bad"
then "Good".
">callSuper</option>
    <option value="Center this {@link #cfg!floated #cfg-floated} or {@link #isPositioned positioned} Component in its parent.
">center</option>
    <option value="Clears all listeners that were attached using the "delegate" event option.
Users should not invoke this method directly.  It is called automatically as
part of normal {@link Ext.util.Observable#method!clearListeners clearListeners}
processing.
">clearDelegatedListeners</option>
    <option value="Removes all listeners for this object including the managed listeners
">clearListeners</option>
    <option value="Removes all managed listeners for this object.
">clearManagedListeners</option>
    <option value="Takes a desired value of a thumb and returns the nearest snap value.
e.g if minValue = 0, maxValue = 100, increment = 10 and we pass a value of 67 here,
the returned value will be 70. The returned number is constrained
within {@link #cfg!minValue #minValue} and {@link #cfg!maxValue #maxValue}, so in the above example 68 would
be returned if {@link #cfg!maxValue #maxValue} was set to 68.
">constrainValue</option>
    <option value="Creates new Component.
">constructor</option>
    <option value="Converts the provided type or config object into a plugin instance.
">createPlugin</option>
    <option value="Creates an event handling function which re-fires the event from this object
as the passed event name.
">createRelayer</option>
    <option value="Destroys the Widget. This method should not be overridden in custom Widgets,
because it sets the flags and does final cleanup that must go last. Instead,
override {@link #method!doDestroy #doDestroy} method to add functionality at destruction time.
">destroy</option>
    <option value="Destroys member properties by name.

If a property name is the name of a *config*, the getter is *not* invoked, so
if the config has not been initialized, nothing will be done.

The property will be destroyed, and the corrected name (if the property is a *config*
and config names are prefixed) will set to `null` in this object's dictionary.
">destroyMembers</option>
    <option value="Removes and destroys a plugin.

**Note:** Not all plugins are designed to be removable. Consult the documentation
for the specific plugin in question to be sure.
">destroyPlugin</option>
    <option value="Disables this Component
">disable</option>
    <option value="undefined">doAddListener</option>
    <option value="Perform the actual destruction sequence. This is the method to override in your
subclasses to add steps specific to the destruction of custom Component.

If the Component is currently added to a Container it will first be removed
from that Container. All {@link Ext.dom.Element Ext.Element} references are also deleted and
the Component is de-registered from {@link Ext.ComponentManager}.

As a rule of thumb, subclasses should destroy their child Components, Elements,
and/or other objects before calling parent method. Any object references will be
nulled after this method has finished, to prevent the possibility of memory leaks.
">doDestroy</option>
    <option value="Fires a delegated event.  Users should not invoke this method directly.  It
is called automatically by the framework as needed (see the "delegate" event
option of {@link Ext.util.Observable#method!addListener addListener} for more
details.
">doFireDelegatedEvent</option>
    <option value="Continue to fire event.
">doFireEvent</option>
    <option value="undefined">doInheritUi</option>
    <option value="undefined">doUninheritUi</option>
    <option value="Enables this Component
">enable</option>
    <option value="Enables events fired by this Observable to bubble up an owner hierarchy by calling
`this.getBubbleTarget()` if present. There is no implementation in the Observable
base class.

This is commonly used by Ext.Components to bubble events to owner Containers.
See {@link Ext.Component#getBubbleTarget}. The default implementation in Ext.Component
returns the Component's immediate owner. But if a known target is required, this can be
overridden to access the required target more quickly.

Example:

    Ext.define('Ext.overrides.form.field.Base', {
        override: 'Ext.form.field.Base',

        //  Add functionality to Field's initComponent to enable
        // the change event to bubble
        initComponent: function () {
            this.callParent();
            this.enableBubble('change');
        }
    });

    var myForm = Ext.create('Ext.form.Panel', {
        title: 'User Details',
        items: [{
            ...
        }],
        listeners: {
            change: function() {
                // Title goes red if form has been modified.
                myForm.header.setStyle('color', 'red');
            }
        }
    });
">enableBubble</option>
    <option value="undefined">factoryThumb</option>
    <option value="The method finds this floated component's floatParent. That means a DOM positioning
container which acts as a root element for sibling floated components, and allows allows
floated components to be absolutely positioned, and their encapsulating elements to be
reordered to produce a visual stacking effect.

This component's element is appended to its floatParent.

There is a global floatParent element, created on demand when the first top level
floated component is shown. This may be an item child of a container configured with
`{@link #cfg!floated #cfg-floated}: true`, or a free `{@link #cfg!floated floated}` component which is programatically
{@link Ext.Component#show shown}.

Child items of components inside a floated component may also be configured `{@link #cfg!floated floated}`.
These are give a floatParent which is created on demand wrapping the nearest `{@link #cfg!floated floated}`
ancestor. This means that when that ancestor's element is brought to the top of the
stack (by moving its element to the end of its own floatParent), the descendant elements
will automatically remain above.
">findFloatParent</option>
    <option value="Finds an alternate Component to focus if this Component is disabled while focused, or
focused while disabled, or otherwise unable to focus.

In both cases, focus must not be lost to document.body, but must move to an intuitively
connectible Component, either a sibling, or uncle or nephew.

This is both for the convenience of keyboard users, and also for when focus is tracked
within a Component tree such as for ComboBoxes and their dropdowns.

For example, a ComboBox with a PagingToolbar in is BoundList. If the "Next Page"
button is hit, the LoadMask shows and focuses, the next page is the last page, so
the "Next Page" button is disabled. When the LoadMask hides, it attempt to focus the
last focused Component which is the disabled "Next Page" button. In this situation,
focus should move to a sibling within the PagingToolbar.
">findFocusTarget</option>
    <option value="Retrieves plugin by its `type` alias. For example:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

     list.findPlugin('pullrefresh').setPullRefreshText('Pull to refresh...');

**Note:** See also {@link #method!getPlugin #getPlugin}.
">findPlugin</option>
    <option value="Fires the specified event with the passed parameters and executes a function (action).
By default, the action function will be executed after any "before" event handlers
(as specified using the `order` option of
`{@link Ext.util.Observable#method!addListener addListener}`), but before any other
handlers are fired.  This gives the "before" handlers an opportunity to
cancel the event by returning `false`, and prevent the action function from
being called.

The action can also be configured to run after normal handlers, but before any "after"
handlers (as specified using the `order` event option) by passing `'after'`
as the `order` parameter.  This configuration gives any event handlers except
for "after" handlers the opportunity to cancel the event and prevent the action
function from being called.
">fireAction</option>
    <option value="Fires the specified event with the passed parameters (minus the event name, plus
the `options` object passed to {@link Ext.util.Observable#method!addListener addListener}).

An event may be set to bubble up an Observable parent hierarchy (See
{@link Ext.Component#getBubbleTarget}) by calling {@link #method!enableBubble #enableBubble}.
">fireEvent</option>
    <option value="Fires the specified event with the passed parameter list.

An event may be set to bubble up an Observable parent hierarchy
(See {@link Ext.Component#getBubbleTarget}) by calling {@link #method!enableBubble #enableBubble}.
">fireEventArgs</option>
    <option value="Fires the specified event with the passed parameters and executes a function (action).
Evented Actions will automatically dispatch a 'before' event passing. This event will
be given a special controller that allows for pausing/resuming of the event flow.

By pausing the controller the updater and events will not run until resumed. Pausing,
however, will not stop the processing of any other before events.
">fireEventedAction</option>
    <option value="Try to focus this component.

If this component is disabled or otherwise not focusable, a close relation
will be targeted for focus instead to keep focus localized for keyboard users.
">focus</option>
    <option value="Prepares information on aligning this to component using alignment.
Also checks to see if this is already aligned to component according to alignment.
">getAlignmentInfo</option>
    <option value="undefined">getAlignRegion</option>
    <option value="Find component(s) that label or describe this component,
and return the id(s) of their ariaEl elements.
">getAriaLabelEl</option>
    <option value="undefined">getArrayValues</option>
    <option value="Gets the bubbling parent for an Observable
">getBubbleParent</option>
    <option value="undefined">getClassCls</option>
    <option value="Returns a specified config property value. If the name parameter is not passed,
all current configuration options will be returned as key value pairs.
">getConfig</option>
    <option value="Returns the {@link Ext.app.ViewController} instance associated with this
component via the {@link #cfg!controller #controller} config or {@link #setController} method.
">getController</option>
    <option value="Current Alignment information from the last alignTo call
">getCurrentAlignmentInfo</option>
    <option value="undefined">getCurrentConfig</option>
    <option value="A template method for modifying the {@link #property!element #element} config before it is processed.
By default adds the result of `this.getTemplate()` as the `children` array of
{@link #property!element #element} if `children` were not specified in the original
{@link #property!element #element} config.  Typically this method should not need to be implemented
in subclasses.  Instead the {@link #property!element #element} property should be use to configure
the element template for a given Widget subclass.

This method is called once when the first instance of each Widget subclass is
created.  The element config object that is returned is cached and used as the template
for all successive instances.  The scope object for this method is the class prototype,
not the instance.
">getElementConfig</option>
    <option value="*For {@link #cfg!floated #cfg-floated} components only. *

Finds the owning {@link #cfg!floated #cfg-floated} component (if any) responsible for
the base z-index stack position of this compoonent, and, if that component
is {@link #cfg!relative #cfg-relative}, for the coordinate system in which this component
is positioned.

If this is a top level floated component, this method will return `null`
">getFloatParent</option>
    <option value="This method returns, or creates on demand the floatWrap element which wraps the passed
floated component. It enables that floated component to act as a host for descendant
floated components.
">getFloatWrap</option>
    <option value="Returns the element used to apply focus styling CSS class when Focusable's
{@link #property!focusEl #focusEl} becomes focused. By default it is {@link #property!focusEl #focusEl}.
">getFocusClsEl</option>
    <option value="Returns the main focus holder element associated with this Focusable, i.e.
the element that will be focused when Focusable's {@link #method!focus} method is
called. For most Focusables, this will be the {@link #property!focusEl #focusEl}.
">getFocusEl</option>
    <option value="Retrieves the `id`. This method Will auto-generate an id if one has not already
been configured.
">getId</option>
    <option value="This method returns an object containing the inherited properties for this instance.
">getInherited</option>
    <option value="This method returns the value of a config property that may be inherited from some
ancestor.

In some cases, a config may be explicitly set on a component with the intent of
*only* being presented to its children while that component should act upon the
inherited value (see `referenceHolder` for example). In these cases the `skipThis`
parameter should be specified as `true`.
">getInheritedConfig</option>
    <option value="Returns the initial configuration passed to the constructor when
instantiating this class.

Given this example Ext.button.Button definition and instance:

    Ext.define('MyApp.view.Button', {
        extend: 'Ext.button.Button',
        xtype: 'mybutton',

        scale: 'large',
        enableToggle: true
    });

    var btn = Ext.create({
        xtype: 'mybutton',
        renderTo: Ext.getBody(),
        text: 'Test Button'
    });

Calling `btn.getInitialConfig()` would return an object including the config
options passed to the `{@link #static-method!create create}` method:

    xtype: 'mybutton',
    renderTo: // The document body itself
    text: 'Test Button'

Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
">getInitialConfig</option>
    <option value="Returns the topmost modal floated component (other then this one).
">getModalSibling</option>
    <option value="Retrieves a plugin by its `id`.

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: [{
             type: 'pullrefresh',
             id: 'foo'
         }]
     });

     list.getPlugin('foo').setPullRefreshText('Pull to refresh...');

**Note:** See also {@link #method!findPlugin #findPlugin}.
">getPlugin</option>
    <option value="Used by {@link Ext.ComponentQuery}, and the {@link Ext.Component#method!up up}
method to find the owning Component in the linkage hierarchy.

By default this returns the Container which contains this Component.

This may be overridden by Component authors who implement ownership hierarchies
which are not based upon ownerCt, such as BoundLists being owned by Fields or Menus
being owned by Buttons.
">getRefOwner</option>
    <option value="Returns the element into which the html content and items should be rendered.
This defaults to the `bodyElement` but derived classes can override this method
to use a different element.

For containers his only applies to `inner` items, not `{@link #cfg!docked docked}` items. The
`{@link #property!positioned positioned}` items are rendered to the element returned by the
{@link Ext.Container#getPositionedItemTarget method.
">getRenderTarget</option>
    <option value="This method is required by the Scroller to return the scrollable client region
">getScrollableClientRegion</option>
    <option value="Returns the height and width of the Component.
">getSize</option>
    <option value="Creates a state builder to access or edit this instance's state object. If this
instance has a `{@link #method!getStatefulOwner}`, the returned
builder will have a `parent` reference that owner's state builder. This can be
an arbitrarily deep chain but does proceed all the way up to the root instance
(with no owner) since that is the instance that determines the ultimate state
storage key.
">getStateBuilder</option>
    <option value="This method allows a class to specify an owning stateful object. This is used by
{@link Ext.plugin.Abstract} to save their state as part of their owning
{@link Ext.Component}.

The return value can be either a `Stateful` object or an array whose first element is
a `Stateful` object. This object's state will be stored inside the state object of
the returned `Stateful` object. If an array is returned, the elements beyond the first
are sub-keys in the state object.

For example, {@link Ext.plugin.Abstract} implement this method like so:

     getStatefulOwner: function() {
         return [ this.cmp, 'plugins' ];
     }

The effect of this is to produce a state object like so:

     {
         plugins: {
             pluginId1: {
                 //...
             }
         }
     }

In order for a child object's state to be saved and restored, all of its parents must
also be stateful (i.e., have a `{@link #cfg!stateId stateId}`).
">getStatefulOwner</option>
    <option value="Return the actual tabIndex for this Focusable.
">getTabIndex</option>
    <option value="Returns the Thumb instance bound to this Slider
">getThumb</option>
    <option value="Returns the Thumb instances bound to this Slider
">getThumbs</option>
    <option value="Convenience method. Calls {@link #getValue}.
">getValues</option>
    <option value="Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
available xtypes, see the {@link Ext.Component} header.

__Note:__ If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.

Example usage:

    var t = new Ext.field.Text();
    alert(t.getXTypes());  // alerts 'component/field/textfield'
">getXTypes</option>
    <option value="undefined">handleBlurEvent</option>
    <option value="undefined">handleFocusEvent</option>
    <option value="Checks if the specified CSS class exists on this element's DOM node.
">hasCls</option>
    <option value="undefined">hasConfig</option>
    <option value="Checks to see if this object has any listeners for a specified event, or whether
the event bubbles. The answer indicates whether the event needs firing or not.
">hasListener</option>
    <option value="Hides this Component optionally using an animation.
">hide</option>
    <option value="This method triggers the lazy configs and must be called when it is time to
fully boot up. The configs that must be initialized are: `{@link #cfg!bind bind}`, `{@link #cfg!publishes publishes}`,
`{@link #cfg!session session}`, `{@link #cfg!twoWayBindable twoWayBindable}` and `{@link #cfg!viewModel viewModel}`.
">initBindable</option>
    <option value="Initialize configuration for this class. a typical example:

    Ext.define('My.awesome.Class', {
        // The default config
        config: {
            name: 'Awesome',
            isAwesome: true
        },

        constructor: function(config) {
            this.initConfig(config);
        }
    });

    var awesome = new My.awesome.Class({
        name: 'Super Awesome'
    });

    alert(awesome.getName()); // 'Super Awesome'
">initConfig</option>
    <option value="This method is called when a drag is initializing. This method should adjust the
drag constraints to ensure all drag movements are properly restricted. See
{@link Ext.drag.Source#cfg!constrain Ext.drag.Source#constrain}.
">initDragConstraints</option>
    <option value="Initializes the Element for this Widget instance.  If this is the first time a
Widget of this type has been instantiated the {@link #property!element #element} config will be
processed to create an Element.  This Element is then cached on the prototype (see
afterCachedConfig) so that future instances can obtain their element by simply
cloning the Element that was cached by the first instance.
">initElement</option>
    <option value="Called for the first instance of this Widget to create an object that contains the
listener configs for all of the element references keyed by reference name. The
object is cached on the prototype and has the following shape:

    _elementListeners: {
        element: {
            click: 'onClick',
            scope: this
        },
        fooReference: {
            tap: {
                fn: someFunction,
                delay: 100
            }
        }
    }

The returned object is prototype chained to the _elementListeners object of its
superclass, and each key in the object is prototype chained to object with the
corresponding key in the superclass _elementListeners.  This allows element
listeners to be inherited and overridden when subclassing widgets.

This method is invoked with the prototype object as the scope
">initElementListeners</option>
    <option value="Sets up the focus listener on this Component's {@link #method!getFocusEl focusEl} if it has one.

Form Components which must implicitly participate in tabbing order usually have
a naturally focusable element as their {@link #method!getFocusEl focusEl}, and it is
the DOM event of that receiving focus which drives the Component's `{@link #method!onFocus onFocus}` handling,
and the DOM event of it being blurred which drives the `{@link #method!onBlur onBlur}` handling.
">initFocusableElement</option>
    <option value="Template method to do any event listener initialization for a Focusable.
This generally happens after the focusEl is available.
">initFocusableEvents</option>
    <option value="undefined">initialize</option>
    <option value="Called by `{@link #method!getInherited getInherited}` to initialize the inheritedState the first time it is requested.
">initInheritedState</option>
    <option value="This method should be called when the instance is ready to start listening for
keyboard events. This is called automatically for `{@link Ext.Component}` and derived
classes. This is done after the component is rendered.
">initKeyMap</option>
    <option value="Initializes a "uiReference".  Ui rerefences are reference elements that have
classCls and ui info in their CSS class names.  They can be used by setting
uiCls in the template, or by invoking this method to setup the ui reference
after element/template initialization (Toolable uses this for its dock wrapper)
">initUiReference</option>
    <option value="This method inserts this floated component's DOM into its owning floatParent.
">insertFloatedDom</option>
    <option value="This method marks the current inherited state as invalid. The next time a call is
made to `{@link #method!getInherited getInherited}` the objects will be recreated and initialized.
">invalidateInheritedState</option>
    <option value="Tests whether this Widget matches a {@link Ext.ComponentQuery}
selector string.
">is</option>
    <option value="Determines whether **this Component** is an ancestor of the passed Component.
This will return `true` if the passed Component is anywhere within the subtree
beneath this Component.
">isAncestor</option>
    <option value="undefined">isBlurring</option>
    <option value="Determines if the passed property name is bound to ViewModel data.
">isBound</option>
    <option value="undefined">isCentered</option>
    <option value="Determines whether this component is the descendant of a passed component.
">isDescendantOf</option>
    <option value="Determines if this Component is inside a Component tree which is destroyed, *or
is being destroyed*.
">isDestructing</option>
    <option value="Returns `true` if this Component is currently disabled.
">isDisabled</option>
    <option value="Returns `true` if this Component is not currently disabled.
">isEnabled</option>
    <option value="Determine if this Focusable can receive focus at this time.

Note that Containers can be non-focusable themselves while delegating
focus treatment to a child Component; see {@link Ext.Container}
for more information.
">isFocusable</option>
    <option value="undefined">isFocusing</option>
    <option value="undefined">isHeighted</option>
    <option value="Returns `true` if this Component is currently hidden.
">isHidden</option>
    <option value="undefined">isPainted</option>
    <option value="undefined">isRendered</option>
    <option value="Checks if all events, or a specific event, is suspended.
">isSuspended</option>
    <option value="Checks if a particular binding is synchronizing the value.
">isSyncing</option>
    <option value="Returns `true` if this Component is currently visible.

A Widget is visible if its element is not hidden, *and* has been
{@link #property!rendered} *and* has not been destroyed.
">isVisible</option>
    <option value="undefined">isWidthed</option>
    <option value="Tests whether or not this Component is of a specific xtype. This can test whether this
Component is descended from the xtype (default) or whether it is directly of the xtype
specified (`shallow = true`).
**If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.__

For a list of all available xtypes, see the {@link Ext.Component} header.

Example usage:

    var t = new Ext.field.Text();
    var isText = t.isXType('textfield'); // true
    var isBoxSubclass = t.isXType('field'); // true, descended from Ext.field.Field
    var isBoxInstance = t.isXType('field', true); // false, not a direct
                                                  // Ext.field.Field instance
">isXType</option>
    <option value="Adds a "destroyable" object to an internal list of objects that will be destroyed
when this instance is destroyed (via `{@link #method!destroy}`).
">link</option>
    <option value="This method is called to load state from the provided `state` builder. This method
should return the config properties loaded from `state`.

This method, like `{@link #method!saveState saveState}`, can be overridden by derived classes:

     loadState: function(state) {
         var ret = this.callParent([ state ]);

         if (ret.foo) {
             // use custom data...

             delete ret.foo;  // remove it since it isn't a config
         }

         return ret;
     }

When overriding this method, it is also likely necessary to override `{@link #method!saveState saveState}`.
">loadState</option>
    <option value="Gets the controller that controls this view. May be a controller that belongs
to a view higher in the hierarchy.
">lookupController</option>
    <option value="Gets the Form or Component that is used as the name holder for this component.
">lookupNameHolder</option>
    <option value="Gets the Controller or Component that is used as the reference holder for this view.
">lookupReferenceHolder</option>
    <option value="Returns the `{@link Ext.data.Session}` for this instance. This property may come
from this instance's `{@link #cfg!session #session}` or be inherited from this object's parent.
">lookupSession</option>
    <option value="Gets a named template instance for this class. See {@link Ext.XTemplate#static-method!getTpl Ext.XTemplate#getTpl}.
">lookupTpl</option>
    <option value="Returns the `{@link Ext.app.ViewModel}` for this instance. This property may come from this
this instance's `{@link #cfg!viewModel #viewModel}` or be inherited from this object's parent.
">lookupViewModel</option>
    <option value="Shorthand for {@link #method!addManagedListener #addManagedListener}.
The addManagedListener method is used when some object (call it "A") is listening
to an event on another observable object ("B") and you want to remove that listener
from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
all of its listeners will be removed at that time.

Example:

    Ext.define('Foo', {
        extend: 'Ext.Component',

        initComponent: function () {
            this.addManagedListener(MyApp.SomeSharedMenu, 'show', this.doSomething);
            this.callParent();
        }
    });

As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.

As of version 5.1 it is no longer necessary to use this method in most cases because
listeners are automatically managed if the scope object provided to
{@link Ext.util.Observable#method!addListener addListener} is an Observable instance.
However, if the observable instance and scope are not the same object you
still need to use `{@link #method!mon mon}` or `{@link #method!addManagedListener addManagedListener}` if you want the listener to be
managed.
">mon</option>
    <option value="Shorthand for {@link #method!removeManagedListener #removeManagedListener}.
Removes listeners that were added by the {@link #method!mon #mon} method.
">mun</option>
    <option value="The {@link #method!on #on} method is shorthand for
{@link Ext.util.Observable#method!addListener addListener}.

Appends an event handler to this object.  For example:

    myGridPanel.on("itemclick", this.onItemClick, this);

The method also allows for a single argument to be passed which is a config object
containing properties which specify multiple events. For example:

    myGridPanel.on({
        cellclick: this.onCellClick,
        select: this.onSelect,
        viewready: this.onViewReady,
        scope: this // Important. Ensure "this" is correct during handler execution
    });

One can also specify options for each event handler separately:

    myGridPanel.on({
        cellclick: {fn: this.onCellClick, scope: this, single: true},
        viewready: {fn: panel.onViewReady, scope: panel}
    });

*Names* of methods in a specified scope may also be used:

    myGridPanel.on({
        cellclick: {fn: 'onCellClick', scope: this, single: true},
        viewready: {fn: 'onViewReady', scope: panel}
    });
">on</option>
    <option value="undefined">onAdded</option>
    <option value="Appends an after-event handler.

Same as {@link Ext.util.Observable#method!addListener addListener} with `order` set
to `'after'`.
">onAfter</option>
    <option value="Appends a before-event handler.  Returning `false` from the handler will stop the event.

Same as {@link Ext.util.Observable#method!addListener addListener} with `order` set
to `'before'`.
">onBefore</option>
    <option value="undefined">onBlur</option>
    <option value="undefined">onFocus</option>
    <option value="Called when focus enters this Component's hierarchy
">onFocusEnter</option>
    <option value="Called when focus exits from this Component's hierarchy
">onFocusLeave</option>
    <option value="Called when focus moves *within* this Component's hierarchy
">onFocusMove</option>
    <option value="Called when this Inheritable is added to a parent
">onInheritedAdd</option>
    <option value="Called when this inheritable is removed from a parent
">onInheritedRemove</option>
    <option value="undefined">onInitialized</option>
    <option value="This method is called the first time a component is inserted into the DOM. If this
component {@link Ext.Container} other components, the `{@link #method!onRender onRender}` method
for child components is called *after* the parent's `{@link #method!onRender onRender}`.

Implementations of this method should avoid modifying the DOM but are free to read
from and measure elements as needed. To adjust the DOM, consider implementing
{@link #method!afterRender afterRender} instead.

If this method is overridden, be sure to use `callParent` to call the base class
version.

     onRender: function() {
         this.callParent();

         // custom actions
     }

This method is not generally needed because components always have their own DOM
{@link #property!element} and these are maintained by config property
updaters prior to insertion in the DOM. In general, it is always best to interrogate
the component's elements outside the DOM where there is no associated reflow or
layout cost. This method is useful for situations where the component's elements
must be in the DOM. For example to be measured correctly.
">onRender</option>
    <option value="Optional template method. If implemented, this is called *asynchronously* after a browser
layout caused by a component resize. This may be triggered for any or several of the
following reasons:
   - Programmatic changes to {@link #cfg!width #cfg-width} or {@link #cfg!height #cfg-height} configs.
   - Setting the {@link #cfg!flex #cfg-flex} config when the owning layout is {@link Ext.layout.Box}.
   - Setting {@link #cfg!minHeight #cfg-minHeight}, {@link #cfg!maxHeight #cfg-maxHeight}, {@link #cfg!minWidth #cfg-minWidth}
     or {@link #cfg!maxWidth #cfg-maxWidth}.
   - Changing device orientation.
   - Changing the browser viewport size.
   - Any resize caused by browser layout recalculation which may be caused by content
     size changes or application of default browser layout rules.
">onResize</option>
    <option value="Invoked when a scroll operation is completed via this component's
{@link #cfg!scrollable scroller}.
">onScrollEnd</option>
    <option value="Invoked when this component is scrolled via its {@link #cfg!scrollable scroller}.
">onScrollMove</option>
    <option value="Invoked when a scroll is initiated on this component via its {@link #cfg!scrollable scroller}.
">onScrollStart</option>
    <option value="This method is called when any of the `{@link #cfg!stateful stateful}` configs are modified.
">onStatefulChange</option>
    <option value="undefined">onTap</option>
    <option value="Returns `true` if the passed element is within the container tree of this component.

For example if a menu's submenu contains an {@link Ext.form.field.Date}, that top level
menu owns the elements of the date picker. Using this method, you can tell if an event
took place within a certain component tree.
">owns</option>
    <option value="Saves the state of this instance to the persistence store. This method is called
by the {@link Ext.state.Provider} when it is ready to save state
to storage.
">persistState</option>
    <option value="This is the private method to ensure everything is set up for showing.
This is called by both show and showBy to set a component up.
the user-facing method is beforeShow, this setup must have
happened by the time that is called.
">preprocessShow</option>
    <option value="Recursively processes the element templates for this class and its superclasses,
ascending the hierarchy until it reaches a superclass whose element template
has already been processed.  This method is invoked using the prototype as the scope.
">processElementConfig</option>
    <option value="Publish this components state to the `ViewModel`. If no arguments are given (or if
this is the first call), the entire state is published. This state is determined by
the `{@link #cfg!publishes publishes}` property.

This method is called only by component authors.
">publishState</option>
    <option value="Returns this instance's state object from the persistence store. This object
should contain config properties.
">readStateObject</option>
    <option value="undefined">realign</option>
    <option value="This method is called by the `thumb` before a drag gets going. We are still
allowed to adjust the constraints at this point so we fix them all up.
">refreshAllThumbConstraints</option>
    <option value="undefined">refreshValue</option>
    <option value="Relays selected events from the specified Observable as if the events were fired
by `this`.

For example if you are extending Grid, you might decide to forward some events from
store. So you can do this inside your initComponent:

    this.relayEvents(this.getStore(), ['load']);

The grid instance will then have an observable 'load' event which will be passed
the parameters of the store's load event and any function fired with the grid's
load event would have access to the grid using the this keyword (unless the event
is handled by a controller's control/listen event listener in which case 'this'
will be the controller rather than the grid).
">relayEvents</option>
    <option value="Alias for {@link #method!unAfter #unAfter}.
">removeAfterListener</option>
    <option value="Alias for {@link #method!unBefore #unBefore}.
">removeBeforeListener</option>
    <option value="Removes the given CSS class(es) from this widget's primary element.
">removeCls</option>
    <option value="Removes delegated listeners for a given eventName, function, and scope.
Users should not invoke this method directly.  It is called automatically by
the framework as part of {@link #method!removeListener #removeListener} processing.
">removeDelegatedListener</option>
    <option value="Removes an event handler.
">removeListener</option>
    <option value="Removes listeners that were added by the {@link #method!mon #mon} method.
">removeManagedListener</option>
    <option value="Remove a single managed listener item
">removeManagedListenerItem</option>
    <option value="Removes and (optionally) destroys a plugin.

**Note:** Not all plugins are designed to be removable. Consult the documentation
for the specific plugin in question to be sure.
">removePlugin</option>
    <option value="Replaces specified classes with the newly specified classes.
It uses the {@link #method!addCls #addCls} and {@link #method!removeCls #removeCls} methods, so if the class(es) you
are removing don't exist, it will still add the new classes.
">replaceCls</option>
    <option value="Resets {@link #cfg!top #top}, {@link #cfg!right #right}, {@link #cfg!bottom #bottom} and {@link #cfg!left #left} configurations to
`null`, which will cause this component to stop being 'positioned' and to take its place in
its owning container's layout.
">resetFloating</option>
    <option value="Resets {@link #cfg!top #top}, {@link #cfg!right #right}, {@link #cfg!bottom #bottom} and {@link #cfg!left #left} configurations to
`null`, which will cause this component to stop being 'positioned' and to take its place in
its owning container's layout.
">resetPositioned</option>
    <option value="Gets the default scope for firing late bound events (string names with
no scope attached) at runtime.
">resolveListenerScope</option>
    <option value="Returns the default listener scope for a "satellite" of this component.
Used for resolving scope for observable objects that are not part of the normal
Container/Component hierarchy (for example, plugins)
">resolveSatelliteListenerScope</option>
    <option value="Resumes firing of the named event(s).

After calling this method to resume events, the events will fire when requested to fire.

**Note that if the {@link #method!suspendEvent #suspendEvent} method is called multiple times for a certain
event, this converse method will have to be called the same number of times for it
to resume firing.**
">resumeEvent</option>
    <option value="Resumes firing events (see {@link #method!suspendEvents #suspendEvents}).

If events were suspended using the `queueSuspended` parameter, then all events fired
during event suspension will be sent to any listeners now.
">resumeEvents</option>
    <option value="Returns focus to the Component or element found in the cached
focusEnterEvent.
">revertFocus</option>
    <option value="This field is on the recieving end of a call from {@link #method!revertFocus}.

It is called when focus is being pushed back into this Component from a Component
that is focused and is being hidden or disabled.

We must focus the passed element.

Subclasses may perform some extra processing to prepare for refocusing.
">revertFocusTo</option>
    <option value="Saves the current state of this object to the provided `state` builder. By default
this method saves the configs specified as `{@link #cfg!stateful stateful}`.

This method can also be overridden by subclasses to store custom data directly to
the `state` builder:

     saveState: function(state) {
         this.callParent([ state ]);

         state.set('foo', 42);
     }

When overriding this method, it is also likely necessary to override `{@link #method!loadState loadState}`.
">saveState</option>
    <option value="Sets a single/multiple configuration options.
">setConfig</option>
    <option value="Sets the current Alignment information, called by alignTo
">setCurrentAlignmentInfo</option>
    <option value="An alias for {@link Ext.util.Observable#method!addListener addListener}.  In
versions prior to 5.1, {@link #cfg!listeners #listeners} had a generated setter which could
be called to add listeners.  In 5.1 the listeners config is not processed
using the config system and has no generated setter, so this method is
provided for backward compatibility.  The preferred way of adding listeners
is to use the {@link #method!on #on} method.
">setListeners</option>
    <option value="All Components need a potentially recursive setRendered because some are
pseudo containers, such as grid {@link Ext.grid.Row}, and some mix in
{@link Ext.mixin.Toolable}.
">setRendered</option>
    <option value="Sets the size of the Component.
">setSize</option>
    <option value="Set the tabIndex property for this Focusable. If the focusEl
is available, set tabIndex attribute on it, too.
">setTabIndex</option>
    <option value="Convenience method. Calls {@link #setValue}.
">setValues</option>
    <option value="undefined">setVisibility</option>
    <option value="This method has the same arguments as {@link Ext.dom.Element#method!setXY element's setXY}
method, but is used to maintain the `{@link #cfg!x x}` and `{@link #cfg!y y}` configs (for `{@link #cfg!floated floated}` components)
or the `{@link #cfg!left left}` and `{@link #cfg!top top}` config for positioned components.
">setXY</option>
    <option value="Shows this component optionally using an animation.
">show</option>
    <option value="Displays component at specific xy position.
A floating component (like a menu) is positioned relative to its ownerCt if any.
Useful for popping up a context menu:

    listeners: {
        itemcontextmenu: function(view, record, item, index, event, options) {
            Ext.create('Ext.menu.Menu', {
                width: 100,
                height: 100,
                margin: '0 0 10 0',
                items: [{
                    text: 'regular item 1'
                },{
                    text: 'regular item 2'
                },{
                    text: 'regular item 3'
                }]
            }).showAt(event.getXY());
        }
    }
">showAt</option>
    <option value="Shows this component by another component. If you specify no alignment, it will automatically
position this component relative to the reference component depending upon the `alignment`
parameter.

The `alignment` parameter describes the edge-to-edge alignment of *this* component
with the target. It can be specified thus:

- **Blank**: Defaults to positioning where the component will fit trying `'l-r?'`,
`'r-l?'`, `'b-t?'` then `'t-b?'` in that order.
- **Two anchors**: If two values from the table below are passed separated by a dash,
  the first value is used as the element's anchor point, and the second value is
  used as the target's anchor point.
- **Two edge/offset descriptors:** An edge/offset descriptor is an edge initial
  (`t`/`r`/`b`/`l`) followed by a percentage along that side. This describes a
  point to align with a similar point in the target. So `'t0-b0'` would be
  the same as `'tl-bl'`, `'l0-r50'` would place the top left corner of this item
  halfway down the right edge of the target item. This allows more flexibility
  and also describes which two edges are considered adjacent when positioning a tip pointer.

Following are all of the supported predefined anchor positions:

     Value  Description
     -----  -----------------------------
     tl     The top left corner
     t      The center of the top edge
     tr     The top right corner
     l      The center of the left edge
     c      The center
     r      The center of the right edge
     bl     The bottom left corner
     b      The center of the bottom edge
     br     The bottom right corner

You can put a '?' at the end of the alignment string to constrain the positioned element to
the {@link Ext.Viewport}. The element will attempt to align as specified, but the
position will be adjusted to constrain to the viewport if necessary. Note that the element
being aligned might be swapped to align to a different position than that specified in order
to enforce the viewport constraints.

Example Usage:

    // show `panel` by `button` using the default positioning (auto fit)
    panel.showBy(button);

    // align the top left corner of `panel` with the top right corner of `button`
    // (constrained to viewport)
    panel.showBy(button, "tl-tr?");

    // align the bottom right corner of `panel` with the center left edge of `button`
    // (not constrained by viewport)
    panel.showBy(button, "br-cl");

    // align the center of panel with the bottom left corner of button and
    // adjust the x position by -6 pixels (and the y position by 0)
    panel.showBy(button, "c-bl", [-6, 0]);

    // align the 25% point on the bottom edge of this panel
    // with the 75% point on the top edge of button.
    panel.showBy(button, 'b25-t75');
">showBy</option>
    <option value="Get the reference to the class from which this object was instantiated. Note that unlike
{@link Ext.Base#property!self Ext.Base#self}, `this.statics()` is scope-independent and it always returns
the class from which it was called, regardless of what `this` points to during run-time

    Ext.define('My.Cat', {
        statics: {
            totalCreated: 0,
            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        },

        constructor: function() {
            var statics = this.statics();

            // always equals to 'Cat' no matter what 'this' refers to
            // equivalent to: My.Cat.speciesName
            alert(statics.speciesName);


            alert(this.self.speciesName);   // dependent on 'this'

            statics.totalCreated++;
        },

        clone: function() {
            var cloned = new this.self();   // dependent on 'this'

            // equivalent to: My.Cat.speciesName
            cloned.groupName = this.statics().speciesName;

            return cloned;
        }
    });


    Ext.define('My.SnowLeopard', {
        extend: 'My.Cat',

        statics: {
            speciesName: 'Snow Leopard' // My.SnowLeopard.speciesName = 'Snow Leopard'
        },

        constructor: function() {
            this.callParent();
        }
    });

    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'

    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'

    var clone = snowLeopard.clone();
    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
    alert(clone.groupName);                 // alerts 'Cat'

    alert(My.Cat.totalCreated);             // alerts 3
">statics</option>
    <option value="Suspends firing of the named event(s).

After calling this method to suspend events, the events will no longer fire when
requested to fire.

**Note that if this is called multiple times for a certain event, the converse method
{@link #method!resumeEvent #resumeEvent} will have to be called the same number of times for it to resume
firing.**
">suspendEvent</option>
    <option value="Suspends the firing of all events. (see {@link #method!resumeEvents #resumeEvents})
">suspendEvents</option>
    <option value="Fixes up the alwaysOnTop order of this floated widget within its siblings.
">syncAlwaysOnTop</option>
    <option value="Synchronizes the size and position of the {@link #method!getFloatWrap floatWrap}
when this Widget is resized
">syncFloatWrap</option>
    <option value="Brings a {@link #cfg!floated #cfg-floated} Component to the front of any other visible, floated
Components while honoring all {@link #cfg!alwaysOnTop} settings. This may not become
topmost if another visible floated component has a higher {@link #cfg!alwaysOnTop} value.

If this Component becomes the topmost *modal* floated component, the the shared modal
mask is moved to just below this Component.
">toFront</option>
    <option value="Toggles the specified CSS class on this element (removes it if it already exists,
otherwise adds it).
">toggleCls</option>
    <option value="This method is called internally by `{@link #method!initConfig initConfig}` to apply whatever changes are
needed from persistent storage.
">transformStatefulConfig</option>
    <option value="undefined">triggerInitialized</option>
    <option value="Shorthand for {@link #method!removeListener #removeListener}.
Removes an event handler.
">un</option>
    <option value="Removes a before-event handler.

Same as {@link #method!removeListener #removeListener} with `order` set to `'after'`.
">unAfter</option>
    <option value="Removes a before-event handler.

Same as {@link #method!removeListener #removeListener} with `order` set to `'before'`.
">unBefore</option>
    <option value="Destroys a given set of `{@link #method!link linked}` objects. This is only needed if
the linked object is being destroyed before this instance.
">unlink</option>
    <option value="Walks up the ownership hierarchy looking for an ancestor Component which matches
the passed simple selector.

Example:

    var owningTabPanel = grid.up('tabpanel');
">up</option>
    <option value="undefined">updateAllowThumbsOverlapping</option>
    <option value="All cls methods directly report to the {@link #cfg!cls #cls} configuration, so anytime it changes,
{@link #method!updateCls #updateCls} will be called
">updateCls</option>
    <option value="undefined">updateData</option>
    <option value="undefined">updateHeight</option>
    <option value="undefined">updateIncrement</option>
    <option value="undefined">updateMaxValue</option>
    <option value="undefined">updateMinValue</option>
    <option value="Updates the session config.
">updateSession</option>
    <option value="undefined">updateThumbs</option>
    <option value="Updates the sliders thumbs with their new value(s)
">updateValue</option>
    <option value="Updates the viewModel config.
">updateViewModel</option>
    <option value="undefined">updateWidth</option>
    <option value="Watches config properties.

     instance.watchConfig({
         title: 'onTitleChange',
         scope: me
     });
">watchConfig</option>
    <option value="Queue a function to run when the component is visible & painted. If those conditions
are met, the function will execute  immediately, otherwise it will wait until it is
visible and painted.
">whenVisible</option>
</select></div>
</div>
  <div id="method" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="events">
<div class="flex-container">
  <div id="eventlist" class="thelist"><div>events:</div><div class="select-div"><select id="events" onchange="changeEvent()" name="events">
    <option value="Fires after a Component had been added to a Container.
">added</option>
    <option value="This event fires when `{@link #cfg!bottom}` changes.">beforebottomchange</option>
    <option value="This event fires when `{@link #cfg!centered}` changes.">beforecenteredchange</option>
    <option value="This event fires when `{@link #cfg!disabled}` changes.">beforedisabledchange</option>
    <option value="This event fires when `{@link #cfg!docked}` changes.">beforedockedchange</option>
    <option value="This event fires when `{@link #cfg!height}` changes.">beforeheightchange</option>
    <option value="This event fires when `{@link #cfg!hidden}` changes.">beforehiddenchange</option>
    <option value="Fires before the Component is hidden. Hide may be vetoed by returning `false` from a handler.
">beforehide</option>
    <option value="This event fires when `{@link #cfg!left}` changes.">beforeleftchange</option>
    <option value="This event fires when `{@link #cfg!maxHeight}` changes.">beforemaxHeightchange</option>
    <option value="This event fires when `{@link #cfg!maxWidth}` changes.">beforemaxWidthchange</option>
    <option value="This event fires when `{@link #cfg!minHeight}` changes.">beforeminHeightchange</option>
    <option value="This event fires when `{@link #cfg!minWidth}` changes.">beforeminWidthchange</option>
    <option value="Fires before orientation changes.
">beforeorientationchange</option>
    <option value="This event fires when `{@link #cfg!right}` changes.">beforerightchange</option>
    <option value="This event fires when `{@link #cfg!scrollable}` changes.">beforescrollablechange</option>
    <option value="Fires before the Component is shown. Show may be vetoed by returning `false` from a handler.
">beforeshow</option>
    <option value="Fires before a {@link #cfg!floated #cfg-floated} component is brought to the front of the visual stack.
">beforetofront</option>
    <option value="This event fires when `{@link #cfg!top}` changes.">beforetopchange</option>
    <option value="This event fires when `{@link #cfg!width}` changes.">beforewidthchange</option>
    <option value="Fires when this Component's {@link #property!focusEl #focusEl} loses focus.
">blur</option>
    <option value="This event fires when `{@link #cfg!bottom}` changes.">bottomchange</option>
    <option value="This event fires when `{@link #cfg!centered}` changes.">centeredchange</option>
    <option value="Fires when the value changes
">change</option>
    <option value="Fires when the component is destroyed
">destroy</option>
    <option value="This event fires when `{@link #cfg!disabled}` changes.">disabledchange</option>
    <option value="This event fires when `{@link #cfg!docked}` changes.">dockedchange</option>
    <option value="Fires when the slider thumb starts a drag
">drag</option>
    <option value="Fires when the slider thumb starts a drag
">dragend</option>
    <option value="Fires when the slider thumb starts a drag
">dragstart</option>
    <option value="Fires when the component is no longer displayed in the DOM.  Listening to this event will
degrade performance not recommend for general use.
">erased</option>
    <option value="Fires whenever there is a change in the positioned status of a component
">floatingchange</option>
    <option value="Fires when this Component's {@link #property!focusEl #focusEl} receives focus.
">focus</option>
    <option value="Fires when focus enters this Component's hierarchy.
">focusenter</option>
    <option value="Fires when focus leaves this Component's hierarchy.
">focusleave</option>
    <option value="Fires whenever a Component with the fullscreen config is instantiated
">fullscreen</option>
    <option value="This event fires when `{@link #cfg!height}` changes.">heightchange</option>
    <option value="This event fires when `{@link #cfg!hidden}` changes.">hiddenchange</option>
    <option value="Fires whenever the Component is hidden
">hide</option>
    <option value="Fires when the component has been initialized
">initialize</option>
    <option value="This event fires when `{@link #cfg!left}` changes.">leftchange</option>
    <option value="This event fires when `{@link #cfg!maxHeight}` changes.">maxHeightchange</option>
    <option value="This event fires when `{@link #cfg!maxWidth}` changes.">maxWidthchange</option>
    <option value="This event fires when `{@link #cfg!minHeight}` changes.">minHeightchange</option>
    <option value="This event fires when `{@link #cfg!minWidth}` changes.">minWidthchange</option>
    <option value="Fires when a component si moved within its Container.
">moved</option>
    <option value="Fires when orientation changes.
">orientationchange</option>
    <option value="Fires whenever this Element actually becomes visible (painted) on the screen. This is
useful when you need to perform 'read' operations on the DOM element, i.e: calculating
natural sizes and positioning.

__Note:__ This event is not available to be used with event delegation. Instead `{@link #event!painted painted}`
only fires if you explicitly add at least one listener to it, for performance reasons.
">painted</option>
    <option value="Fires whenever there is a change in the positioned status of a component
">positionedchange</option>
    <option value="Fires when a component is removed from a Container
">removed</option>
    <option value="Important note: For the best performance on mobile devices, use this only when you
absolutely need to monitor a Element's size.

__Note:__ This event is not available to be used with event delegation. Instead `{@link #event!resize resize}`
only fires if you explicitly add at least one listener to it, for performance reasons.
">resize</option>
    <option value="This event fires when `{@link #cfg!right}` changes.">rightchange</option>
    <option value="This event fires when `{@link #cfg!scrollable}` changes.">scrollablechange</option>
    <option value="Fires whenever the Component is shown
">show</option>
    <option value="Fires when a {@link #cfg!floated #cfg-floated} component has been brought to the front of the visual
stack.
">tofront</option>
    <option value="This event fires when `{@link #cfg!top}` changes.">topchange</option>
    <option value="Fires whenever the data of the component is updated
">updatedata</option>
    <option value="This event fires when `{@link #cfg!width}` changes.">widthchange</option>
</select></div>
</div>
  <div id="event" class="thetext"></div>
</div>
        </z-tabpanel>
    </z-tabs>
</div>

<p>
------------------
<pre>The slider component utilized by `{@link Ext.field.Slider}`.

The slider is a way to allow the user to select a value from a given numerical range.
You might use it for choosing a percentage, combine two of them to get min and max
values, or use three of them to specify the hex values for a color.

Each slider contains a single 'thumb' that can be dragged along the slider's length to
change the value.

## Simple Slider

    @example
    Ext.create({
        xtype: 'container',
        fullscreen: true,
        padding: 20,

        items: [{
            xtype: 'slider',
            value: 42
        }]
    });

## Slider with Bound Value

This slider does not incorporate two-way binding by default.  Please utilize `{@link #cfg!publishes publishes}` or
`{@link #cfg!twoWayBindable twoWayBindable}` in order to publish bound values.  You can also use Ext.field.Slider
directly for a more feature-rich component.

    @example
    Ext.create({
        xtype: 'container',
        fullscreen: true,
        padding: 20,

        layout: {
            type: 'hbox',
            pack: 'center'
        },

        viewModel: {
            data: {
                value: 42
            }
        },

        items: [{
            xtype: 'slider',
            value: '{value}'
        }, {
            xtype: 'label',
            bind: '{value}'
        }]
    })
</pre>

<span><b>Ext JS name:</b></span>
<br>
<span>Ext.slider.Slider</span>
<br><br>
<span><b>others:</b></span>
extend: 
extenders: Ext.slider.Toggle
mixed: Ext.Mixin,Ext.mixin.Accessible,Ext.mixin.Bindable,Ext.mixin.ComponentDelegation,Ext.mixin.Factoryable,Ext.mixin.Focusable,Ext.mixin.Identifiable,Ext.mixin.Inheritable,Ext.mixin.Keyboard,Ext.mixin.Observable,Ext.mixin.Pluggable,Ext.state.Stateful
mixins: 
requires: Ext.slider.Thumb,Ext.fx.easing.EaseOut
src: [object Object]



</div>

</body>
</html>