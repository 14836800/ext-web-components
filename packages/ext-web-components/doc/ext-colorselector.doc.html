<!DOCTYPE HTML>
<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="z-tabs.js"></script>

<script>
function changeProperty() {
  var x = document.getElementById("properties").value;
  document.getElementById("property").innerHTML = x;
}
function changeMethod() {
  var x = document.getElementById("methods").value;
  document.getElementById("method").innerHTML = x;
}
function changeEvent() {
  var x = document.getElementById("events").value;
  document.getElementById("event").innerHTML = x;
}
</script>

</head>
<body>

<div>






<!--
<div class="heading">&lt;ext-colorselector&gt;&lt;/ext-colorselector&gt;</div>
-->

<div class="heading">ext-colorselector</div>
<br>
<pre>encha Pro Services presents xtype "colorselector".
API has been kept as close to the regular colorpicker as possible. The Selector can be
rendered to any container.

The defaul selected color is conf...</pre>
<br>
<div><b>JavaScript:</b></div>

<pre class="code">
import '@sencha/ext-web-components/lib/ext-colorselector.component';

colorselectorReady(event) {
  this.ColorselectorCmp = event.detail.cmp;
}
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-colorselector onready="colorselectorReady"&gt;&lt;/ext-colorselector&gt;
</pre>


<!--
<pre class="code">
import '@sencha/ext-web-components/lib/ext-colorselector.component';

class ColorselectorComponentExample {

  onColorselectorReady(event) {
    this.ColorselectorCmp = event.detail.cmp;
  }

}

window.ColorselectorExample = new ColorselectorComponentExample();
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-colorselector onready="ColorselectorExample.onColorselectorReady"&gt;
...
&lt;/ext-colorselector&gt;
</pre>
-->

<div style="height:300px;">
    <z-tabs>
        <z-tabpanel tabname="properties">
<div class="flex-container">
  <div id="propertylist" class="thelist"><div>properties:</div><div class="select-div"><select id="properties" onchange="changeProperty()" name="properties">
    <option value="The format used by {@link Ext.util.Format#method!number Ext.util.Format#number} to format the alpha channel's
value.
">alphaDecimalFormat</option>
    <option value="Text value for "Cancel" button;
these are relied upon by the {@link Ext.ux.colorpick.Button} and the
{@link Ext.ux.colorpick.Field}.
">cancelButtonText</option>
    <option value="This config property is used internally by the UI to maintain the full color.
Changes to this config are automatically reflected in `{@link #cfg!value value}` and vise-versa.
Setting `{@link #cfg!value value}` can, however, cause the alpha to be dropped if the new value
does not contain an alpha component.
">color</option>
    <option value="padding between the sliders and HEX/R/G/B fields.
">fieldPad</option>
    <option value="Width of the text fields on the container (excluding HEX);
since the width of the slider containers is the same as the text field under it
(it's the same vbox column), changing this value will also affect the spacing between
the sliders.
">fieldWidth</option>
    <option value="The color format to for the `{@link #cfg!value value}` config. The `{@link #cfg!value value}` can be set using any
supported format or named color, but the stored value will always be in this
format.

Supported formats are:

- hex6 - For example "ffaa00" (Note: does not preserve transparency).
- hex8 - For eaxmple "ffaa00ff" - the last 2 digits represent transparency
- #hex6 - For example "#ffaa00" (same as "hex6" but with a leading "#").
- #hex8 - For example "#ffaa00ff" (same as "hex8" but with a leading "#").
- HEX6 - Same as "hex6" but upper case.
- HEX8 - Same as "hex8" but upper case.
- #HEX6 - Same as "#hex6" but upper case.
- #HEX8 - Same as "#hex8" but upper case.
">format</option>
    <option value="Text value for "Ok" button;
these are relied upon by the {@link Ext.ux.colorpick.Button} and the
{@link Ext.ux.colorpick.Field}.
">okButtonText</option>
    <option value="Whether Ok and Cancel buttons (in upper right, below the selected color preview) should
be shown;
these are relied upon by the {@link Ext.ux.colorpick.Button} and the
{@link Ext.ux.colorpick.Field}.
">showOkCancelButtons</option>
    <option value="Whether "previous color" region (in upper right, below the selected color preview) should
be shown;
these are relied upon by the {@link Ext.ux.colorpick.Button} and the
{@link Ext.ux.colorpick.Field}.
">showPreviousColor</option>
    <option value="The initial color to highlight; see {@link #cfg!format #format} for supported formats.
">value</option>
</select></div>
</div>
  <div id="property" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="methods">
<div class="flex-container">
  <div id="methodlist" class="thelist"><div>methods:</div><div class="select-div"><select id="methods" onchange="changeMethod()" name="methods">
    <option value="This method applies a versioned, deprecation declaration to this class. This
is typically called by the `deprecated` config.
">addDeprecations</option>
    <option value="Call the original method that was previously overridden with {@link Ext.Base#static-method!override Ext.Base#override}

    Ext.define('My.Cat', {
        constructor: function() {
            alert("I'm a cat!");
        }
    });

    My.Cat.override({
        constructor: function() {
            alert("I'm going to be a cat!");

            this.callOverridden();

            alert("Meeeeoooowwww");
        }
    });

    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
                              // alerts "I'm a cat!"
                              // alerts "Meeeeoooowwww"
">callOverridden</option>
    <option value="Call the "parent" method of the current method. That is the method previously
overridden by derivation or by an override (see {@link Ext#method!define Ext#define}).

     Ext.define('My.Base', {
         constructor: function(x) {
             this.x = x;
         },

         statics: {
             method: function(x) {
                 return x;
             }
         }
     });

     Ext.define('My.Derived', {
         extend: 'My.Base',

         constructor: function() {
             this.callParent([21]);
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // alerts 21

This can be used with an override as follows:

     Ext.define('My.DerivedOverride', {
         override: 'My.Derived',

         constructor: function(x) {
             this.callParent([x*2]); // calls original My.Derived constructor
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // now alerts 42

This also works with static and private methods.

     Ext.define('My.Derived2', {
         extend: 'My.Base',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Base.method
             }
         }
     });

     alert(My.Base.method(10));     // alerts 10
     alert(My.Derived2.method(10)); // alerts 20

Lastly, it also works with overridden static methods.

     Ext.define('My.Derived2Override', {
         override: 'My.Derived2',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Derived2.method
             }
         }
     });

     alert(My.Derived2.method(10); // now alerts 40

To override a method and replace it and also call the superclass method, use
{@link #method!callSuper #method-callSuper}. This is often done to patch a method to fix a bug.
">callParent</option>
    <option value="This method is used by an **override** to call the superclass method but
bypass any overridden method. This is often done to "patch" a method that
contains a bug but for whatever reason cannot be fixed directly.

Consider:

     Ext.define('Ext.some.Class', {
         method: function() {
             console.log('Good');
         }
     });

     Ext.define('Ext.some.DerivedClass', {
         extend: 'Ext.some.Class',

         method: function() {
             console.log('Bad');

             // ... logic but with a bug ...

             this.callParent();
         }
     });

To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
override:

     Ext.define('App.patches.DerivedClass', {
         override: 'Ext.some.DerivedClass',

         method: function() {
             console.log('Fixed');

             // ... logic but with bug fixed ...

             this.callSuper();
         }
     });

The patch method cannot use {@link #method!callParent #method-callParent} to call the superclass
`method` since that would call the overridden method containing the bug. In
other words, the above patch would only produce "Fixed" then "Good" in the
console log, whereas, using `callParent` would produce "Fixed" then "Bad"
then "Good".
">callSuper</option>
    <option value="This method is called to cleanup an object and its resources. After calling
this method, the object should not be used any further in any way, including
access to its methods and properties.

To prevent potential memory leaks, all object references will be nulled
at the end of destruction sequence, unless {@link #property!clearPropertiesOnDestroy #clearPropertiesOnDestroy}
is set to `false`.
">destroy</option>
    <option value="Destroys member properties by name.

If a property name is the name of a *config*, the getter is *not* invoked, so
if the config has not been initialized, nothing will be done.

The property will be destroyed, and the corrected name (if the property is a *config*
and config names are prefixed) will set to `null` in this object's dictionary.
">destroyMembers</option>
    <option value="Returns a specified config property value. If the name parameter is not passed,
all current configuration options will be returned as key value pairs.
">getConfig</option>
    <option value="undefined">getCurrentConfig</option>
    <option value="Returns the initial configuration passed to the constructor when
instantiating this class.

Given this example Ext.button.Button definition and instance:

    Ext.define('MyApp.view.Button', {
        extend: 'Ext.button.Button',
        xtype: 'mybutton',

        scale: 'large',
        enableToggle: true
    });

    var btn = Ext.create({
        xtype: 'mybutton',
        renderTo: Ext.getBody(),
        text: 'Test Button'
    });

Calling `btn.getInitialConfig()` would return an object including the config
options passed to the `{@link #static-method!create create}` method:

    xtype: 'mybutton',
    renderTo: // The document body itself
    text: 'Test Button'

Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
">getInitialConfig</option>
    <option value="undefined">hasConfig</option>
    <option value="Initialize configuration for this class. a typical example:

    Ext.define('My.awesome.Class', {
        // The default config
        config: {
            name: 'Awesome',
            isAwesome: true
        },

        constructor: function(config) {
            this.initConfig(config);
        }
    });

    var awesome = new My.awesome.Class({
        name: 'Super Awesome'
    });

    alert(awesome.getName()); // 'Super Awesome'
">initConfig</option>
    <option value="Adds a "destroyable" object to an internal list of objects that will be destroyed
when this instance is destroyed (via `{@link #method!destroy}`).
">link</option>
    <option value="Sets a single/multiple configuration options.
">setConfig</option>
    <option value="Get the reference to the class from which this object was instantiated. Note that unlike
{@link Ext.Base#property!self Ext.Base#self}, `this.statics()` is scope-independent and it always returns
the class from which it was called, regardless of what `this` points to during run-time

    Ext.define('My.Cat', {
        statics: {
            totalCreated: 0,
            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        },

        constructor: function() {
            var statics = this.statics();

            // always equals to 'Cat' no matter what 'this' refers to
            // equivalent to: My.Cat.speciesName
            alert(statics.speciesName);


            alert(this.self.speciesName);   // dependent on 'this'

            statics.totalCreated++;
        },

        clone: function() {
            var cloned = new this.self();   // dependent on 'this'

            // equivalent to: My.Cat.speciesName
            cloned.groupName = this.statics().speciesName;

            return cloned;
        }
    });


    Ext.define('My.SnowLeopard', {
        extend: 'My.Cat',

        statics: {
            speciesName: 'Snow Leopard' // My.SnowLeopard.speciesName = 'Snow Leopard'
        },

        constructor: function() {
            this.callParent();
        }
    });

    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'

    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'

    var clone = snowLeopard.clone();
    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
    alert(clone.groupName);                 // alerts 'Cat'

    alert(My.Cat.totalCreated);             // alerts 3
">statics</option>
    <option value="Destroys a given set of `{@link #method!link linked}` objects. This is only needed if
the linked object is being destroyed before this instance.
">unlink</option>
    <option value="Watches config properties.

     instance.watchConfig({
         title: 'onTitleChange',
         scope: me
     });
">watchConfig</option>
</select></div>
</div>
  <div id="method" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="events">
<div class="flex-container">
  <div id="eventlist" class="thelist"><div>events:</div><div class="select-div"><select id="events" onchange="changeEvent()" name="events">
    <option value="Fires when Cancel button is clicked (see {@link #cfg!showOkCancelButtons #showOkCancelButtons}).
">cancel</option>
    <option value="Fires when a color is selected. Simply dragging sliders around will trigger this.
">change</option>
    <option value="Fires when OK button is clicked (see {@link #cfg!showOkCancelButtons #showOkCancelButtons}).
">ok</option>
</select></div>
</div>
  <div id="event" class="thetext"></div>
</div>
        </z-tabpanel>
    </z-tabs>
</div>

<p>
------------------
<pre>Sencha Pro Services presents xtype "colorselector".
API has been kept as close to the regular colorpicker as possible. The Selector can be
rendered to any container.

The defaul selected color is configurable via {@link #cfg!value #value} config
and The Format is configurable via {@link #cfg!format #format}. Usually used in
forms via {@link Ext.ux.colorpick.Button} or {@link Ext.ux.colorpick.Field}.

Typically you will need to listen for the change event to be notified when the user
chooses a color. Alternatively, you can bind to the "value" config

    @example
    Ext.create('Ext.ux.colorpick.Selector', {
        value     : '993300',  // initial selected color
        format   : 'hex6', // by default it's hex6
        renderTo  : Ext.getBody(),

        listeners: {
            change: function (colorselector, color) {
                console.log('New color: ' + color);
            }
        }
    });
</pre>

<span><b>Ext JS name:</b></span>
<br>
<span>Ext.ux.colorpick.Selector</span>
<br><br>
<span><b>others:</b></span>
extend: 
extenders: 
mixed: Ext.Mixin,Ext.mixin.Accessible,Ext.mixin.Bindable,Ext.mixin.ComponentDelegation,Ext.mixin.Container,Ext.mixin.Factoryable,Ext.mixin.Focusable,Ext.mixin.FocusableContainer,Ext.mixin.Identifiable,Ext.mixin.Inheritable,Ext.mixin.Keyboard,Ext.mixin.Observable,Ext.mixin.Pluggable,Ext.mixin.Queryable,Ext.mixin.Toolable,Ext.panel.Buttons,Ext.state.Stateful,Ext.ux.colorpick.Selection
mixins: Ext.ux.colorpick.Selection
requires: Ext.field.Text,Ext.field.Number,Ext.ux.colorpick.ColorMap,Ext.ux.colorpick.SelectorModel,Ext.ux.colorpick.SelectorController,Ext.ux.colorpick.ColorPreview,Ext.ux.colorpick.Slider,Ext.ux.colorpick.SliderAlpha,Ext.ux.colorpick.SliderSaturation,Ext.ux.colorpick.SliderValue,Ext.ux.colorpick.SliderHue
src: [object Object]



</div>

</body>
</html>