<!DOCTYPE HTML>
<html>
<head>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="z-tabs.js"></script>

<script>
function changeProperty() {
  var x = document.getElementById("properties").value;
  document.getElementById("property").innerHTML = x;
}
function changeMethod() {
  var x = document.getElementById("methods").value;
  document.getElementById("method").innerHTML = x;
}
function changeEvent() {
  var x = document.getElementById("events").value;
  document.getElementById("event").innerHTML = x;
}
</script>

</head>
<body>

<div>






<!--
<div class="heading">&lt;ext-numbercell&gt;&lt;/ext-numbercell&gt;</div>
-->

<div class="heading">ext-numbercell</div>
<br>
<pre>his class displays a numeric value in a {@link Ext.grid.Grid} cell. This cell type
is typically used by specifying {@link Ext.grid.column.Number} column type.

{@link Ext.grid.Row} create cells based...</pre>
<br>
<div><b>JavaScript:</b></div>

<pre class="code">
import '@sencha/ext-web-components/lib/ext-numbercell.component';

numbercellReady(event) {
  this.NumbercellCmp = event.detail.cmp;
}
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-numbercell onready="numbercellReady"&gt;&lt;/ext-numbercell&gt;
</pre>


<!--
<pre class="code">
import '@sencha/ext-web-components/lib/ext-numbercell.component';

class NumbercellComponentExample {

  onNumbercellReady(event) {
    this.NumbercellCmp = event.detail.cmp;
  }

}

window.NumbercellExample = new NumbercellComponentExample();
</pre>

<div><b>HTML:</b></div>
<pre class="code">
&lt;ext-numbercell onready="NumbercellExample.onNumbercellReady"&gt;
...
&lt;/ext-numbercell&gt;
</pre>
-->

<div style="height:300px;">
    <z-tabs>
        <z-tabpanel tabname="properties">
<div class="flex-container">
  <div id="propertylist" class="thelist"><div>properties:</div><div class="select-div"><select id="properties" onchange="changeProperty()" name="properties">
    <option value="The value for the `text-align` of the cell content.
">align</option>
    <option value="Specifies the self alignment of this widget in a box layout
">alignSelf</option>
    <option value="A flag indicating that this component should
be above its floated siblings.

This may be a positive number to prioritize the ordering of multiple visible always on
top components.

This may be set to a *negative* number to prioritize a component to the *bottom* of the
z-index stack.
">alwaysOnTop</option>
    <option value="An object containing ARIA attributes to be set
on this Component's ARIA element. Use this to set the attributes that cannot be
determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.

**Note** that this config is only meaningful at the Component rendering time,
and setting it after that will do nothing.
">ariaAttributes</option>
    <option value="DOM selector for a child element that is to be used
as description for this Component, set in `aria-describedby` attribute.
The selector works the same way as {@link #cfg!ariaLabelledBy #ariaLabelledBy}.
">ariaDescribedBy</option>
    <option value="ARIA label for this Component. It is best to use
{@link #cfg!ariaLabelledBy #ariaLabelledBy} option instead, because screen readers prefer
`aria-labelledby` attribute to `aria-label`. {@link #cfg!ariaLabel #ariaLabel} and
{@link #cfg!ariaLabelledBy #ariaLabelledBy} config options are mutually exclusive.
">ariaLabel</option>
    <option value="DOM selector for a child element that is to be used
as label for this Component, set in `aria-labelledby` attribute.
If the selector is by `{@link #cfg!id #id}`, the label element can be any existing element,
not necessarily a child of the main Component element.

{@link #cfg!ariaLabelledBy #ariaLabelledBy} and {@link #cfg!ariaLabel #ariaLabel} config options are
mutually exclusive, and `{@link #cfg!ariaLabelledBy ariaLabelledBy}` has the higher precedence.
">ariaLabelledBy</option>
    <option value="Setting this config option adds or removes data bindings for other configs.
For example, to bind the `title` config:

     var panel = Ext.create({
         xtype: 'panel',
         bind: {
             title: 'Hello {user.name}'
         }
     });

To dynamically add bindings:

     panel.setBind({
         title: 'Greetings {user.name}!'
     });

To remove bindings:

     panel.setBind({
         title: null
     });

The bind expressions are presented to `{@link Ext.app.ViewModel#method!bind Ext.app.ViewModel#bind}`. The
`ViewModel` instance is determined by `{@link #method!lookupViewModel lookupViewModel}`.

**Note:** If  bind is passed as a string, it will use the
{@link Ext.Component#property!defaultBindProperty Ext.Component#property-defaultBindProperty} for the binding.
">bind</option>
    <option value="An arbitrary CSS class to add to the cell's inner element (the element that
typically contains the cell's text).
">bodyCls</option>
    <option value="Additional CSS styles that will be rendered into the cell's inner element (the
element that typically contains the cell's text).

You can pass either a string syntax:

    bodyStyle: 'background:red'

Or by using an object:

    bodyStyle: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    bodyStyle: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
">bodyStyle</option>
    <option value="Enables or disables bordering on this component.
The following values are accepted:

- `null` or `true (default): Do nothing and allow the border to be specified
by the theme.
- `false`: suppress the default border provided by the theme.

Please note that enabling bordering via this config will not add a `border-color`
or `border-style` CSS property to the component; you provide the `border-color`
and `border-style` via CSS rule or {@link #cfg!style #style} configuration
(if not already provide by the theme).

## Using {@link #cfg!style #style}:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        style: 'border: 1px solid blue;'
        // ...
    });

## Using CSS:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        cls: 'my-component'
        // ...
    });

And your CSS file:

    .my-component {
        border: 1px solid red;
    }
">border</option>
    <option value="undefined">cellCls</option>
    <option value="An arbitrary CSS class to add to the cell's outermost element.
">cls</option>
    <option value="The grid column that created this cell.
">column</option>
    <option value="A specification of the constraint to apply when {@link #showBy} or {@link #method!alignTo #alignTo}
is called to align a {@link #cfg!floated #floated} or positioned component.

Defaults to the parent container for *positioned* components (components
which have their {@link #cfg!top}, {@link #cfg!right}, {@link #cfg!bottom} or
{@link #cfg!left} set to move them out of their container's layout flow).

Defaults to the viewport for {@link #cfg!floated #floated} components.

May be a {@link Ext.ComponentQuery} selector to find an ancestor
component to constrain within.

May be `false` to specify that constraining is not applied.

You may also specify an element, or a {@link Ext.util.Region}
">constrainAlign</option>
    <option value="A string alias, a configuration object or an instance of a `ViewController` for
this container. Sample usage:

    Ext.define('MyApp.UserController', {
        alias: 'controller.user'
    });

    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: 'user'
    });
    // Or
    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: {
            type: 'user',
            someConfig: true
        }
    });

    // Can also instance at runtime
    var ctrl = new MyApp.UserController();
    var view = new UserContainer({
        controller: ctrl
    });
">controller</option>
    <option value="If `true`, this component will be the default scope (this pointer) for events
specified with string names so that the scope can be dynamically resolved. The
component will automatically become the defaultListenerScope if a
{@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for some sample
usages.

**NOTE**: This value can only be reliably set at construction time. Setting it
after that time may not correctly rewire all of the potentially effected
listeners.
">defaultListenerScope</option>
    <option value="The default `weight` for tools in the `header`.
">defaultToolWeights</option>
    <option value="Whether or not this component is disabled
">disabled</option>
    <option value="Specify `false` to write HTML directly to the cell. Be aware that doing this
can expose your application to security issues if that content is not known to
be safe. User input can contain malicious content such as `script` tags and
should be scrubbed before directly rendering that HTML.
">encodeHtml</option>
    <option value="A map of event type to the corresponding handler method
name. This is used internally by native event handling mechanism.
">eventHandlers</option>
    <option value="The flex of this item *if* this item item is inside a {@link Ext.layout.HBox}
or {@link Ext.layout.VBox} layout.

You can also update the flex of a component dynamically using
the {@link Ext.layout.FlexBox#setItemFlex} method.

When supplied as a string or number this option supports the same syntax
as CSS [flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex).
For example:

    flex: '1 2 auto'

sets `flex-grow` property to `0`, `flex-shrink` to `2` and `flex-basis` to
`'auto'`.

The default `flex-shrink` value for box layout items is set to `0` in the
stylesheet, which is different from the browser's default `flex-shrink` value
of `1`.  This accommodates the majority use case for applications since where
non-flexed components are typically not expected to shrink smaller than their
default size.

For convenience when only a single number is supplied it is used as the value
for both `flex-grow` and `flex-shrink`, for example `flex: 3` is the same as
`flex: '3 3'`

An object form is also accepted:

    flex: {
        grow: 1,
        shrink: 2,
        basis: 'auto'
    }

When the object form is supplied `shrink` always defaults to `0` regardless
of the value of `grow`.

Although `'auto'` is the default value for flex-basis, flex-basis defaults to 0%
when flex is supplied as a single numeric or string value (e.g. `flex: 1`). If
this behavior is not desired either explicitly set flex-basis to `'auto'` or use
the object form to set only grow and/or shrink:

    flex: {
        grow: 2
    }
">flex</option>
    <option value="A Component may be floated above all other components in the application. This means that
the component is absolutely positioned, and will move to the front and occlude other
sibling floated component if clicked.

A Floated component may have floated descendants. It will bring these decendants to the
front with it when brought to the front of its sibling floated components.

By default, descendant floated components are all positioned using the viewport
coordinate system. To make a floating component a positioning parent for descendants,
and have the ancestors positioned relatively, configure the parent floated component
with `{@link #cfg!relative #cfg-relative}: true`.
">floated</option>
    <option value="CSS class that will be added to focused
component's {@link #property!focusClsEl #focusClsEl}, and removed when component blurs.
">focusCls</option>
    <option value="A format string as used by {@link Ext.util.Format#method!number Ext.util.Format#number} to format values for
this column.
">format</option>
    <option value="The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">height</option>
    <option value="The hidden state of this cell (propagated from the column's hidden state).
">hidden</option>
    <option value="A String which specifies how this component's DOM element will be hidden. The
accepted values are any of these:

- `'clip'` : Hide using {@link Ext.dom.Element#static-property!CLIP clip}.
- `'display'` : Hide using {@link Ext.dom.Element#static-property!DISPLAY display}.
- `'offsets'` : Hide using positioning {@link Ext.dom.Element#static-property!OFFSETS offsets}.
- `'opacity'` : Hide using {@link Ext.dom.Element#static-property!OPACITY opacity}.
- `'visibility'` : Hide using {@link Ext.dom.Element#static-property!VISIBILITY visibility}.

Hiding using ``display`` results in having no dimensions as well as resetting
scroll positions to 0.

The other modes overcome this but may have different trade-offs in certain
circumstances.
">hideMode</option>
    <option value="The **unique id of this component instance.**

It should not be necessary to use this configuration except for singleton objects in
your application. Components created with an id may be accessed globally
using {@link Ext#method!getCmp Ext.getCmp}.

Instead of using assigned ids, use the {@link #cfg!itemId #itemId} config,
and {@link Ext.ComponentQuery} which provides selector-based searching
for Sencha Components analogous to DOM querying. The {@link Ext.Container} class
contains {@link Ext.Container#method!down shortcut methods} to query its descendant Components
by selector.

Note that this id will also be used as the element id for the containing HTML element
that is rendered to the page for this component. This allows you to write id-based CSS
rules to style the specific instance of this component uniquely, and also to select
sub-elements using this component's id as the parent.

**Note**: to avoid complications imposed by a unique id also see `{@link #cfg!itemId #itemId}`.

Defaults to an auto-assigned id.
">id</option>
    <option value="
An extra CSS class or classes to augment the {@link #property!classCls #classCls} on an individual instance
">instanceCls</option>
    <option value="An itemId can be used as an alternative way to get a reference to a component when no
object reference is available. Instead of using an `{@link #cfg!id #id}` with {@link Ext#method!getCmp Ext#getCmp},
use `{@link #cfg!itemId itemId}` with {@link Ext.Container#method!getComponent Ext.Container#getComponent} which will retrieve `{@link #cfg!itemId itemId}`'s or
{@link #cfg!id #id}'s. Since `{@link #cfg!itemId itemId}`'s are an index to the container's internal MixedCollection,
the `{@link #cfg!itemId itemId}` is scoped locally to the container - avoiding potential conflicts with
{@link Ext.ComponentManager} which requires a **unique** `{@link #cfg!id #id}`.

Also see {@link #cfg!id #id}, {@link Ext.Container#method!query Ext.Container#query}, {@link Ext.Container#method!down Ext.Container#down} and
{@link Ext.Container#method!child Ext.Container#child}.
">itemId</option>
    <option value="An object containing handlers for keyboard events. The property names of this
object are the key name and any modifiers. The values of the properties are the
descriptors of how to handle each event.

The handler descriptor can be simply the handler function(either the
literal function or the method name), or it can be an object with these
properties:

 - `handler`: The function or its name to call to handle the event.
 - `scope`: The this pointer context (can be "this" or "controller").
 - `event`: An optional override of the key event to which to listen.

**Important:** Calls to `setKeyMap` do not replace the entire `{@link #cfg!keyMap keyMap}` but
instead update the provided mappings. That is, unless `null` is passed as the
value of the `{@link #cfg!keyMap keyMap}` which will clear the `{@link #cfg!keyMap keyMap}` of all entries.
">keyMap</option>
    <option value="Enables or disables processing keys in the `{@link #cfg!keyMap keyMap}`. This value starts as
`null` and if it is `null` when `{@link #method!initKeyMap initKeyMap}` is called, it will automatically
be set to `true`. Since `{@link #method!initKeyMap initKeyMap}` is called by `{@link Ext.Component}` at the
proper time, this is not something application code normally handles.
">keyMapEnabled</option>
    <option value="The name of the member that should be used to listen for keydown/keypress events.
This is intended to be controlled at the class level not per instance.
">keyMapTarget</option>
    <option value="
A config object containing one or more event handlers to be added to this object during
initialization. This should be a valid listeners config object as specified in the
{@link Ext.util.Observable#method!addListener addListener} example for attaching
multiple handlers at once.

**DOM events from Ext JS {@link Ext.Component}**

While _some_ Ext JS Component classes export selected DOM events (e.g. "click",
"mouseover" etc), this is usually only done when extra value can be added. For example
the {@link Ext.view.View DataView}'s **`{@link Ext.view.View#itemclick itemclick}`**
event passing the node clicked on. To access DOM events directly from a child element
of a Component, we need to specify the `element` option to identify the Component
property to add a DOM listener to:

    new Ext.panel.Panel({
        width: 400,
        height: 200,
        dockedItems: [{
            xtype: 'toolbar'
        }],
        listeners: {
            click: {
                element: 'el', //bind to the underlying el property on the panel
                fn: function(){ console.log('click el'); }
            },
            dblclick: {
                element: 'body', //bind to the underlying body property on the panel
                fn: function(){ console.log('dblclick body'); }
            }
        }
    });
">listeners</option>
    <option value="The margin to use on this Component. Can be specified as a number (in which
case all edges get the same margin) or a CSS string like '5 10 10 10'
">margin</option>
    <option value="Name for the widget to be used with {@link Ext.Container#method!lookupName Ext.Container#lookupName}
et al.
">name</option>
    <option value="Set to `true` for this component's `name` property to be tracked by its containing
`nameHolder`.
">nameable</option>
    <option value="This config describes one or more plugin config objects used to create plugin
instances for this component.

Plugins are a way to bundle and reuse custom functionality. Plugins should extend
`{@link Ext.plugin.Abstract}` but technically the only requirement for a valid plugin
is that it contain an `init` method that accepts a reference to its owner. Once
a plugin is created, the owner will call the `init` method, passing a reference
to itself. Each plugin can then call methods or respond to events on its owner
as needed to provide its functionality.

This config's value can take several different forms.

The value can be a single string with the plugin's {@link Ext.enums.Plugin alias}:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: 'listpaging'
     });

In the above examples, the string "listpaging" is the type alias for
`{@link Ext.dataview.plugin.ListPaging}`. The full alias includes the "plugin." prefix
(i.e., 'plugin.listpaging').

The preferred form for multiple plugins or to configure plugins is the
keyed-object form (new in version 6.5):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: {
             pullrefresh: true,
             listpaging: {
                 autoPaging: true,
                 weight: 10
             }
         }
     });

The object keys are the `id`'s as well as the default type alias. This form
allows the value of the `{@link #cfg!plugins plugins}` to be merged from base class to derived class
and finally with the instance configuration. This allows classes to define a
set of plugins that derived classes or instantiators can further configure or
disable. This merge behavior is a feature of the
{@link Ext.Class#cfg!config}.

The `{@link #cfg!plugins plugins}` config can also be an array of plugin aliases (arrays are not
merged so this form does not respect plugins defined by the class author):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

An array can also contain elements that are config objects with a `type`
property holding the type alias:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['pullrefresh', {
             type: 'listpaging',
             autoPaging: true
         }]
     });
">plugins</option>
    <option value="One or more names of config properties that this component should publish
to its ViewModel. Generally speaking, only properties defined in a class config
block (including ancestor config blocks and mixins) are eligible for publishing
to the viewModel. Some components override this and publish their most useful
configs by default.

**Note:** We'll discuss publishing properties **not** found in the config block below.

Values determined to be invalid by component (often form fields and model validations)
will not be published to the ViewModel.

This config uses the `{@link #cfg!reference #cfg-reference}` to determine the name of the data
object to place in the `ViewModel`. If `{@link #cfg!reference reference}` is not set then this config
is ignored.

By using this config and `{@link #cfg!reference #cfg-reference}` you can bind configs between
components. For example:

     ...
         items: [{
             xtype: 'textfield',
             reference: 'somefield',  // component's name in the ViewModel
             publishes: 'value' // value is not published by default
         },{
             ...
         },{
             xtype: 'displayfield',
             bind: 'You have entered "{somefield.value}"'
         }]
     ...

Classes must provide this config as an Object:

     Ext.define('App.foo.Bar', {
         publishes: {
             foo: true,
             bar: true
         }
     });

This is required for the config system to properly merge values from derived
classes.

For instances this value can be specified as a value as show above or an array
or object as follows:

     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: [
             'value',
             'rawValue',
             'dirty'
         ]
     }

     // This achieves the same result as the above array form.
     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: {
             value: true,
             rawValue: true,
             dirty: true
         }
     }

In some cases, users may want to publish a property to the viewModel that is not found
in a class  config block. In these situations, you may utilize {@link #method!publishState #publishState}
if the property has a  setter method. Let's use
{@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:

      setFieldLabel: function(fieldLabel) {
          this.callParent(arguments);
          this.publishState('fieldLabel', fieldLabel);
      }

With the above chunk of code, fieldLabel may now be published to the viewModel.
">publishes</option>
    <option value="The text value of the cell. This value will be written to the cell differently
based on the {@link #cfg!encodeHtml #encodeHtml} config. This config is automatically set as a
result of setting the {@link #cfg!value #value} config and is rarely set directly. This is
a separate config to avoid writting the same formatted result to the DOM.
">rawValue</option>
    <option value="The currently associated record.
">record</option>
    <option value="Specifies a name for this component inside its component hierarchy. This name
must be unique within its {@link Ext.Container#cfg!referenceHolder view}
or its {@link Ext.app.ViewController}. See the documentation in
{@link Ext.Container Ext.container.Container} for more information about references.

**Note**: Valid identifiers start with a letter or underscore and are followed
by zero or more additional letters, underscores or digits. References are case
sensitive.
">reference</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure this as `true` if you require descendant floated components to be positioned
relative to this component's coordinate space, not the viewport's coordinate space.

*Note:* The coordinate space is this Component's encapsulating element's area. Not that
of the inner element in which static child items are rendered by the layout.
">relative</option>
    <option value="Optional element to render this Component to.
Not required if this component is an {@link Ext.Container#cfg!items item} of a Container
of a Container.
">renderTo</option>
    <option value="Set to truthy, Color or Object value for the ripple.
">ripple</option>
    <option value="Set to `false` to disable selection of the record when tapping on this cell.
">selectable</option>
    <option value="If provided this creates a new `Session` instance for this component. If this
is a `Container`, this will then be inherited by all child components.

To create a new session you can specify `true`:

     Ext.create({
         xtype: 'viewport',
         session: true,

         items: [{
             ...
         }]
     });

Alternatively, a config object can be provided:

     Ext.create({
         xtype: 'viewport',
         session: {
             ...
         },

         items: [{
             ...
         }]
     });
">session</option>
    <option value="Configure as `true` for the component to have a drop shadow. 'false' will suppress any
default shadow. By default the theme will determine the presence of a shadow.
">shadow</option>
    <option value="Set to `true` to allow this component's `name` to be shared by other items in the
same `nameHolder`. Such items will be returned in an array from `lookupName`.
">shareableName</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure as `true` for the component to use an `<iframe>` as an underlay to ensure
certain non-standard browser plugins are occluded by this component.
">shim</option>
    <option value="Additional CSS styles that will be rendered into an inline style attribute when
the widget is rendered.

You can pass either a string syntax:

    style: 'background:red'

Or by using an object:

    style: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    style: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
">style</option>
    <option value="True to automatically call {@link #method!toFront #toFront} when a {@link #cfg!floated #cfg-floated} Component is
shown.
">toFrontOnShow</option>
    <option value="The properties of this object are shallow copied (via {@link Ext#method!applyIf applyIf()}
as opposed to {@link Ext#method!merge Ext.merge()} to each tool declared in the `{@link #cfg!tools tools}`
config.
">toolDefaults</option>
    <option value="An array of {@link Ext.Tool} configs or an object keyed by `itemId`.
">tools</option>
    <option value="
Emulates the behavior of the CSS
[touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
property in a cross-browser compatible manner.

Keys in this object are touch action names, and values are `false` to disable
a touch action or `true` to enable it.  Accepted keys are:

- `panX`
- `panY`
- `pinchZoom`
- `doubleTapZoom`

All touch actions are enabled (`true`) by default, so it is usually only necessary
to specify which touch actions to disable.  For example, the following disables
only horizontal scrolling and pinch-to-zoom on the component's main element:

    touchAction: {
        panX: false,
        pinchZoom: false
    }

Touch actions can be specified on reference elements using the reference element
name, for example:

    // disables horizontal scrolling on the main element, and double-tap-zoom
    // on the child element named "body"
    touchAction: {
        panY: false
        body: {
            doubleTapZoom: false
        }
    }

The primary motivation for setting the touch-action of an element is to prevent
the browser's default handling of a gesture such as pinch-to-zoom, or
drag-to-scroll, so that the application can implement its own handling of that
gesture on the element.  Suppose, for example, a component has a custom drag
handler on its element and wishes to prevent horizontal scrolling of its container
while it is being dragged:

    Ext.create('Ext.Widget', {
        touchAction: {
            panX: false
        },
        listeners: {
            drag: function(e) {
                // implement drag logic
            }
        }
    });
">touchAction</option>
    <option value="undefined">translatable</option>
    <option value="This object holds a map of `config` properties that will update their binding
as they are modified. For example, `value` is a key added by form fields. The
form of this config is the same as `{@link #cfg!publishes}`.

This config is defined so that updaters are not created and added for all
bound properties since most cannot be modified by the end-user and hence are
not appropriate for two-way binding.
">twoWayBindable</option>
    <option value="The ui or uis to be used on this Component

When a ui is configured, CSS class names are added to the {@link #property!element #element}, created
by appending the ui name(s) to each {@link #property!classCls #classCls} and/or {@link #property!baseCls #baseCls}.
">ui</option>
    <option value="One or more CSS classes to add to the component's primary element. This config
is intended solely for use by the component instantiator (the "user"), not by
derived classes.

For example:

     items: [{
         xtype: 'button',
         userCls: 'my-button'
     ...
     }]
">userCls</option>
    <option value="The value of the {@link Ext.grid.column.Column#cfg!dataIndex dataIndex} field of
the associated record. Application code should not need to set this value.
">value</option>
    <option value="The `ViewModel` is a data provider for this component and its children. The
data contained in the `ViewModel` is typically used by adding `{@link #cfg!bind bind}` configs
to the components that want present or edit this data.

When set, the `ViewModel` is created and links to any inherited `{@link #cfg!viewModel viewModel}`
instance from an ancestor container as the "parent". The `ViewModel` hierarchy,
once established, only supports creation or destruction of children. The
parent of a `ViewModel` cannot be changed on the fly.

If this is a root-level `ViewModel`, the data model connection is made to this
component's associated `{@link Ext.data.Session}`. This is
determined by calling `getInheritedSession`.
">viewModel</option>
    <option value="The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
">width</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
">x</option>
    <option value="*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
">y</option>
    <option value="
A replacement value for 0.

If the cell value is 0 and you want to display it or hide it then you can define
a not null value here.

Set it as an empty string if you want to hide cells that have 0s.
">zeroValue</option>
</select></div>
</div>
  <div id="property" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="methods">
<div class="flex-container">
  <div id="methodlist" class="thelist"><div>methods:</div><div class="select-div"><select id="methods" onchange="changeMethod()" name="methods">
    <option value="Adds declarative listeners as nested arrays of listener objects.
">_addDeclaredListeners</option>
    <option value="Sets up a reference on our current reference holder.
">_fixReference</option>
    <option value="Creates a particular plugin type if defined in the `{@link #cfg!plugins plugins}` configuration.
">activatePlugin</option>
    <option value="Alias for {@link #method!onAfter #onAfter}.
">addAfterListener</option>
    <option value="Alias for {@link #method!onBefore #onBefore}.
">addBeforeListener</option>
    <option value="Adds a CSS class (or classes) to this Component's rendered element.
">addCls</option>
    <option value="Adds a listeners with the "delegate" event option.  Users should not invoke this
method directly.  Use the "delegate" event option of
{@link Ext.util.Observable#method!addListener addListener} instead.
">addDelegatedListener</option>
    <option value="This method applies a versioned, deprecation declaration to this class. This
is typically called by the `deprecated` config.
">addDeprecations</option>
    <option value="Adds an element reference to this Widget instance.
">addElementReference</option>
    <option value="Reduces instantiation time for a Widget by lazily instantiating Ext.Element
references the first time they are used.  This optimization only works for elements
with no listeners specified.
">addElementReferenceOnDemand</option>
    <option value="The {@link #method!on #on} method is shorthand for
{@link Ext.util.Observable#method!addListener addListener}.

Appends an event handler to this object.  For example:

    myGridPanel.on("itemclick", this.onItemClick, this);

The method also allows for a single argument to be passed which is a config object
containing properties which specify multiple events. For example:

    myGridPanel.on({
        cellclick: this.onCellClick,
        select: this.onSelect,
        viewready: this.onViewReady,
        scope: this // Important. Ensure "this" is correct during handler execution
    });

One can also specify options for each event handler separately:

    myGridPanel.on({
        cellclick: {fn: this.onCellClick, scope: this, single: true},
        viewready: {fn: panel.onViewReady, scope: panel}
    });

*Names* of methods in a specified scope may also be used:

    myGridPanel.on({
        cellclick: {fn: 'onCellClick', scope: this, single: true},
        viewready: {fn: 'onViewReady', scope: panel}
    });
">addListener</option>
    <option value="The addManagedListener method is used when some object (call it "A") is listening
to an event on another observable object ("B") and you want to remove that listener
from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
all of its listeners will be removed at that time.

Example:

    Ext.define('Foo', {
        extend: 'Ext.Component',

        initComponent: function () {
            this.addManagedListener(MyApp.SomeSharedMenu, 'show', this.doSomething);
            this.callParent();
        }
    });

As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.

As of version 5.1 it is no longer necessary to use this method in most cases because
listeners are automatically managed if the scope object provided to
{@link Ext.util.Observable#method!addListener addListener} is an Observable instance.
However, if the observable instance and scope are not the same object you
still need to use `{@link #method!mon mon}` or `{@link #method!addManagedListener addManagedListener}` if you want the listener to be
managed.
">addManagedListener</option>
    <option value="Adds a plugin. For example:

     list.addPlugin('pullrefresh');

Or:

     list.addPlugin({
         type: 'pullrefresh',
         pullRefreshText: 'Pull to refresh...'
     });
">addPlugin</option>
    <option value="This method is called after the component is initially added to the DOM. If this
component {@link Ext.Container} other components, the `{@link #method!afterRender afterRender}` method
for child components is called *before* the parent's `{@link #method!afterRender afterRender}`.

Implementations of this method should avoid reading from the DOM but are free to
write to the DOM as needed. To read the DOM, consider implementing
{@link #method!onRender onRender} instead.

This method is not generally needed because components always have their own DOM
{@link #property!element} and these are maintained by config property
updaters prior to insertion in the DOM. In general, it is always best to manipulate
the component's elements outside the DOM where there is no associated reflow or
layout cost. This method is useful for situations where the component's elements
must be in the DOM in order to be manipulated correctly.
">afterRender</option>
    <option value="undefined">alignTo</option>
    <option value="undefined">applyBind</option>
    <option value="Applier for the `{@link #cfg!plugins plugins}` config property.
">applyPlugins</option>
    <option value="Transforms a Session config to a proper instance.
">applySession</option>
    <option value="undefined">applyStyle</option>
    <option value="Transforms a ViewModel config to a proper instance.
">applyViewModel</option>
    <option value="undefined">blur</option>
    <option value="Returns `true` if this cell's value is bound to any of the given `fields`. This
is typically due to the `dataIndex`.
">bound</option>
    <option value="Bubbles up the {@link #method!getRefOwner} hierarchy, calling the specified function
with each component. The scope (`this` reference) of the function call will be the
scope provided or the current component. The arguments to the function will
be the args provided or the current component. If the function returns false at any
point, the bubble is stopped.
">bubble</option>
    <option value="Call the original method that was previously overridden with {@link Ext.Base#static-method!override Ext.Base#override}

    Ext.define('My.Cat', {
        constructor: function() {
            alert("I'm a cat!");
        }
    });

    My.Cat.override({
        constructor: function() {
            alert("I'm going to be a cat!");

            this.callOverridden();

            alert("Meeeeoooowwww");
        }
    });

    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
                              // alerts "I'm a cat!"
                              // alerts "Meeeeoooowwww"
">callOverridden</option>
    <option value="Call the "parent" method of the current method. That is the method previously
overridden by derivation or by an override (see {@link Ext#method!define Ext#define}).

     Ext.define('My.Base', {
         constructor: function(x) {
             this.x = x;
         },

         statics: {
             method: function(x) {
                 return x;
             }
         }
     });

     Ext.define('My.Derived', {
         extend: 'My.Base',

         constructor: function() {
             this.callParent([21]);
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // alerts 21

This can be used with an override as follows:

     Ext.define('My.DerivedOverride', {
         override: 'My.Derived',

         constructor: function(x) {
             this.callParent([x*2]); // calls original My.Derived constructor
         }
     });

     var obj = new My.Derived();

     alert(obj.x);  // now alerts 42

This also works with static and private methods.

     Ext.define('My.Derived2', {
         extend: 'My.Base',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Base.method
             }
         }
     });

     alert(My.Base.method(10));     // alerts 10
     alert(My.Derived2.method(10)); // alerts 20

Lastly, it also works with overridden static methods.

     Ext.define('My.Derived2Override', {
         override: 'My.Derived2',

         // privates: {
         statics: {
             method: function(x) {
                 return this.callParent([x*2]); // calls My.Derived2.method
             }
         }
     });

     alert(My.Derived2.method(10); // now alerts 40

To override a method and replace it and also call the superclass method, use
{@link #method!callSuper #method-callSuper}. This is often done to patch a method to fix a bug.
">callParent</option>
    <option value="This method is used by an **override** to call the superclass method but
bypass any overridden method. This is often done to "patch" a method that
contains a bug but for whatever reason cannot be fixed directly.

Consider:

     Ext.define('Ext.some.Class', {
         method: function() {
             console.log('Good');
         }
     });

     Ext.define('Ext.some.DerivedClass', {
         extend: 'Ext.some.Class',

         method: function() {
             console.log('Bad');

             // ... logic but with a bug ...

             this.callParent();
         }
     });

To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
override:

     Ext.define('App.patches.DerivedClass', {
         override: 'Ext.some.DerivedClass',

         method: function() {
             console.log('Fixed');

             // ... logic but with bug fixed ...

             this.callSuper();
         }
     });

The patch method cannot use {@link #method!callParent #method-callParent} to call the superclass
`method` since that would call the overridden method containing the bug. In
other words, the above patch would only produce "Fixed" then "Good" in the
console log, whereas, using `callParent` would produce "Fixed" then "Bad"
then "Good".
">callSuper</option>
    <option value="Clears all listeners that were attached using the "delegate" event option.
Users should not invoke this method directly.  It is called automatically as
part of normal {@link Ext.util.Observable#method!clearListeners clearListeners}
processing.
">clearDelegatedListeners</option>
    <option value="Removes all listeners for this object including the managed listeners
">clearListeners</option>
    <option value="Removes all managed listeners for this object.
">clearManagedListeners</option>
    <option value="Converts the provided type or config object into a plugin instance.
">createPlugin</option>
    <option value="Creates an event handling function which re-fires the event from this object
as the passed event name.
">createRelayer</option>
    <option value="Destroys the Widget. This method should not be overridden in custom Widgets,
because it sets the flags and does final cleanup that must go last. Instead,
override {@link #method!doDestroy #doDestroy} method to add functionality at destruction time.
">destroy</option>
    <option value="Destroys member properties by name.

If a property name is the name of a *config*, the getter is *not* invoked, so
if the config has not been initialized, nothing will be done.

The property will be destroyed, and the corrected name (if the property is a *config*
and config names are prefixed) will set to `null` in this object's dictionary.
">destroyMembers</option>
    <option value="Removes and destroys a plugin.

**Note:** Not all plugins are designed to be removable. Consult the documentation
for the specific plugin in question to be sure.
">destroyPlugin</option>
    <option value="Disables this Component
">disable</option>
    <option value="undefined">doAddListener</option>
    <option value="Perform the actual destruction sequence. This is the method to override in your
subclasses to add steps specific to the destruction of custom Component or Widget.

As a rule of thumb, subclasses should destroy their child Components, Elements,
and/or other objects before calling parent method. Any object references will be
nulled after this method has finished, to prevent the possibility of memory leaks.
">doDestroy</option>
    <option value="Fires a delegated event.  Users should not invoke this method directly.  It
is called automatically by the framework as needed (see the "delegate" event
option of {@link Ext.util.Observable#method!addListener addListener} for more
details.
">doFireDelegatedEvent</option>
    <option value="Continue to fire event.
">doFireEvent</option>
    <option value="undefined">doInheritUi</option>
    <option value="undefined">doUninheritUi</option>
    <option value="Enables this Component
">enable</option>
    <option value="Enables events fired by this Observable to bubble up an owner hierarchy by calling
`this.getBubbleTarget()` if present. There is no implementation in the Observable
base class.

This is commonly used by Ext.Components to bubble events to owner Containers.
See {@link Ext.Component#getBubbleTarget}. The default implementation in Ext.Component
returns the Component's immediate owner. But if a known target is required, this can be
overridden to access the required target more quickly.

Example:

    Ext.define('Ext.overrides.form.field.Base', {
        override: 'Ext.form.field.Base',

        //  Add functionality to Field's initComponent to enable
        // the change event to bubble
        initComponent: function () {
            this.callParent();
            this.enableBubble('change');
        }
    });

    var myForm = Ext.create('Ext.form.Panel', {
        title: 'User Details',
        items: [{
            ...
        }],
        listeners: {
            change: function() {
                // Title goes red if form has been modified.
                myForm.header.setStyle('color', 'red');
            }
        }
    });
">enableBubble</option>
    <option value="The method finds this floated component's floatParent. That means a DOM positioning
container which acts as a root element for sibling floated components, and allows allows
floated components to be absolutely positioned, and their encapsulating elements to be
reordered to produce a visual stacking effect.

This component's element is appended to its floatParent.

There is a global floatParent element, created on demand when the first top level
floated component is shown. This may be an item child of a container configured with
`{@link #cfg!floated #cfg-floated}: true`, or a free `{@link #cfg!floated floated}` component which is programatically
{@link Ext.Component#show shown}.

Child items of components inside a floated component may also be configured `{@link #cfg!floated floated}`.
These are give a floatParent which is created on demand wrapping the nearest `{@link #cfg!floated floated}`
ancestor. This means that when that ancestor's element is brought to the top of the
stack (by moving its element to the end of its own floatParent), the descendant elements
will automatically remain above.
">findFloatParent</option>
    <option value="Finds an alternate Component to focus if this Component is disabled while focused, or
focused while disabled, or otherwise unable to focus.

In both cases, focus must not be lost to document.body, but must move to an intuitively
connectible Component, either a sibling, or uncle or nephew.

This is both for the convenience of keyboard users, and also for when focus is tracked
within a Component tree such as for ComboBoxes and their dropdowns.

For example, a ComboBox with a PagingToolbar in is BoundList. If the "Next Page"
button is hit, the LoadMask shows and focuses, the next page is the last page, so
the "Next Page" button is disabled. When the LoadMask hides, it attempt to focus the
last focused Component which is the disabled "Next Page" button. In this situation,
focus should move to a sibling within the PagingToolbar.
">findFocusTarget</option>
    <option value="Retrieves plugin by its `type` alias. For example:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

     list.findPlugin('pullrefresh').setPullRefreshText('Pull to refresh...');

**Note:** See also {@link #method!getPlugin #getPlugin}.
">findPlugin</option>
    <option value="Fires the specified event with the passed parameters and executes a function (action).
By default, the action function will be executed after any "before" event handlers
(as specified using the `order` option of
`{@link Ext.util.Observable#method!addListener addListener}`), but before any other
handlers are fired.  This gives the "before" handlers an opportunity to
cancel the event by returning `false`, and prevent the action function from
being called.

The action can also be configured to run after normal handlers, but before any "after"
handlers (as specified using the `order` event option) by passing `'after'`
as the `order` parameter.  This configuration gives any event handlers except
for "after" handlers the opportunity to cancel the event and prevent the action
function from being called.
">fireAction</option>
    <option value="Fires the specified event with the passed parameters (minus the event name, plus
the `options` object passed to {@link Ext.util.Observable#method!addListener addListener}).

An event may be set to bubble up an Observable parent hierarchy (See
{@link Ext.Component#getBubbleTarget}) by calling {@link #method!enableBubble #enableBubble}.
">fireEvent</option>
    <option value="Fires the specified event with the passed parameter list.

An event may be set to bubble up an Observable parent hierarchy
(See {@link Ext.Component#getBubbleTarget}) by calling {@link #method!enableBubble #enableBubble}.
">fireEventArgs</option>
    <option value="Fires the specified event with the passed parameters and executes a function (action).
Evented Actions will automatically dispatch a 'before' event passing. This event will
be given a special controller that allows for pausing/resuming of the event flow.

By pausing the controller the updater and events will not run until resumed. Pausing,
however, will not stop the processing of any other before events.
">fireEventedAction</option>
    <option value="Try to focus this component.

If this component is disabled or otherwise not focusable, a close relation
will be targeted for focus instead to keep focus localized for keyboard users.
">focus</option>
    <option value="Prepares information on aligning this to component using alignment.
Also checks to see if this is already aligned to component according to alignment.
">getAlignmentInfo</option>
    <option value="undefined">getAlignRegion</option>
    <option value="Find component(s) that label or describe this component,
and return the id(s) of their ariaEl elements.
">getAriaLabelEl</option>
    <option value="Gets the bubbling parent for an Observable
">getBubbleParent</option>
    <option value="undefined">getClassCls</option>
    <option value="Returns a specified config property value. If the name parameter is not passed,
all current configuration options will be returned as key value pairs.
">getConfig</option>
    <option value="Returns the {@link Ext.app.ViewController} instance associated with this
component via the {@link #cfg!controller #controller} config or {@link #setController} method.
">getController</option>
    <option value="Current Alignment information from the last alignTo call
">getCurrentAlignmentInfo</option>
    <option value="undefined">getCurrentConfig</option>
    <option value="A template method for modifying the {@link #property!element #element} config before it is processed.
By default adds the result of `this.getTemplate()` as the `children` array of
{@link #property!element #element} if `children` were not specified in the original
{@link #property!element #element} config.  Typically this method should not need to be implemented
in subclasses.  Instead the {@link #property!element #element} property should be use to configure
the element template for a given Widget subclass.

This method is called once when the first instance of each Widget subclass is
created.  The element config object that is returned is cached and used as the template
for all successive instances.  The scope object for this method is the class prototype,
not the instance.
">getElementConfig</option>
    <option value="*For {@link #cfg!floated #cfg-floated} components only. *

Finds the owning {@link #cfg!floated #cfg-floated} component (if any) responsible for
the base z-index stack position of this compoonent, and, if that component
is {@link #cfg!relative #cfg-relative}, for the coordinate system in which this component
is positioned.

If this is a top level floated component, this method will return `null`
">getFloatParent</option>
    <option value="This method returns, or creates on demand the floatWrap element which wraps the passed
floated component. It enables that floated component to act as a host for descendant
floated components.
">getFloatWrap</option>
    <option value="Returns the element used to apply focus styling CSS class when Focusable's
{@link #property!focusEl #focusEl} becomes focused. By default it is {@link #property!focusEl #focusEl}.
">getFocusClsEl</option>
    <option value="Returns the main focus holder element associated with this Focusable, i.e.
the element that will be focused when Focusable's {@link #method!focus} method is
called. For most Focusables, this will be the {@link #property!focusEl #focusEl}.
">getFocusEl</option>
    <option value="Retrieves the `id`. This method Will auto-generate an id if one has not already
been configured.
">getId</option>
    <option value="This method returns an object containing the inherited properties for this instance.
">getInherited</option>
    <option value="This method returns the value of a config property that may be inherited from some
ancestor.

In some cases, a config may be explicitly set on a component with the intent of
*only* being presented to its children while that component should act upon the
inherited value (see `referenceHolder` for example). In these cases the `skipThis`
parameter should be specified as `true`.
">getInheritedConfig</option>
    <option value="Returns the initial configuration passed to the constructor when
instantiating this class.

Given this example Ext.button.Button definition and instance:

    Ext.define('MyApp.view.Button', {
        extend: 'Ext.button.Button',
        xtype: 'mybutton',

        scale: 'large',
        enableToggle: true
    });

    var btn = Ext.create({
        xtype: 'mybutton',
        renderTo: Ext.getBody(),
        text: 'Test Button'
    });

Calling `btn.getInitialConfig()` would return an object including the config
options passed to the `{@link #static-method!create create}` method:

    xtype: 'mybutton',
    renderTo: // The document body itself
    text: 'Test Button'

Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
">getInitialConfig</option>
    <option value="Retrieves a plugin by its `id`.

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '<div class="item">{title}</div>',
         store: 'Items',

         plugins: [{
             type: 'pullrefresh',
             id: 'foo'
         }]
     });

     list.getPlugin('foo').setPullRefreshText('Pull to refresh...');

**Note:** See also {@link #method!findPlugin #findPlugin}.
">getPlugin</option>
    <option value="Used by {@link Ext.ComponentQuery}, and the {@link Ext.Component#method!up up}
method to find the owning Component in the linkage hierarchy.

By default this returns the Container which contains this Component.

This may be overridden by Component authors who implement ownership hierarchies
which are not based upon ownerCt, such as BoundLists being owned by Fields or Menus
being owned by Buttons.
">getRefOwner</option>
    <option value="Returns the height and width of the Component.
">getSize</option>
    <option value="Return the actual tabIndex for this Focusable.
">getTabIndex</option>
    <option value="undefined">handleBlurEvent</option>
    <option value="undefined">handleFocusEvent</option>
    <option value="Checks if the specified CSS class exists on this element's DOM node.
">hasCls</option>
    <option value="undefined">hasConfig</option>
    <option value="Checks to see if this object has any listeners for a specified event, or whether
the event bubbles. The answer indicates whether the event needs firing or not.
">hasListener</option>
    <option value="This method triggers the lazy configs and must be called when it is time to
fully boot up. The configs that must be initialized are: `{@link #cfg!bind bind}`, `{@link #cfg!publishes publishes}`,
`{@link #cfg!session session}`, `{@link #cfg!twoWayBindable twoWayBindable}` and `{@link #cfg!viewModel viewModel}`.
">initBindable</option>
    <option value="Initialize configuration for this class. a typical example:

    Ext.define('My.awesome.Class', {
        // The default config
        config: {
            name: 'Awesome',
            isAwesome: true
        },

        constructor: function(config) {
            this.initConfig(config);
        }
    });

    var awesome = new My.awesome.Class({
        name: 'Super Awesome'
    });

    alert(awesome.getName()); // 'Super Awesome'
">initConfig</option>
    <option value="Initializes the Element for this Widget instance.  If this is the first time a
Widget of this type has been instantiated the {@link #property!element #element} config will be
processed to create an Element.  This Element is then cached on the prototype (see
afterCachedConfig) so that future instances can obtain their element by simply
cloning the Element that was cached by the first instance.
">initElement</option>
    <option value="Called for the first instance of this Widget to create an object that contains the
listener configs for all of the element references keyed by reference name. The
object is cached on the prototype and has the following shape:

    _elementListeners: {
        element: {
            click: 'onClick',
            scope: this
        },
        fooReference: {
            tap: {
                fn: someFunction,
                delay: 100
            }
        }
    }

The returned object is prototype chained to the _elementListeners object of its
superclass, and each key in the object is prototype chained to object with the
corresponding key in the superclass _elementListeners.  This allows element
listeners to be inherited and overridden when subclassing widgets.

This method is invoked with the prototype object as the scope
">initElementListeners</option>
    <option value="Sets up the focus listener on this Component's {@link #method!getFocusEl focusEl} if it has one.

Form Components which must implicitly participate in tabbing order usually have
a naturally focusable element as their {@link #method!getFocusEl focusEl}, and it is
the DOM event of that receiving focus which drives the Component's `{@link #method!onFocus onFocus}` handling,
and the DOM event of it being blurred which drives the `{@link #method!onBlur onBlur}` handling.
">initFocusableElement</option>
    <option value="Template method to do any event listener initialization for a Focusable.
This generally happens after the focusEl is available.
">initFocusableEvents</option>
    <option value="This method is called to initialize the `inheritedState` objects for this instance.
This amounts to typically copying certain properties from the instance to the given
object.
">initInheritedState</option>
    <option value="This method should be called when the instance is ready to start listening for
keyboard events. This is called automatically for `{@link Ext.Component}` and derived
classes. This is done after the component is rendered.
">initKeyMap</option>
    <option value="Initializes a "uiReference".  Ui rerefences are reference elements that have
classCls and ui info in their CSS class names.  They can be used by setting
uiCls in the template, or by invoking this method to setup the ui reference
after element/template initialization (Toolable uses this for its dock wrapper)
">initUiReference</option>
    <option value="This method inserts this floated component's DOM into its owning floatParent.
">insertFloatedDom</option>
    <option value="This method marks the current inherited state as invalid. The next time a call is
made to `{@link #method!getInherited getInherited}` the objects will be recreated and initialized.
">invalidateInheritedState</option>
    <option value="Tests whether this Widget matches a {@link Ext.ComponentQuery}
selector string.
">is</option>
    <option value="Determines whether **this Component** is an ancestor of the passed Component.
This will return `true` if the passed Component is anywhere within the subtree
beneath this Component.
">isAncestor</option>
    <option value="undefined">isBlurring</option>
    <option value="Determines if the passed property name is bound to ViewModel data.
">isBound</option>
    <option value="Determines whether this component is the descendant of a passed component.
">isDescendantOf</option>
    <option value="Determines if this Component is inside a Component tree which is destroyed, *or
is being destroyed*.
">isDestructing</option>
    <option value="Returns `true` if this Component is currently disabled.
">isDisabled</option>
    <option value="Returns `true` if this Component is not currently disabled.
">isEnabled</option>
    <option value="Determine if this Focusable can receive focus at this time.

Note that Containers can be non-focusable themselves while delegating
focus treatment to a child Component; see {@link Ext.Container}
for more information.
">isFocusable</option>
    <option value="undefined">isFocusing</option>
    <option value="undefined">isHeighted</option>
    <option value="Returns `true` if this Component is currently hidden.
">isHidden</option>
    <option value="Checks if all events, or a specific event, is suspended.
">isSuspended</option>
    <option value="Checks if a particular binding is synchronizing the value.
">isSyncing</option>
    <option value="Returns `true` if this Component is currently visible.

A Widget is visible if its element is not hidden, *and* has been
{@link #property!rendered} *and* has not been destroyed.
">isVisible</option>
    <option value="undefined">isWidthed</option>
    <option value="Tests whether or not this Component is of a specific xtype. This can test whether this
Component is descended from the xtype (default) or whether it is directly of the xtype
specified (`shallow = true`).
**If using your own subclasses, be aware that a Component must register its own xtype
to participate in determination of inherited xtypes.__

For a list of all available xtypes, see the {@link Ext.Component} header.

Example usage:

    var t = new Ext.field.Text();
    var isText = t.isXType('textfield'); // true
    var isBoxSubclass = t.isXType('field'); // true, descended from Ext.field.Field
    var isBoxInstance = t.isXType('field', true); // false, not a direct
                                                  // Ext.field.Field instance
">isXType</option>
    <option value="Adds a "destroyable" object to an internal list of objects that will be destroyed
when this instance is destroyed (via `{@link #method!destroy}`).
">link</option>
    <option value="Gets the controller that controls this view. May be a controller that belongs
to a view higher in the hierarchy.
">lookupController</option>
    <option value="Gets the Form or Component that is used as the name holder for this component.
">lookupNameHolder</option>
    <option value="Gets the Controller or Component that is used as the reference holder for this view.
">lookupReferenceHolder</option>
    <option value="Returns the `{@link Ext.data.Session}` for this instance. This property may come
from this instance's `{@link #cfg!session #session}` or be inherited from this object's parent.
">lookupSession</option>
    <option value="Gets a named template instance for this class. See {@link Ext.XTemplate#static-method!getTpl Ext.XTemplate#getTpl}.
">lookupTpl</option>
    <option value="Returns the `{@link Ext.app.ViewModel}` for this instance. This property may come from this
this instance's `{@link #cfg!viewModel #viewModel}` or be inherited from this object's parent.
">lookupViewModel</option>
    <option value="Shorthand for {@link #method!addManagedListener #addManagedListener}.
The addManagedListener method is used when some object (call it "A") is listening
to an event on another observable object ("B") and you want to remove that listener
from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
all of its listeners will be removed at that time.

Example:

    Ext.define('Foo', {
        extend: 'Ext.Component',

        initComponent: function () {
            this.addManagedListener(MyApp.SomeSharedMenu, 'show', this.doSomething);
            this.callParent();
        }
    });

As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.

As of version 5.1 it is no longer necessary to use this method in most cases because
listeners are automatically managed if the scope object provided to
{@link Ext.util.Observable#method!addListener addListener} is an Observable instance.
However, if the observable instance and scope are not the same object you
still need to use `{@link #method!mon mon}` or `{@link #method!addManagedListener addManagedListener}` if you want the listener to be
managed.
">mon</option>
    <option value="Shorthand for {@link #method!removeManagedListener #removeManagedListener}.
Removes listeners that were added by the {@link #method!mon #mon} method.
">mun</option>
    <option value="The {@link #method!on #on} method is shorthand for
{@link Ext.util.Observable#method!addListener addListener}.

Appends an event handler to this object.  For example:

    myGridPanel.on("itemclick", this.onItemClick, this);

The method also allows for a single argument to be passed which is a config object
containing properties which specify multiple events. For example:

    myGridPanel.on({
        cellclick: this.onCellClick,
        select: this.onSelect,
        viewready: this.onViewReady,
        scope: this // Important. Ensure "this" is correct during handler execution
    });

One can also specify options for each event handler separately:

    myGridPanel.on({
        cellclick: {fn: this.onCellClick, scope: this, single: true},
        viewready: {fn: panel.onViewReady, scope: panel}
    });

*Names* of methods in a specified scope may also be used:

    myGridPanel.on({
        cellclick: {fn: 'onCellClick', scope: this, single: true},
        viewready: {fn: 'onViewReady', scope: panel}
    });
">on</option>
    <option value="undefined">onAdded</option>
    <option value="Appends an after-event handler.

Same as {@link Ext.util.Observable#method!addListener addListener} with `order` set
to `'after'`.
">onAfter</option>
    <option value="Appends a before-event handler.  Returning `false` from the handler will stop the event.

Same as {@link Ext.util.Observable#method!addListener addListener} with `order` set
to `'before'`.
">onBefore</option>
    <option value="undefined">onBlur</option>
    <option value="undefined">onFocus</option>
    <option value="Called when focus enters this Component's hierarchy
">onFocusEnter</option>
    <option value="Called when focus exits from this Component's hierarchy
">onFocusLeave</option>
    <option value="Called when focus moves *within* this Component's hierarchy
">onFocusMove</option>
    <option value="Called when this Inheritable is added to a parent
">onInheritedAdd</option>
    <option value="Called when this inheritable is removed from a parent
">onInheritedRemove</option>
    <option value="This method is called the first time a component is inserted into the DOM. If this
component {@link Ext.Container} other components, the `{@link #method!onRender onRender}` method
for child components is called *after* the parent's `{@link #method!onRender onRender}`.

Implementations of this method should avoid modifying the DOM but are free to read
from and measure elements as needed. To adjust the DOM, consider implementing
{@link #method!afterRender afterRender} instead.

If this method is overridden, be sure to use `callParent` to call the base class
version.

     onRender: function() {
         this.callParent();

         // custom actions
     }

This method is not generally needed because components always have their own DOM
{@link #property!element} and these are maintained by config property
updaters prior to insertion in the DOM. In general, it is always best to interrogate
the component's elements outside the DOM where there is no associated reflow or
layout cost. This method is useful for situations where the component's elements
must be in the DOM. For example to be measured correctly.
">onRender</option>
    <option value="Returns `true` if the passed element is within the container tree of this component.

For example if a menu's submenu contains an {@link Ext.form.field.Date}, that top level
menu owns the elements of the date picker. Using this method, you can tell if an event
took place within a certain component tree.
">owns</option>
    <option value="Recursively processes the element templates for this class and its superclasses,
ascending the hierarchy until it reaches a superclass whose element template
has already been processed.  This method is invoked using the prototype as the scope.
">processElementConfig</option>
    <option value="Publish this components state to the `ViewModel`. If no arguments are given (or if
this is the first call), the entire state is published. This state is determined by
the `{@link #cfg!publishes publishes}` property.

This method is called only by component authors.
">publishState</option>
    <option value="undefined">realign</option>
    <option value="Relays selected events from the specified Observable as if the events were fired
by `this`.

For example if you are extending Grid, you might decide to forward some events from
store. So you can do this inside your initComponent:

    this.relayEvents(this.getStore(), ['load']);

The grid instance will then have an observable 'load' event which will be passed
the parameters of the store's load event and any function fired with the grid's
load event would have access to the grid using the this keyword (unless the event
is handled by a controller's control/listen event listener in which case 'this'
will be the controller rather than the grid).
">relayEvents</option>
    <option value="Alias for {@link #method!unAfter #unAfter}.
">removeAfterListener</option>
    <option value="Alias for {@link #method!unBefore #unBefore}.
">removeBeforeListener</option>
    <option value="Removes the given CSS class(es) from this widget's primary element.
">removeCls</option>
    <option value="Removes delegated listeners for a given eventName, function, and scope.
Users should not invoke this method directly.  It is called automatically by
the framework as part of {@link #method!removeListener #removeListener} processing.
">removeDelegatedListener</option>
    <option value="Removes an event handler.
">removeListener</option>
    <option value="Removes listeners that were added by the {@link #method!mon #mon} method.
">removeManagedListener</option>
    <option value="Remove a single managed listener item
">removeManagedListenerItem</option>
    <option value="Removes and (optionally) destroys a plugin.

**Note:** Not all plugins are designed to be removable. Consult the documentation
for the specific plugin in question to be sure.
">removePlugin</option>
    <option value="Replaces specified classes with the newly specified classes.
It uses the {@link #method!addCls #addCls} and {@link #method!removeCls #removeCls} methods, so if the class(es) you
are removing don't exist, it will still add the new classes.
">replaceCls</option>
    <option value="Gets the default scope for firing late bound events (string names with
no scope attached) at runtime.
">resolveListenerScope</option>
    <option value="Returns the default listener scope for a "satellite" of this component.
Used for resolving scope for observable objects that are not part of the normal
Container/Component hierarchy (for example, plugins)
">resolveSatelliteListenerScope</option>
    <option value="Resumes firing of the named event(s).

After calling this method to resume events, the events will fire when requested to fire.

**Note that if the {@link #method!suspendEvent #suspendEvent} method is called multiple times for a certain
event, this converse method will have to be called the same number of times for it
to resume firing.**
">resumeEvent</option>
    <option value="Resumes firing events (see {@link #method!suspendEvents #suspendEvents}).

If events were suspended using the `queueSuspended` parameter, then all events fired
during event suspension will be sent to any listeners now.
">resumeEvents</option>
    <option value="Returns focus to the Component or element found in the cached
focusEnterEvent.
">revertFocus</option>
    <option value="This field is on the recieving end of a call from {@link #method!revertFocus}.

It is called when focus is being pushed back into this Component from a Component
that is focused and is being hidden or disabled.

We must focus the passed element.

Subclasses may perform some extra processing to prepare for refocusing.
">revertFocusTo</option>
    <option value="Sets a single/multiple configuration options.
">setConfig</option>
    <option value="Sets the current Alignment information, called by alignTo
">setCurrentAlignmentInfo</option>
    <option value="An alias for {@link Ext.util.Observable#method!addListener addListener}.  In
versions prior to 5.1, {@link #cfg!listeners #listeners} had a generated setter which could
be called to add listeners.  In 5.1 the listeners config is not processed
using the config system and has no generated setter, so this method is
provided for backward compatibility.  The preferred way of adding listeners
is to use the {@link #method!on #on} method.
">setListeners</option>
    <option value="All Components need a potentially recursive setRendered because some are
pseudo containers, such as grid {@link Ext.grid.Row}, and some mix in
{@link Ext.mixin.Toolable}.
">setRendered</option>
    <option value="Sets the size of the Component.
">setSize</option>
    <option value="Set the tabIndex property for this Focusable. If the focusEl
is available, set tabIndex attribute on it, too.
">setTabIndex</option>
    <option value="Get the reference to the class from which this object was instantiated. Note that unlike
{@link Ext.Base#property!self Ext.Base#self}, `this.statics()` is scope-independent and it always returns
the class from which it was called, regardless of what `this` points to during run-time

    Ext.define('My.Cat', {
        statics: {
            totalCreated: 0,
            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
        },

        constructor: function() {
            var statics = this.statics();

            // always equals to 'Cat' no matter what 'this' refers to
            // equivalent to: My.Cat.speciesName
            alert(statics.speciesName);


            alert(this.self.speciesName);   // dependent on 'this'

            statics.totalCreated++;
        },

        clone: function() {
            var cloned = new this.self();   // dependent on 'this'

            // equivalent to: My.Cat.speciesName
            cloned.groupName = this.statics().speciesName;

            return cloned;
        }
    });


    Ext.define('My.SnowLeopard', {
        extend: 'My.Cat',

        statics: {
            speciesName: 'Snow Leopard' // My.SnowLeopard.speciesName = 'Snow Leopard'
        },

        constructor: function() {
            this.callParent();
        }
    });

    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'

    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'

    var clone = snowLeopard.clone();
    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
    alert(clone.groupName);                 // alerts 'Cat'

    alert(My.Cat.totalCreated);             // alerts 3
">statics</option>
    <option value="Suspends firing of the named event(s).

After calling this method to suspend events, the events will no longer fire when
requested to fire.

**Note that if this is called multiple times for a certain event, the converse method
{@link #method!resumeEvent #resumeEvent} will have to be called the same number of times for it to resume
firing.**
">suspendEvent</option>
    <option value="Suspends the firing of all events. (see {@link #method!resumeEvents #resumeEvents})
">suspendEvents</option>
    <option value="Fixes up the alwaysOnTop order of this floated widget within its siblings.
">syncAlwaysOnTop</option>
    <option value="Synchronizes the size and position of the {@link #method!getFloatWrap floatWrap}
when this Widget is resized
">syncFloatWrap</option>
    <option value="Synchronizes an alignment cls on the tool dock wrapper when the alignment changes.
Only applicable for toolable components that have an `align` config such as
grid cells and column headers
">syncToolableAlign</option>
    <option value="Brings a {@link #cfg!floated #cfg-floated} Component to the front of any other visible, floated
Components while honoring all {@link #cfg!alwaysOnTop} settings. This may not become
topmost if another visible floated component has a higher {@link #cfg!alwaysOnTop} value.

If this Component becomes the topmost *modal* floated component, the the shared modal
mask is moved to just below this Component.
">toFront</option>
    <option value="Toggles the specified CSS class on this element (removes it if it already exists,
otherwise adds it).
">toggleCls</option>
    <option value="Shorthand for {@link #method!removeListener #removeListener}.
Removes an event handler.
">un</option>
    <option value="Removes a before-event handler.

Same as {@link #method!removeListener #removeListener} with `order` set to `'after'`.
">unAfter</option>
    <option value="Removes a before-event handler.

Same as {@link #method!removeListener #removeListener} with `order` set to `'before'`.
">unBefore</option>
    <option value="Destroys a given set of `{@link #method!link linked}` objects. This is only needed if
the linked object is being destroyed before this instance.
">unlink</option>
    <option value="Walks up the ownership hierarchy looking for an ancestor Component which matches
the passed simple selector.

Example:

    var owningTabPanel = grid.up('tabpanel');
">up</option>
    <option value="All cls methods directly report to the {@link #cfg!cls #cls} configuration, so anytime it changes,
{@link #method!updateCls #updateCls} will be called
">updateCls</option>
    <option value="undefined">updateHeight</option>
    <option value="Updates the session config.
">updateSession</option>
    <option value="Updates the viewModel config.
">updateViewModel</option>
    <option value="undefined">updateWidth</option>
    <option value="Watches config properties.

     instance.watchConfig({
         title: 'onTitleChange',
         scope: me
     });
">watchConfig</option>
</select></div>
</div>
  <div id="method" class="thetext"></div>
</div>
        </z-tabpanel>
        <z-tabpanel tabname="events">
<div class="flex-container">
  <div id="eventlist" class="thelist"><div>events:</div><div class="select-div"><select id="events" onchange="changeEvent()" name="events">
    <option value="This event fires when `{@link #cfg!disabled}` changes.">beforedisabledchange</option>
    <option value="This event fires when `{@link #cfg!height}` changes.">beforeheightchange</option>
    <option value="This event fires when `{@link #cfg!hidden}` changes.">beforehiddenchange</option>
    <option value="Fires before a {@link #cfg!floated #cfg-floated} component is brought to the front of the visual stack.
">beforetofront</option>
    <option value="This event fires when `{@link #cfg!width}` changes.">beforewidthchange</option>
    <option value="Fires when this Component's {@link #property!focusEl #focusEl} loses focus.
">blur</option>
    <option value="This event fires when `{@link #cfg!disabled}` changes.">disabledchange</option>
    <option value="Fires when this Component's {@link #property!focusEl #focusEl} receives focus.
">focus</option>
    <option value="Fires when focus enters this Component's hierarchy.
">focusenter</option>
    <option value="Fires when focus leaves this Component's hierarchy.
">focusleave</option>
    <option value="This event fires when `{@link #cfg!height}` changes.">heightchange</option>
    <option value="This event fires when `{@link #cfg!hidden}` changes.">hiddenchange</option>
    <option value="Fires when a {@link #cfg!floated #cfg-floated} component has been brought to the front of the visual
stack.
">tofront</option>
    <option value="This event fires when `{@link #cfg!width}` changes.">widthchange</option>
</select></div>
</div>
  <div id="event" class="thetext"></div>
</div>
        </z-tabpanel>
    </z-tabs>
</div>

<p>
------------------
<pre>This class displays a numeric value in a {@link Ext.grid.Grid} cell. This cell type
is typically used by specifying {@link Ext.grid.column.Number} column type.

{@link Ext.grid.Row} create cells based on the {@link Ext.grid.column.Column#cfg!cell Ext.grid.column.Column#cell}
config. Application code would rarely create cells directly.
</pre>

<span><b>Ext JS name:</b></span>
<br>
<span>Ext.grid.cell.Number</span>
<br><br>
<span><b>others:</b></span>
extend: 
extenders: Ext.grid.cell.RowNumberer
mixed: Ext.Mixin,Ext.mixin.Accessible,Ext.mixin.Bindable,Ext.mixin.ComponentDelegation,Ext.mixin.Factoryable,Ext.mixin.Focusable,Ext.mixin.Identifiable,Ext.mixin.Inheritable,Ext.mixin.Keyboard,Ext.mixin.Observable,Ext.mixin.Pluggable,Ext.mixin.Toolable
mixins: 
requires: Ext.util.Format
src: [object Object]



</div>

</body>
</html>